<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>我为什么要搬离CSDN Blog？</title>
    <link href="/2020/07/02/why-should-I-move-away-from-CSDN-blog/"/>
    <url>/2020/07/02/why-should-I-move-away-from-CSDN-blog/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>终于要搬家啦 传送门：<a href="https://kongkongk.github.io/" target="_blank" rel="noopener">https://kongkongk.github.io/</a></em> *</strong></p><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>从大学开始，逐渐深入接触计算机相关知识，当时也有产出一些总结（无论是纸质化或本地markdown），俗称个人笔记。后来接触到 CSDN，才有想法将这些沉淀的知识总结迁移到 Blog 中。原因也很简单，不能走哪都抱着一厚沓纸，实时查阅的功能更是没有，所以最终决定将本地文档迁移至CSDN Blog。</p><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>此时有几个问题浮现脑海，这些问题需要思考清楚</p><ul><li>为什么用的好好的，却要开始搬家迁移 Blog ？<br> CSDN 属于商业应用，变现是理所当然。但计算机技术领域面向的目标人群很窄，扩展目标用户就变得很难，那就要从变现途径入手了，所以越来越多的广告开始出现在 Blog 中，我现在终于受不了了。</li><li>新 Blog 如何维护？<br>新 Blog 将迁移至 Github，基于 Github Pages + Hexo 构建。同时无需维护服务器、域名和证书等资源，这一点和现在 CSDN Blog 相同，否则后续维护成本将大大提高。</li><li>历史文档的迁移成本有多少？<br>当前 CSDN Blog 文档使用 markdown 编辑，markdown 作为文档编辑语法既好用又成熟，后续 Blog 也将继续使用，因此文档迁移成本还在可接受范围内。<h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3>目前新  Blog 雏形已经搭建完成，但相关个性化信息还没怎么玩，文档也没有开始迁移。。。</li></ul><p>TODO</p><ul><li>后续将逐步优化新 Blog 个性化，使用开源模版提升交互性、可视化性和可扩展性</li><li>同时有序将 CSDN 原创文档迁移至新 Blog</li><li>后续将只在新 Blog 中继续更新 <a href="https://kongkongk.github.io/" target="_blank" rel="noopener">https://kongkongk.github.io/</a></li></ul><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><p>再见 <a href="https://blog.csdn.net/kongkongkkk" target="_blank" rel="noopener">https://blog.csdn.net/kongkongkkk</a>，你好 <a href="https://kongkongk.github.io/" target="_blank" rel="noopener">https://kongkongk.github.io/</a> </p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感想随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>未来的学习方向</title>
    <link href="/2020/07/02/future-learning-direction/"/>
    <url>/2020/07/02/future-learning-direction/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>我的征途是星辰大海！</em> *</strong></p><p><strong>传送门：</strong></p><p><a href="http://www.infoq.com/cn/articles/mogujie-11-11-private-cloud-platform-docker-application" target="_blank" rel="noopener">蘑菇街11.11：私有云平台的Docker应用实践</a></p><p><a href="http://cloud.51cto.com/art/201511/496288.htm" target="_blank" rel="noopener">蘑菇街基于 OpenStack 和 Docker 的私有云实践</a></p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感想随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的秋招经历（已完结）</title>
    <link href="/2020/07/02/my-autumn-recruiting-experience/"/>
    <url>/2020/07/02/my-autumn-recruiting-experience/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>随着提前批又一次提前到来。。。秋招大幕徐徐拉开。。。本篇就来记录我的秋招经历吧。。。→_→</em> *</strong></p><p><strong>秋招结束！终于可以歇一阵了~</strong></p><h3 id="CVTE"><a href="#CVTE" class="headerlink" title="CVTE"></a><strong>CVTE</strong></h3><p><strong>结果：收到书面offer</strong></p><p>时间：2017.08.08<br>内容：CVTE提前批一面<br>结果：GG<br>面经：</p><ul><li><p>介绍项目</p><ul><li>（介绍项目的时候，面试管其实也在看简历。。。）</li></ul></li><li><p>项目中遇到的最大困难是什么？</p></li><li><p>虚函数表中有没有名字？</p><ul><li>（我的回答是没有，然后用了非常长的时间去解释为什么没有，面试官表达了我说的不对的意思，然后我就问面试官“怎么会有名字？”，面试官说“我没有说有名字哦”此时心态已炸。。。）</li></ul></li><li><p>私有继承是is-a还是has-s？</p></li><li><p>进程中能开多少个线程？</p></li><li><p>如何避免死锁</p></li><li><p>线程间同步有哪些方法？</p></li><li><p>vector如何扩容？具体过程？</p></li><li><p>vector和list的区别？适用场景？</p></li><li><p>仿函数和函数指针的区别？</p></li><li><p>private和protect的区别</p></li><li><p>熟不熟悉智能指针？shared_ptr什么时候引用计数加1？</p></li><li><p>map中[]运算符和find运算符有什么区别？</p></li><li><p>new和malloc的区别？</p></li><li><p>平常遇到困难怎么解决？</p></li><li><p>怎样学习新知识？</p></li></ul><p>总结：</p><ul><li>秋招第一面可以说是GG的非常快。。预约的15：00-16：00时间段，18：00左右才叫去面试。。倒数第二个未面试的。。没去过面试地点，所以去的也比较早，以至于等了很久，面试的时候状态已经很差了。。又饿又累。。。面试官全程都是从他提前准备好的题目中进行提问的，回答中向面试官递了很多点，可是面试官并不接你的点。。所以全程的回答都是为了解决所提出的问题。。到后面我都觉得给他递点非常的尴尬。。还是继续继续努力吧。。</li></ul><p>时间：2017.09.11<br>内容：CVTE校招一面<br>面经：</p><ul><li>记不清了。。。</li></ul><p>时间：2017.09.11<br>内容：CVTE校招二面<br>面经：</p><ul><li>记不清了。。。</li></ul><h3 id="好未来"><a href="#好未来" class="headerlink" title="好未来"></a><strong>好未来</strong></h3><p><strong>结果：收到书面offer</strong></p><p>时间：2017.08.23<br>内容：好未来提前批一面（霸面）<br>结果：GG<br>面经：</p><ul><li><p>问了问比赛的相关内容</p></li><li><p>导师是做什么的？有没有导师？</p><ul><li>我们是本科啊。。。</li></ul></li><li><p>项目怎么写的？为什么写这个项目？</p></li><li><p>静态库和动态库？使用的优先级？</p><ul><li>说成静态链接和动态链接了。。。</li></ul></li><li><p>虚拟地址空间的内存布局？</p></li><li><p>栈里面存什么？</p></li><li><p>堆里面存什么？</p></li><li><p>重载和重写？</p></li><li><p>Linux中线程相关的函数有哪些？</p></li><li><p>线程同步的方法？</p></li><li><p>如何避免线程死锁？</p></li><li><p>银行家算法？</p><ul><li>要好好看看这个了。。。</li></ul></li><li><p>求数组中的最大子序列，元素有可能为负数、0、正数，要求时间复杂度小于O(n^2)</p></li><li><p>判断一个树是不是另一个树的子树，要求时间复杂度小于O(n^2)</p></li><li><p>判断两个单链表是否有交点，单链表可能有环，要求时间复杂度小于O(n+m)，空间复杂度为O(1)</p></li></ul><p>总结：</p><ul><li>霸面是和小伙伴一起去的，面试的时候就是我俩一起面（技术群面？）。。。面试官问有没有笔，然后就回去拿笔，再一次坐下时面试官说“你俩的简历有些相似啊”（PS：？？？）。手撕代码中的两道题之前都有刷过，但面试写时脑子就一片空白了。。。面试官还是很看重算法能力的。。。继续努力吧。。。</li></ul><p>时间：2017.09.25<br>内容：好未来校招一面<br>面经：</p><ul><li><p>自我介绍</p></li><li><p>一个程序的执行过程</p></li><li><p>手写单例模式</p></li><li><p>TCP滑动窗口如何理解的</p></li><li><p>进程有哪些状态，都来讲一讲</p></li><li><p>C++中的四种类型转换</p></li><li><p>进程间通信有哪些？</p></li><li><p>无名管道具体讲一讲？</p></li><li><p>手写归并排序</p></li><li><p>IO的阻塞与非阻塞如何理解</p></li><li><p>IO的同步与异步如何理解</p></li><li><p>手写二叉树的路径序列，如果有多个只用输出一个即可</p></li></ul><p>总结：</p><ul><li>面试小哥非常nice！写的代码中间有错误。。小哥和我在分析的时候都在一起讨论，已经感觉不到是在面试了。。。体验非常棒！本来预约的18：00，早上就去了，小姐姐说来早更好啊！继续加油！</li></ul><p>时间：2017.09.25<br>内容：好未来校招二面<br>面经：</p><ul><li><p>自我介绍</p></li><li><p>手写模拟实现pow（x，y）函数</p></li><li><p>TCP中的流量控制、滑动窗口、超时重传都讲一下</p></li><li><p>有没有什么问题</p></li></ul><p>总结：</p><ul><li>刚吃完中午饭就被叫去面试了。。。二面一上来就写代码。。写完后面试官会从几个方面提出让你优化代码，写完后面试官说，这个环节是很看重代码习惯的。。。最后其实就开始聊天了。。问了好未来的技术，面试官还介绍了未来的发展方向，给了我很多建议，非常棒的面试，结束时说我这面就是终面。。问“没有hr面吗。。？”答“社招有hr面谈薪资，我也算hr面”。。。继续加油！</li></ul><h3 id="蘑菇街"><a href="#蘑菇街" class="headerlink" title="蘑菇街"></a><strong>蘑菇街</strong></h3><p><strong>结果：收到书面offer</strong></p><p>时间：2017.08.28<br>内容：蘑菇街内推一面<br>面经：</p><ul><li><p>日常自我介绍</p></li><li><p>select和epoll的比较，为什么epoll更高效？</p></li><li><p>红黑树相关</p></li><li><p>操作系统中调度的基本单位是什么？</p></li><li><p>XXXX分布式相关的有没有了解过。。。（当时没听清。。。）</p></li><li><p>Linux内核中哪一块比较熟悉，来讲一讲。。。</p></li><li><p>IO同步异步、阻塞非阻塞是什么？</p></li><li><p>一致性哈希是什么？</p></li><li><p>内存管理知道多少？来讲一讲。。。</p></li><li><p>专业排名多少？相比其他同学优势、劣势？</p></li><li><p>重载和覆盖</p></li><li><p>gdb调试中如何跟踪函数调用栈？</p></li><li><p>伙伴系统知不知道？</p></li><li><p>TCP四次挥手时的TIME_WAIT和CLOSE_WAIT是什么？</p></li><li><p>拥塞窗口介绍一下</p></li><li><p>docker虚拟化相关的知不知道？</p></li><li><p>怎样在用户态跟踪系统调用？</p></li><li><p>讲一讲你遇到的bug和困难</p></li><li><p>有什么问题想问的？</p></li><li><p>代码量有多少？</p></li><li><p>如何确定内存泄漏？</p></li></ul><p>总结：</p><ul><li>哇。。。准时来电，赞！面试官很nice~有记不清的也给了答案，整场电面几乎都是我一直在说。。最后口干舌燥。。。很开心的一次面试！面试官说代码写的少，调试能力需要加强。。。最后面试官要去开会了。。。最后一个问题留给我思考。。就先结束了。。继续加油！</li></ul><p>时间：2017.08.30<br>内容：蘑菇街内推二面<br>面经：</p><ul><li><p>日常自我介绍</p></li><li><p>讲项目，直到给面试官讲清楚</p></li><li><p>针对项目的很多部分提问，并进行优化改进</p></li><li><p>Linux懂哪些，讲一讲系统调用</p></li><li><p>今后想往哪方面发展</p></li><li><p>有没有什么问题</p></li></ul><p>总结：</p><ul><li>依旧如此的准时！！！赞！二面可以说整场都是关于项目的。。。而且针对一些部分让你设计成更好的方案。。。有很多方法还是不知道。。。只能怪自己看的太少。。。继续加油！</li></ul><p>时间：2017.09.04<br>内容：蘑菇街内推hr面<br>面经：</p><ul><li>内（tao）容（lu）几乎都是差不多的。。。</li></ul><p>总结：</p><ul><li>真的是准时！赞！第三次赞了！继续加油！</li></ul><p>时间：2017.09.14<br>内容：蘑菇街内推四面<br>面经：</p><ul><li><p>人生。。理想。。未来方向。。。</p></li><li><p>有没有到诡异的bug？</p></li></ul><p>总结：</p><ul><li>怀着激动的心情迎来了四面视频面。。。在这里向CTO大佬低头致敬。。。这次面试其实很紧张的。。。第一次可以和这样的大神交流很值了。。。继续加油！</li></ul><h3 id="金山WPS"><a href="#金山WPS" class="headerlink" title="金山WPS"></a><strong>金山WPS</strong></h3><p><strong>结果：已拒hr面（把机会留给其他小伙伴。。）</strong></p><p>时间：2017.09.06<br>内容：金山WPS内推一面<br>面经：</p><ul><li><p>虚函数是什么？</p></li><li><p>C++重载是什么？</p></li><li><p>静态库和动态库是什么？</p></li><li><p>静态库和动态库中存的什么？</p></li><li><p>epoll为什么比select更高效？</p></li><li><p>一致性哈希是什么？</p></li><li><p>平衡二叉树是什么？</p></li><li><p>如何处理hash冲突？</p></li><li><p>boost和STL中的容器有什么不同？</p><ul><li>这个是真不知道。。。</li></ul></li><li><p>boost库中的智能指针讲一讲</p></li><li><p>STL中的模板定义和声明为什么都写在同一个文件中？</p><ul><li>？？？</li></ul></li><li><p>map的模板参数有哪些？</p></li><li><p>vector如何扩容？</p><ul><li>讲到一半，面试官说可以了。。。然后我俩都笑了。。。</li></ul></li><li><p>如何快速查找到一个单链表的中间位置？</p><ul><li>剑指offer原题。。。刷过的啊。。。脑子又抽了。。。</li></ul></li><li><p>TCP为什么三次握手？</p></li><li><p>一致性哈希是什么？</p></li><li><p>349的16进制是多少？</p></li><li><p>gdb调试的命令有哪些？</p></li><li><p>如何在gdb调试中传入参数？</p></li><li><p>单例模式怎么设计？</p></li></ul><p>总结：</p><ul><li>面试官特别有耐心！没听懂就问他是什么意思。。。然后他就会换一种方式解释。有些点之前没有看到过。。。下来要好总结了。。。最后没有让我提问啊。。。“后续通知hr会联系你的。。。”继续加油吧。。。</li></ul><p>时间：2017.09.27<br>内容：金山WPS内推二面<br>面经：</p><ul><li>具体的记不清了。。只记得一个如何统计文件中的单词个数，按序输出，设计程序，不用写代码</li></ul><p>总结：</p><ul><li>面试小哥再听了我的设计方案后，被我说的想不出反例，然后就让我写了一个求阶乘的代码，我写了递归的，然后他说再写个非递归的。。。写完后小哥说你看你这个方案，他有这个问题啊。。。哈哈。。我俩在设计方案上讨论了很长时间。。继续加油！</li></ul><h3 id="多益网络"><a href="#多益网络" class="headerlink" title="多益网络"></a><strong>多益网络</strong></h3><p><strong>结果：收到书面offer</strong></p><p>时间：2017.09.07<br>内容：多益网络提前批一面<br>面经：</p><ul><li><p>当然是自我介绍啦</p></li><li><p>讲项目</p></li><li><p>还有哪些负载算法？</p></li><li><p>项目中遇到了哪些问题，如何解决的？</p></li><li><p>日常中遇到问题怎么解决？</p></li><li><p>如果程序出现bug如何快速定位？</p></li><li><p>栈溢出是怎么回事？</p></li><li><p>vector介绍一下？</p></li><li><p>代码题</p><ul><li><p>写一段程序，去除一句英文句子中多余的空格。</p></li><li><p>例如输入“I am    a   student.” 输出”I am a student.”</p></li></ul></li><li><p>常用什么语言？</p></li><li><p>C++有什么缺点？</p></li><li><p>你最想往C++中添加什么功能？</p></li><li><p>玩过什么游戏？有没有玩过LOL？</p><ul><li>没有玩过LOL。。。玩过王者荣耀啊→_→</li></ul></li><li><p>王者荣耀比较适合用UDP还是TCP，UDP和TCP讲一讲？</p></li><li><p>网盘厂商如何提高磁盘利用率？</p></li><li><p>对互联网加班的看法？</p></li><li><p>现在找工作是什么状态？有没有offer？</p></li></ul><p>总结：</p><ul><li>第一次视频面试。。。中间好像是麦克风的问题。。。面试官听不见声音了。。。又重连了一次。。。之前一直都是二笔中。。。终于从备胎池捞出来了。。。如何提高磁盘利用率？？？面试官说还需要再多看看相关的。。。继续加油！</li></ul><h3 id="广联达"><a href="#广联达" class="headerlink" title="广联达"></a><strong>广联达</strong></h3><p><strong>结果：收到书面offer</strong></p><p>时间：2017.09.10<br>内容：广联达一面<br>面经：</p><ul><li><p>日常自我介绍</p></li><li><p>多态是什么？</p><ul><li>这里问的很细。。。有多细节面试官说和我的理解不一样。。。</li></ul></li><li><p>动态库和静态库是什么？</p></li><li><p>画一下C++对象的内存分布</p><ul><li>面试官让我自己设计类，然后画出内存分布</li></ul></li><li><p>观察者监听者模式讲一讲</p></li><li><p>MVC模式介绍一下</p></li><li><p>栈在程序中怎么运用</p></li><li><p>如果栈越界会发生什么？</p></li><li><p>介绍一下项目</p></li><li><p>项目中如何具体的调试</p></li><li><p>提问</p></li></ul><p>总结：</p><ul><li>面试官对一些细节很清楚。。。所以有些点记得有问题时，面试官就让我回去再看看。。。去了先做两道题。。。一道是查找数组中重复出现的所有数字，但不能用哈希，另一道是字符串的子集。。。在面试的时候会选一道让讲。。。继续加油！</li></ul><p>时间：2017.09.10<br>内容：广联达二面<br>面经：</p><ul><li>自我介绍</li><li>你有什么优点？你有什么缺点？</li><li>今后的规划？</li><li>你是一个怎样的人？</li><li>等等内（tao）容（lu）。。。</li></ul><p>总结：</p><ul><li>出来才知道这一面是经理面。。。继续加油喽！</li></ul><h3 id="猎豹移动"><a href="#猎豹移动" class="headerlink" title="猎豹移动"></a><strong>猎豹移动</strong></h3><p><strong>结果：收到书面offer</strong></p><p>时间：2017.09.13<br>内容：猎豹移动内推一面<br>面经：</p><ul><li><p>进程和线程是怎么理解的？</p></li><li><p>虚拟地址空间怎么理解的？</p></li><li><p>其中的栈和堆是什么？</p></li><li><p>函数调用过程讲一下？</p></li><li><p>栈溢出是什么？</p></li><li><p>可以申请多个堆吗？</p></li><li><p>虚拟地址映射讲一下？</p></li><li><p>页表是怎么初始化的？</p></li><li><p>熟悉哪些数据结构？每个的特点？</p></li><li><p>红黑树和AVL树比较一下？</p></li><li><p>ELF文件结构讲一下？</p></li><li><p>知不知道PE文件结构？</p></li><li><p>指针和引用的区别</p></li><li><p>编译链接过程讲一下？</p></li><li><p>静态链接和动态链接？</p></li><li><p>静态库和动态库？</p></li><li><p>算法题说思路。。。</p></li><li><p>提问</p></li></ul><p>总结：</p><ul><li>正在考试。。。就是猎豹移动的笔试。。。和面试官说了半个小时之后打过去。。。面试官咳嗽比较严重啊。。。希望您能早点好。。。又是一次口干舌燥。。。但面试官非常nice，问到不会的就说没关系，然后讲一下，再继续问下一个。。。继续加油！</li></ul><p>时间：2017.09.14<br>内容：猎豹移动内推二面<br>面经：</p><ul><li><p>昨天的字符串笔试题是什么思路？时间复杂度？空间复杂度？</p></li><li><p>有没有其他方法？</p><ul><li>比如STL中的方法或使用栈</li></ul></li><li><p>笔试题扩展：如果有一个4G大文件，将后2G移到前面，有什么方法？</p><ul><li>说了文件分割和虚拟内存映射</li></ul></li><li><p>进程中能创建多少个线程？</p></li><li><p>场景题：如果有大量客户端链接怎么解决高并发？</p></li><li><p>线程池如何设计？</p></li><li><p>单例模式讲一下？</p></li><li><p>单例模式和静态方法哪一个更适合处理临时量</p><ul><li>面试官说比如上下文</li></ul></li><li><p>单例模式静态方法的优缺点</p></li></ul><p>总结：</p><ul><li>本来以为电话是要约面试。。。结果直接开始了。。。面试官非常有耐心！！！对问题都有引导性！！！我觉得笔试题部分，面试官并不需要我使用多么高大上的算法，而是要想法灵活，可以针对问题提出不同思路的解决方法！继续加油！</li></ul><p>时间：2017.09.14<br>内容：猎豹移动内推三面<br>面经：</p><ul><li>根据简历一个一个问。。。前面问完问后面。。后面问万问前面。。。面试的时候明显感受到了太阳已经下山了。。。</li></ul><p>总结：</p><ul><li>把简历上的东西挨个问了一遍。。。只有一个感受。。。太渴了。。。继续加油！</li></ul><p>时间：2017.09.14<br>内容：猎豹移动内推四面<br>面经：</p><ul><li>人生。。理想。。时不时问一个技术问题。。但都不难。。。</li></ul><p>总结：</p><ul><li>面试官的气场完全不一样。。。应该是个大佬。。。我是最后一个面试完的。。。到家九点了。。。继续加油！</li></ul><p>时间：2017.09.16<br>内容：猎豹移动内推五面hr面<br>面经：</p><ul><li>基本的情况问一问，当场就签了意向协议书，她们也着急赶往下一场宣讲会。。</li></ul><p>总结：</p><ul><li>hr小姐姐就是一直通知我们、提醒我们面试的姐姐。。。没有套路。。小姐姐说我们坦陈相待的聊一聊。。。中午请我们在面试地点旁边的酒店吃饭，和四面的大boss、测试部门的负责人坐同一桌，和我们聊了很多，真的是一点架子都没有！各位boss也真是阔气。。抢红包发的真多。。。继续加油！</li></ul><h3 id="去哪儿网"><a href="#去哪儿网" class="headerlink" title="去哪儿网"></a><strong>去哪儿网</strong></h3><p><strong>结果：收到书面offer</strong></p><p>时间：2017.09.22<br>内容：去哪儿网一面<br>面经：</p><ul><li><p>自我介绍</p></li><li><p>介绍项目</p></li><li><p>手撕代码</p><ul><li><p>给定随机函数Rand()，其会返回0或1，输入N值，在保证随机生成序列的概率相同的情况下，输出一个序列。比如输入4，可以输出1234或4321</p></li><li><p>判断两棵二叉树是不是相同结构</p></li></ul></li><li><p>Mysql事务</p></li><li><p>死锁是什么，写一个死锁代码</p></li><li><p>如何理解面向对象语言，有哪些特点</p></li><li><p>C++多态如何实现</p></li></ul><p>总结：</p><ul><li>面试官应该是JAVA方向的，没有问过多的C++知识。。。第一题代码没有优化好。。继续加油！</li></ul><p>时间：2017.09.22<br>内容：去哪儿网二面<br>面经：</p><ul><li><p>自我介绍</p></li><li><p>讲项目</p></li><li><p>如果让你设计缓存需要考虑什么指标</p></li><li><p>采用什么缓存机制</p></li><li><p>设计何种数据结构使得对缓存的查询、添加、替换效率相对的高</p></li><li><p>手写快速排序</p></li><li><p>笔试题第二道讲一讲</p></li><li><p>为什么学习C++方向</p></li></ul><p>总结：</p><ul><li>二面更加注重对知识得运用，面试官会提出场景，需要对场景进行分析，提出合理的解决方案，只要能自圆其说就行。。。一面结束后等了不到15分钟，就直接二面。。效率真的高！</li></ul><p>时间：2017.09.22<br>内容：去哪儿网三面<br>面经：</p><ul><li><p>简单的介绍了项目。。</p></li><li><p>考不考研</p></li><li><p>工作地点</p></li><li><p>薪资的要求</p></li></ul><p>总结：</p><ul><li>我真的没想到。。。一个早上就能走完全部流程。。。直接就签了。。本来以为至少要一整天呢。。。只能说这效率真高！和hr聊的很好，哈哈，最后我俩一直都在笑。。。继续加油！</li></ul><h3 id="深信服"><a href="#深信服" class="headerlink" title="深信服"></a><strong>深信服</strong></h3><p><strong>结果：收到书面offer</strong></p><p>时间：2017.09.23<br>内容：深信服一面<br>面经：</p><ul><li><p>一面大部分是基础知识，C++没有涉及，都是C的知识</p></li><li><p>也有一部分Linux相关的</p></li></ul><p>总结：</p><ul><li>本来想的是去霸面的。。没想到二面面试官给我说查到我信息了。。只是还没给我发通知。。所以我算是提前去了。。后面才知道硕士和本科是分开面试的，先面硕士的，之后才面本科。。继续加油！</li></ul><p>时间：2017.09.23<br>内容：深信服二面<br>面经：</p><ul><li>全是Linux内核。。。知道什么问什么。。。</li></ul><p>总结：</p><ul><li>和二面面试官最后聊的时候知道，他的部门是做云、虚拟化相关的。。。所以Linux内核问的很多。。。也是二面面试官告诉我的。。我不是霸面的。。。还问了他提前来面会不会有影响。。。他说不会。。。那我就放心了。。中间聊到看源码的事，面试官说有的项目源码太多了。。。有很多都看不完。。二面的最后，面试官说给你加面一场。。。什么操作。。继续加油！</li></ul><p>时间：2017.09.23<br>内容：深信服三面<br>面经：</p><ul><li><p>聊天中问着技术。。。</p></li><li><p>技术中畅谈人生。。。</p></li></ul><p>总结：</p><ul><li>估计又是个大佬。。。中间有聊到Linux内核迭代的问题——“Linux内核也在一直迭代，那公司会不会也跟着更新呢？”部分回答：“二面面试官的部门，花了一年半的时间从2.4升级到2.6。。。”继续加油！</li></ul><p>时间：2017.09.23<br>内容：深信服四面hr面<br>面经：</p><ul><li><p>家是哪里的</p></li><li><p>最近印象最深的视频、书一类的，我说最近一直跑校招。。。只有之前的战狼2看了。。然后问我为什么战狼2那么火。。。</p></li><li><p>有没有和他人合作的项目，有什么收获？</p></li><li><p>还有一些问题都是差不多的</p></li></ul><p>总结：</p><ul><li>在外面等的时候听到了。。hr对那哥们说“那今天给你就发个口头offer，SP的薪资，具体我们明天再谈”。。。真大佬。。。和hr聊的也挺好的。。。最后说这两天内出结果。。。继续加油！</li></ul><h3 id="盛大游戏"><a href="#盛大游戏" class="headerlink" title="盛大游戏"></a><strong>盛大游戏</strong></h3><p><strong>结果：收到书面offer</strong></p><p>时间：2017.09.27<br>内容：盛大游戏一面、二面hr、三面总监面<br>面经：</p><ul><li>记不清了。。。</li></ul><p>总结：</p><ul><li>收手了。。。不要砍我。。。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kube-Batch 架构剖析</title>
    <link href="/2020/07/02/analysis-of-kube-batch-architecture/"/>
    <url>/2020/07/02/analysis-of-kube-batch-architecture/</url>
    
    <content type="html"><![CDATA[<blockquote><p>2019.12.20 本周五在组内做了一次技术分享，内容关于kube-batch，也在其中阐述了些自我思考。本文记录下分享的主要内容，PPT就不贴上来了。</p></blockquote><h1 id="basic-concept"><a href="#basic-concept" class="headerlink" title="basic concept"></a>basic concept</h1><ul><li>Queue</li><li>Job</li><li>Task</li><li>Podgroup<br><img src="https://img-blog.csdnimg.cn/20191222140027519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmdrb25na2tr,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="basic-concept"></li></ul><h1 id="framework"><a href="#framework" class="headerlink" title="framework"></a>framework</h1><ul><li>One-time scheduling process<br><img src="https://img-blog.csdnimg.cn/20191222140136745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmdrb25na2tr,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="framework"></li></ul>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kube-Batch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes dex 原理机制分析</title>
    <link href="/2020/07/02/dex-principle-analysis/"/>
    <url>/2020/07/02/dex-principle-analysis/</url>
    
    <content type="html"><![CDATA[<h1 id="kubernetes-身份认证与授权"><a href="#kubernetes-身份认证与授权" class="headerlink" title="kubernetes 身份认证与授权"></a>kubernetes 身份认证与授权</h1><p>OpenID Connect Toke<br><img src="https://img-blog.csdnimg.cn/20181108142619330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmdrb25na2tr,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h1 id="dex-身份认证"><a href="#dex-身份认证" class="headerlink" title="dex 身份认证"></a>dex 身份认证</h1><p>使用 kubernetes storage，LDAP connector，loginapp static client<br><img src="https://img-blog.csdnimg.cn/20181108143136593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmdrb25na2tr,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang语法的踩坑总结（持续更新中）</title>
    <link href="/2020/07/02/golang-grammar-stepping-summary/"/>
    <url>/2020/07/02/golang-grammar-stepping-summary/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>本来这篇是想写docker的基本操作总结的。。。想想还是写这个吧。。。→_→</em> *</strong></p><ul><li><blockquote><p><strong>变量声明使用 := 方式时，左值必须是未声明的，否则会出现编译错误</strong></p></blockquote>  <pre><code class="hljs go"><span class="hljs-comment">//.\main.go:8:4: no new variables on left side of :=</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span><span class="hljs-keyword">var</span> b <span class="hljs-keyword">int</span> = <span class="hljs-number">20</span>b := <span class="hljs-number">30</span>fmt.Print(a, b)&#125;</code></pre></li><li><blockquote><p><strong>变量声明了，就必须要使用，否则会出现编译错误</strong></p></blockquote>  <pre><code class="hljs go"><span class="hljs-comment">//.\main.go:7:6: b declared and not used</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span><span class="hljs-keyword">var</span> b <span class="hljs-keyword">int</span> = <span class="hljs-number">20</span>fmt.Print(a)&#125;</code></pre></li><li><blockquote><p><strong>const修饰符的作用范围为同时修饰的所有常量</strong></p></blockquote>  <pre><code class="hljs go"><span class="hljs-comment">//.\main.go:7:4: cannot assign to a</span><span class="hljs-comment">//.\main.go:8:4: cannot assign to b</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">const</span> a, b <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span>, <span class="hljs-number">20</span>a = <span class="hljs-number">10</span>b = <span class="hljs-number">20</span>fmt.Print(a, b)&#125;</code></pre></li><li><blockquote><p><strong>++自增和- -自减运算符类比C语言，相当于前置的自增和自减，而且go语言中不区分前置或后置</strong></p></blockquote>  <pre><code class="hljs go"><span class="hljs-comment">//.\main.go:9:2: syntax error: unexpected ++, expecting &#125;</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span><span class="hljs-keyword">var</span> b <span class="hljs-keyword">int</span> = <span class="hljs-number">20</span>++ab++fmt.Print(a, b)&#125;</code></pre></li><li><blockquote><p><strong>不能使用++自增或- -自减运算符初始化变量和对变量赋值</strong></p></blockquote>  <pre><code class="hljs sql">//.\main.go:7:15: syntax error: unexpected ++ at <span class="hljs-keyword">end</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">statement</span>//.\main.go:<span class="hljs-number">10</span>:<span class="hljs-number">7</span>: syntax <span class="hljs-keyword">error</span>: unexpected ++ <span class="hljs-keyword">at</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">statement</span><span class="hljs-keyword">package</span> <span class="hljs-keyword">main</span><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span>func <span class="hljs-keyword">main</span>()&#123;<span class="hljs-keyword">var</span> a <span class="hljs-built_in">int</span> = <span class="hljs-number">10</span><span class="hljs-keyword">var</span> b <span class="hljs-built_in">int</span> = a++<span class="hljs-keyword">var</span> c <span class="hljs-built_in">int</span> = <span class="hljs-number">20</span>c = a++fmt.Print(a, b, c)&#125;</code></pre></li><li><blockquote><p><strong>if…else 语句中的 else 必须和 if 的 ‘ } ‘ 在同一行，否则编译错误</strong></p></blockquote>  <pre><code class="hljs go"><span class="hljs-comment">//.\main.go:11:2: syntax error: unexpected else, expecting &#125;</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">30</span><span class="hljs-keyword">if</span> a &lt; <span class="hljs-number">20</span> &#123;fmt.Print(<span class="hljs-string">"a&lt;20"</span>)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Print(<span class="hljs-string">"a&gt;=20"</span>)&#125;&#125;</code></pre></li><li><blockquote><p><strong>switch 中的 case和default分支不用添加break</strong></p></blockquote>  <pre><code class="hljs go"><span class="hljs-comment">//代码运行成功</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span><span class="hljs-keyword">switch</span> a &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:fmt.Println(<span class="hljs-string">"1"</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:fmt.Println(<span class="hljs-string">"2"</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:fmt.Println(<span class="hljs-string">"10"</span>)<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">"unknow"</span>)&#125;&#125;</code></pre></li><li><blockquote><p><strong>switch 中 也可以不用添加表达式</strong></p></blockquote>  <pre><code class="hljs go"><span class="hljs-comment">//代码运行成功</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span><span class="hljs-keyword">switch</span> &#123;<span class="hljs-keyword">case</span> a == <span class="hljs-number">1</span>:fmt.Println(<span class="hljs-string">"1"</span>)<span class="hljs-keyword">case</span> a == <span class="hljs-number">2</span>:fmt.Println(<span class="hljs-string">"2"</span>)<span class="hljs-keyword">case</span> a == <span class="hljs-number">10</span>:fmt.Println(<span class="hljs-string">"10"</span>)<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">"unknow"</span>)&#125;&#125;</code></pre></li><li><blockquote><p><strong>switch的case分支的常量表达式可以同时测试多个值</strong></p></blockquote>  <pre><code class="hljs go"><span class="hljs-comment">//代码运行成功</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span><span class="hljs-keyword">switch</span> &#123;<span class="hljs-keyword">case</span> a == <span class="hljs-number">1</span>, a == <span class="hljs-number">2</span>:fmt.Println(<span class="hljs-string">"1 or 2"</span>)<span class="hljs-keyword">case</span> a == <span class="hljs-number">10</span>, a == <span class="hljs-number">20</span>:fmt.Println(<span class="hljs-string">"10 or 20"</span>)<span class="hljs-keyword">case</span> a == <span class="hljs-number">100</span>, a == <span class="hljs-number">200</span>:fmt.Println(<span class="hljs-string">"100 or 200"</span>)<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">"unknow"</span>)&#125;&#125;</code></pre></li><li><blockquote><p><strong>switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型</strong></p></blockquote>  <pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> x <span class="hljs-keyword">interface</span>&#123;&#125;<span class="hljs-keyword">switch</span> i := x.(<span class="hljs-keyword">type</span>) &#123;<span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:fmt.Printf(<span class="hljs-string">"%T"</span>, i)<span class="hljs-keyword">case</span> <span class="hljs-keyword">int</span>:fmt.Printf(<span class="hljs-string">"int"</span>)<span class="hljs-keyword">case</span> <span class="hljs-keyword">float64</span>:fmt.Printf(<span class="hljs-string">"float64"</span>)<span class="hljs-keyword">case</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">float64</span>:</span>fmt.Printf(<span class="hljs-string">"func(int)"</span>)<span class="hljs-keyword">case</span> <span class="hljs-keyword">bool</span>, <span class="hljs-keyword">string</span>:fmt.Printf(<span class="hljs-string">"bool or string"</span>)<span class="hljs-keyword">default</span>:fmt.Printf(<span class="hljs-string">"unknow"</span>)&#125;&#125;</code></pre></li><li><blockquote><p><strong>select 语句。。这个现在还没看懂。。先MARK</strong></p></blockquote>  <pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">Learning</span></span>...</code></pre></li><li><blockquote><p><strong>for循环语句range格式，遍历数组</strong></p></blockquote>  <pre><code class="hljs go"><span class="hljs-comment">//i为下标</span><span class="hljs-comment">//x为元素的值</span><span class="hljs-comment">//0 1</span><span class="hljs-comment">//1 2</span><span class="hljs-comment">//2 3</span><span class="hljs-comment">//3 4</span><span class="hljs-comment">//4 5</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> number = [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> number &#123;fmt.Println(i, x)&#125;&#125;</code></pre></li><li><blockquote><p><strong>for循环语句和C语言中的while循环语句比较</strong></p></blockquote>  <pre><code class="hljs yaml"><span class="hljs-string">//0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><span class="hljs-string">package</span> <span class="hljs-string">main</span><span class="hljs-string">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-string">func</span> <span class="hljs-string">main()</span> <span class="hljs-string">&#123;</span><span class="hljs-string">var</span> <span class="hljs-string">a</span> <span class="hljs-string">int</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span><span class="hljs-string">for</span> <span class="hljs-string">a</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">10</span> <span class="hljs-string">&#123;</span><span class="hljs-string">fmt.Printf("%d</span> <span class="hljs-string">", a)</span><span class="hljs-string">a++</span><span class="hljs-string">&#125;</span><span class="hljs-string">&#125;</span></code></pre></li><li><blockquote><p><strong>for循环语句和C语言中的for循环语句比较</strong></p></blockquote>  <pre><code class="hljs yaml"><span class="hljs-string">//0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><span class="hljs-string">package</span> <span class="hljs-string">main</span><span class="hljs-string">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-string">func</span> <span class="hljs-string">main()</span> <span class="hljs-string">&#123;</span><span class="hljs-string">var</span> <span class="hljs-string">a</span> <span class="hljs-string">int</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span><span class="hljs-string">for</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span><span class="hljs-string">;</span> <span class="hljs-string">a</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">10</span><span class="hljs-string">;</span> <span class="hljs-string">a++</span> <span class="hljs-string">&#123;</span><span class="hljs-string">fmt.Printf("%d</span> <span class="hljs-string">", a)</span><span class="hljs-string">&#125;</span><span class="hljs-string">&#125;</span></code></pre></li><li><blockquote><p><strong>函数的结构与C语言中的函数结构有很大不同，函数调用相似</strong></p></blockquote>  <pre><code class="hljs kotlin"><span class="hljs-comment">//10 10</span><span class="hljs-comment">//true</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span>func <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(num1 *int, num2 *int)</span></span> bool &#123;fmt.Println(*num1, *num2)<span class="hljs-keyword">if</span> *num1 == *num2 &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;&#125;func main() &#123;<span class="hljs-keyword">var</span> a int = <span class="hljs-number">10</span><span class="hljs-keyword">var</span> b int = <span class="hljs-number">10</span><span class="hljs-keyword">var</span> flag bool = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(&amp;a, &amp;b)</span></span>fmt.Print(flag)&#125;</code></pre></li><li><blockquote><p><strong>函数可以同时返回多个值</strong></p></blockquote>  <pre><code class="hljs go"><span class="hljs-comment">//hello world</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fun</span><span class="hljs-params">(str1 <span class="hljs-keyword">string</span>, str2 <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, <span class="hljs-keyword">string</span>)</span></span> &#123;<span class="hljs-keyword">return</span> str2, str1&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;str1, str2 := fun(<span class="hljs-string">"world"</span>, <span class="hljs-string">"hello"</span>)fmt.Println(str1, str2)&#125;</code></pre></li><li><blockquote><p><strong>函数可以作为值使用，神奇~</strong></p></blockquote>  <pre><code class="hljs go"><span class="hljs-comment">//-1</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;tmp := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> -x&#125;fmt.Print(tmp(<span class="hljs-number">1</span>))&#125;</code></pre></li><li><blockquote><p><strong>函数支持匿名函数，可作为闭包。匿名函数是一个”内联”语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</strong></p></blockquote>  <pre><code class="hljs go"><span class="hljs-comment">//1 2 3</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">first</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;i := <span class="hljs-number">0</span><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;i++<span class="hljs-keyword">return</span> i&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;tmp := first()fmt.Println(tmp(), tmp(), tmp())&#125;</code></pre></li><li><blockquote><p><strong>函数也可以成为自定义类型的一个方法</strong></p></blockquote>  <pre><code class="hljs go"><span class="hljs-comment">//10 abc</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-comment">//自定义类型</span><span class="hljs-keyword">type</span> student <span class="hljs-keyword">struct</span> &#123;num  <span class="hljs-keyword">int</span>name <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">//方法getNum</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(stu student)</span> <span class="hljs-title">getNum</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> stu.num&#125;<span class="hljs-comment">//方法getName</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(stu student)</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> stu.name&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> st studentst.num = <span class="hljs-number">10</span>st.name = <span class="hljs-string">"abc"</span><span class="hljs-comment">//对象调用其方法</span>fmt.Println(st.getNum(), st.getName())&#125;</code></pre></li><li><blockquote><p><strong>数组的声明、初始化、赋值、访问</strong></p></blockquote>  <pre><code class="hljs yaml"><span class="hljs-string">//[0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><span class="hljs-string">]</span><span class="hljs-string">//100</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-string">[100</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><span class="hljs-string">]</span><span class="hljs-string">package</span> <span class="hljs-string">main</span><span class="hljs-string">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-string">func</span> <span class="hljs-string">main()</span> <span class="hljs-string">&#123;</span><span class="hljs-string">var</span> <span class="hljs-string">arr</span> <span class="hljs-string">[10]int</span><span class="hljs-string">var</span> <span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-string">[...]int&#123;0,</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-number">5</span><span class="hljs-string">,</span> <span class="hljs-number">6</span><span class="hljs-string">,</span> <span class="hljs-number">7</span><span class="hljs-string">,</span> <span class="hljs-number">8</span><span class="hljs-string">,</span> <span class="hljs-number">9</span><span class="hljs-string">&#125;</span><span class="hljs-string">number[0]</span> <span class="hljs-string">=</span> <span class="hljs-number">100</span><span class="hljs-string">fmt.Println(arr)</span><span class="hljs-string">var</span> <span class="hljs-string">i</span> <span class="hljs-string">int</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span><span class="hljs-string">for</span> <span class="hljs-string">i</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span><span class="hljs-string">;</span> <span class="hljs-string">i</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">10</span><span class="hljs-string">;</span> <span class="hljs-string">i++</span> <span class="hljs-string">&#123;</span><span class="hljs-string">fmt.Printf("%d</span> <span class="hljs-string">", number[i])</span><span class="hljs-string">&#125;</span><span class="hljs-string"></span><span class="hljs-string">fmt.Println(number)</span><span class="hljs-string">&#125;</span></code></pre></li><li><blockquote><p><strong>二维数组的初始化</strong></p></blockquote>  <pre><code class="hljs angelscript"><span class="hljs-comment">//[[1 2 3] [4 5 6] [7 8 9]]</span>package main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span>func main() &#123;var number = [<span class="hljs-number">3</span>][<span class="hljs-number">3</span>]<span class="hljs-built_in">int</span>&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;&#125;fmt.Println(number)&#125;</code></pre></li><li><blockquote><p><strong>函数参数为数组，必须同时显示的写出数组元素个数或同时隐藏数组的元素个数</strong></p></blockquote>  <pre><code class="hljs angelscript"><span class="hljs-comment">//0 1 2 3 4 5 6 7 8 9 10</span>package main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span>func getNum(number []<span class="hljs-built_in">int</span>) <span class="hljs-built_in">int</span> &#123;var i <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;fmt.Printf(<span class="hljs-string">"%d "</span>, number[i])&#125;<span class="hljs-keyword">return</span> len(number)&#125;func main() &#123;var number = []<span class="hljs-built_in">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;num := getNum(number)fmt.Println(num)&#125;</code></pre>  <pre><code class="hljs angelscript"><span class="hljs-comment">//0 1 2 3 4 5 6 7 8 9 10</span>package main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span>func getNum(number [<span class="hljs-number">10</span>]<span class="hljs-built_in">int</span>) <span class="hljs-built_in">int</span> &#123;var i <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;fmt.Printf(<span class="hljs-string">"%d "</span>, number[i])&#125;<span class="hljs-keyword">return</span> len(number)&#125;func main() &#123;var number = [<span class="hljs-number">10</span>]<span class="hljs-built_in">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;num := getNum(number)fmt.Println(num)&#125;</code></pre></li><li><blockquote><p><strong>指针数组的初始化和使用</strong></p></blockquote>  <pre><code class="hljs yaml"><span class="hljs-string">//0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-string">package</span> <span class="hljs-string">main</span><span class="hljs-string">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-string">func</span> <span class="hljs-string">main()</span> <span class="hljs-string">&#123;</span><span class="hljs-string">var</span> <span class="hljs-string">number</span> <span class="hljs-string">=</span> <span class="hljs-string">[10]int&#123;0,</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-number">5</span><span class="hljs-string">,</span> <span class="hljs-number">6</span><span class="hljs-string">,</span> <span class="hljs-number">7</span><span class="hljs-string">,</span> <span class="hljs-number">8</span><span class="hljs-string">,</span> <span class="hljs-number">9</span><span class="hljs-string">&#125;</span><span class="hljs-string">var</span> <span class="hljs-string">num</span> <span class="hljs-string">[10]*int</span><span class="hljs-string">for</span> <span class="hljs-string">i</span> <span class="hljs-string">:=</span> <span class="hljs-number">0</span><span class="hljs-string">;</span> <span class="hljs-string">i</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">10</span><span class="hljs-string">;</span> <span class="hljs-string">i++</span> <span class="hljs-string">&#123;</span><span class="hljs-string">num[i]</span> <span class="hljs-string">=</span> <span class="hljs-string">&amp;number[i]</span><span class="hljs-string">&#125;</span><span class="hljs-string">for</span> <span class="hljs-string">i</span> <span class="hljs-string">:=</span> <span class="hljs-number">0</span><span class="hljs-string">;</span> <span class="hljs-string">i</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">10</span><span class="hljs-string">;</span> <span class="hljs-string">i++</span> <span class="hljs-string">&#123;</span><span class="hljs-string">fmt.Printf("%d</span> <span class="hljs-string">", *num[i])</span><span class="hljs-string">&#125;</span><span class="hljs-string">&#125;</span></code></pre></li><li><blockquote><p><strong>二级指针的初始化和使用</strong></p></blockquote>  <pre><code class="hljs go"><span class="hljs-comment">//10 10 10</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span><span class="hljs-keyword">var</span> ptr1 *<span class="hljs-keyword">int</span> = &amp;i<span class="hljs-keyword">var</span> ptr2 **<span class="hljs-keyword">int</span> = &amp;ptr1fmt.Printf(<span class="hljs-string">"%d %d %d"</span>, i, *ptr1, **ptr2)&#125;</code></pre></li><li><blockquote><p><strong>结构体的定义和初始化方式，注意结构体变量和结构体指针变量访问结构体成员时只有 . 一种方式，此处和C语言的结构体语法不同</strong></p></blockquote>  <pre><code class="hljs reasonml"><span class="hljs-comment">//111</span><span class="hljs-comment">//zhangsan</span><span class="hljs-comment">//man</span><span class="hljs-comment">//20</span><span class="hljs-comment">//111</span><span class="hljs-comment">//zhangsan</span><span class="hljs-comment">//man</span><span class="hljs-comment">//20</span>package mainimport <span class="hljs-string">"fmt"</span><span class="hljs-keyword">type</span> studentInfo <span class="hljs-keyword">struct</span> &#123;id   <span class="hljs-built_in">int</span>name <span class="hljs-built_in">string</span>sex  <span class="hljs-built_in">string</span>age  <span class="hljs-built_in">int</span>&#125;func get<span class="hljs-constructor">Info(<span class="hljs-params">stu</span> <span class="hljs-params">studentInfo</span>)</span> &#123;fmt.<span class="hljs-constructor">Println(<span class="hljs-params">stu</span>.<span class="hljs-params">id</span>)</span>fmt.<span class="hljs-constructor">Println(<span class="hljs-params">stu</span>.<span class="hljs-params">name</span>)</span>fmt.<span class="hljs-constructor">Println(<span class="hljs-params">stu</span>.<span class="hljs-params">sex</span>)</span>fmt.<span class="hljs-constructor">Println(<span class="hljs-params">stu</span>.<span class="hljs-params">age</span>)</span>&#125;func get<span class="hljs-constructor">InfoByPtr(<span class="hljs-params">stuPtr</span> <span class="hljs-operator">*</span><span class="hljs-params">studentInfo</span>)</span> &#123;fmt.<span class="hljs-constructor">Println(<span class="hljs-params">stuPtr</span>.<span class="hljs-params">id</span>)</span>fmt.<span class="hljs-constructor">Println(<span class="hljs-params">stuPtr</span>.<span class="hljs-params">name</span>)</span>fmt.<span class="hljs-constructor">Println(<span class="hljs-params">stuPtr</span>.<span class="hljs-params">sex</span>)</span>fmt.<span class="hljs-constructor">Println(<span class="hljs-params">stuPtr</span>.<span class="hljs-params">age</span>)</span>&#125;func main<span class="hljs-literal">()</span> &#123;var stu studentInfostu.id = <span class="hljs-number">111</span>stu.name = <span class="hljs-string">"zhangsan"</span>stu.sex = <span class="hljs-string">"man"</span>stu.age = <span class="hljs-number">20</span>get<span class="hljs-constructor">Info(<span class="hljs-params">stu</span>)</span>var stuPtr *studentInfo = &amp;stuget<span class="hljs-constructor">InfoByPtr(<span class="hljs-params">stuPtr</span>)</span>&#125;</code></pre></li><li><blockquote><p><strong>切片（Slice），长度不固定，可以理解为动态数组。Slice有两个属性：length即当前元素的容量大小，capacity即可以最大容纳元素的容量大小。Slice的定义如下</strong></p></blockquote>  <pre><code class="hljs yaml"><span class="hljs-string">//make([]T,</span> <span class="hljs-string">length,</span> <span class="hljs-string">capacity)</span><span class="hljs-string">//len</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span> <span class="hljs-string">cap</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-string">slice</span> <span class="hljs-string">=</span> <span class="hljs-string">[]</span><span class="hljs-string">//len</span> <span class="hljs-string">=</span> <span class="hljs-number">10</span> <span class="hljs-string">cap</span> <span class="hljs-string">=</span> <span class="hljs-number">10</span><span class="hljs-string">,</span> <span class="hljs-string">slice</span> <span class="hljs-string">=</span> <span class="hljs-string">[0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><span class="hljs-string">]</span><span class="hljs-string">//len</span> <span class="hljs-string">=</span> <span class="hljs-number">10</span> <span class="hljs-string">cap</span> <span class="hljs-string">=</span> <span class="hljs-number">10</span><span class="hljs-string">,</span> <span class="hljs-string">slice</span> <span class="hljs-string">=</span> <span class="hljs-string">[0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><span class="hljs-string">]</span><span class="hljs-string">//len</span> <span class="hljs-string">=</span> <span class="hljs-number">5</span> <span class="hljs-string">cap</span> <span class="hljs-string">=</span> <span class="hljs-number">10</span><span class="hljs-string">,</span> <span class="hljs-string">slice</span> <span class="hljs-string">=</span> <span class="hljs-string">[0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><span class="hljs-string">]</span><span class="hljs-string">package</span> <span class="hljs-string">main</span><span class="hljs-string">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-string">func</span> <span class="hljs-string">printSlice(slice</span> <span class="hljs-string">[]int)</span> <span class="hljs-string">&#123;</span><span class="hljs-string">fmt.Printf("len</span> <span class="hljs-string">=</span> <span class="hljs-string">%d</span> <span class="hljs-string">cap</span> <span class="hljs-string">=</span> <span class="hljs-string">%d,</span> <span class="hljs-string">slice</span> <span class="hljs-string">=</span> <span class="hljs-string">%v\n",</span> <span class="hljs-string">len(slice),</span> <span class="hljs-string">cap(slice),</span> <span class="hljs-string">slice)</span><span class="hljs-string">&#125;</span><span class="hljs-string">func</span> <span class="hljs-string">main()</span> <span class="hljs-string">&#123;</span><span class="hljs-string">var</span> <span class="hljs-string">slice1</span> <span class="hljs-string">[]int</span><span class="hljs-string">printSlice(slice1)</span><span class="hljs-string">var</span> <span class="hljs-string">slice2</span> <span class="hljs-string">=</span> <span class="hljs-string">make([]int,</span> <span class="hljs-number">10</span><span class="hljs-string">)</span><span class="hljs-string">printSlice(slice2)</span><span class="hljs-string">var</span> <span class="hljs-string">slice3</span> <span class="hljs-string">=</span> <span class="hljs-string">make([]int,</span> <span class="hljs-number">10</span><span class="hljs-string">,</span> <span class="hljs-number">10</span><span class="hljs-string">)</span><span class="hljs-string">printSlice(slice3)</span><span class="hljs-string">slice4</span> <span class="hljs-string">:=</span> <span class="hljs-string">make([]int,</span> <span class="hljs-number">5</span><span class="hljs-string">,</span> <span class="hljs-number">10</span><span class="hljs-string">)</span><span class="hljs-string">printSlice(slice4)</span><span class="hljs-string">&#125;</span></code></pre></li><li><blockquote><p><strong>Slice的初始化如下：startIndex代表起始下标，endIndex代表终止下标，但在初始化时的实际范围是startIndex~endIndex-1。</strong><br><strong>缺省endIndex表示一直到最后一个元素，缺省startIndex表示从第一个元素开始。</strong><br><strong>当startIndex不是从arr[0]开始时，会将新切片的cap值改变为：原cap的值减startIndex。</strong></p></blockquote>  <pre><code class="hljs yaml"><span class="hljs-string">//s</span> <span class="hljs-string">:=</span> <span class="hljs-string">arr[startIndex:endIndex]</span> <span class="hljs-string">//len</span> <span class="hljs-string">=</span> <span class="hljs-number">10</span> <span class="hljs-string">cap</span> <span class="hljs-string">=</span> <span class="hljs-number">10</span><span class="hljs-string">,</span> <span class="hljs-string">slice</span> <span class="hljs-string">=</span> <span class="hljs-string">[0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><span class="hljs-string">]</span><span class="hljs-string">//len</span> <span class="hljs-string">=</span> <span class="hljs-number">10</span> <span class="hljs-string">cap</span> <span class="hljs-string">=</span> <span class="hljs-number">10</span><span class="hljs-string">,</span> <span class="hljs-string">slice</span> <span class="hljs-string">=</span> <span class="hljs-string">[0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><span class="hljs-string">]</span><span class="hljs-string">//len</span> <span class="hljs-string">=</span> <span class="hljs-number">10</span> <span class="hljs-string">cap</span> <span class="hljs-string">=</span> <span class="hljs-number">10</span><span class="hljs-string">,</span> <span class="hljs-string">slice</span> <span class="hljs-string">=</span> <span class="hljs-string">[0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><span class="hljs-string">]</span><span class="hljs-string">//len</span> <span class="hljs-string">=</span> <span class="hljs-number">2</span> <span class="hljs-string">cap</span> <span class="hljs-string">=</span> <span class="hljs-number">9</span><span class="hljs-string">,</span> <span class="hljs-string">slice</span> <span class="hljs-string">=</span> <span class="hljs-string">[1</span> <span class="hljs-number">2</span><span class="hljs-string">]</span><span class="hljs-string">//len</span> <span class="hljs-string">=</span> <span class="hljs-number">9</span> <span class="hljs-string">cap</span> <span class="hljs-string">=</span> <span class="hljs-number">9</span><span class="hljs-string">,</span> <span class="hljs-string">slice</span> <span class="hljs-string">=</span> <span class="hljs-string">[1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><span class="hljs-string">]</span><span class="hljs-string">//len</span> <span class="hljs-string">=</span> <span class="hljs-number">3</span> <span class="hljs-string">cap</span> <span class="hljs-string">=</span> <span class="hljs-number">10</span><span class="hljs-string">,</span> <span class="hljs-string">slice</span> <span class="hljs-string">=</span> <span class="hljs-string">[0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><span class="hljs-string">]</span><span class="hljs-string">//len</span> <span class="hljs-string">=</span> <span class="hljs-number">2</span> <span class="hljs-string">cap</span> <span class="hljs-string">=</span> <span class="hljs-number">8</span><span class="hljs-string">,</span> <span class="hljs-string">slice</span> <span class="hljs-string">=</span> <span class="hljs-string">[2</span> <span class="hljs-number">3</span><span class="hljs-string">]</span><span class="hljs-string">package</span> <span class="hljs-string">main</span><span class="hljs-string">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-string">func</span> <span class="hljs-string">printSlice(slice</span> <span class="hljs-string">[]int)</span> <span class="hljs-string">&#123;</span><span class="hljs-string">fmt.Printf("len</span> <span class="hljs-string">=</span> <span class="hljs-string">%d</span> <span class="hljs-string">cap</span> <span class="hljs-string">=</span> <span class="hljs-string">%d,</span> <span class="hljs-string">slice</span> <span class="hljs-string">=</span> <span class="hljs-string">%v\n",</span> <span class="hljs-string">len(slice),</span> <span class="hljs-string">cap(slice),</span> <span class="hljs-string">slice)</span><span class="hljs-string">&#125;</span><span class="hljs-string">func</span> <span class="hljs-string">main()</span> <span class="hljs-string">&#123;</span><span class="hljs-string">var</span> <span class="hljs-string">slice1</span> <span class="hljs-string">=</span> <span class="hljs-string">[]int&#123;0,</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-number">5</span><span class="hljs-string">,</span> <span class="hljs-number">6</span><span class="hljs-string">,</span> <span class="hljs-number">7</span><span class="hljs-string">,</span> <span class="hljs-number">8</span><span class="hljs-string">,</span> <span class="hljs-number">9</span><span class="hljs-string">&#125;</span><span class="hljs-string">printSlice(slice1)</span><span class="hljs-string">slice2</span> <span class="hljs-string">:=</span> <span class="hljs-string">[]int&#123;0,</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-number">5</span><span class="hljs-string">,</span> <span class="hljs-number">6</span><span class="hljs-string">,</span> <span class="hljs-number">7</span><span class="hljs-string">,</span> <span class="hljs-number">8</span><span class="hljs-string">,</span> <span class="hljs-number">9</span><span class="hljs-string">&#125;</span><span class="hljs-string">printSlice(slice2)</span><span class="hljs-string">//数组arr</span><span class="hljs-string">var</span> <span class="hljs-string">arr</span> <span class="hljs-string">=</span> <span class="hljs-string">[10]int&#123;0,</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-number">5</span><span class="hljs-string">,</span> <span class="hljs-number">6</span><span class="hljs-string">,</span> <span class="hljs-number">7</span><span class="hljs-string">,</span> <span class="hljs-number">8</span><span class="hljs-string">,</span> <span class="hljs-number">9</span><span class="hljs-string">&#125;</span><span class="hljs-string">slice3</span> <span class="hljs-string">:=</span> <span class="hljs-string">arr[:]</span><span class="hljs-string">printSlice(slice3)</span><span class="hljs-string">slice4</span> <span class="hljs-string">:=</span> <span class="hljs-string">arr[1:3]</span><span class="hljs-string">printSlice(slice4)</span><span class="hljs-string">slice5</span> <span class="hljs-string">:=</span> <span class="hljs-string">arr[1:]</span><span class="hljs-string">printSlice(slice5)</span><span class="hljs-string">slice6</span> <span class="hljs-string">:=</span> <span class="hljs-string">arr[:3]</span><span class="hljs-string">printSlice(slice6)</span><span class="hljs-string">slice7</span> <span class="hljs-string">:=</span> <span class="hljs-string">slice5[1:3]</span><span class="hljs-string">printSlice(slice7)</span><span class="hljs-string">&#125;</span></code></pre></li><li><blockquote><p><strong>未初始化的切片Slice默认为nil，len为0，cap为0</strong></p></blockquote>  <pre><code class="hljs go"><span class="hljs-comment">//len = 0, cap = 0, slice = []</span><span class="hljs-comment">//slice is nil</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printSlice</span><span class="hljs-params">(slice []<span class="hljs-keyword">int</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">"len = %d, cap = %d, slice = %v\n"</span>, <span class="hljs-built_in">len</span>(slice), <span class="hljs-built_in">cap</span>(slice), slice)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> slice []<span class="hljs-keyword">int</span>printSlice(slice)<span class="hljs-keyword">if</span> slice == <span class="hljs-literal">nil</span> &#123;fmt.Printf(<span class="hljs-string">"slice is nil\n"</span>)&#125;&#125;</code></pre></li><li><blockquote><p><strong>Slice切片的append()追加和copy()拷贝。</strong><br><strong>当切片长度len等于切片容量cap时，再append()追加数据，此时切片cap容量增长，且默认扩容2倍。</strong></p></blockquote>  <pre><code class="hljs go"><span class="hljs-comment">//len = 0, cap = 0, slice = []</span><span class="hljs-comment">//len = 1, cap = 1, slice = [0]</span><span class="hljs-comment">//len = 2, cap = 2, slice = [0 1]</span><span class="hljs-comment">//len = 5, cap = 6, slice = [0 1 2 3 4]</span><span class="hljs-comment">//len = 5, cap = 12, slice = [0 1 2 3 4]</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printSlice</span><span class="hljs-params">(slice []<span class="hljs-keyword">int</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">"len = %d, cap = %d, slice = %v\n"</span>, <span class="hljs-built_in">len</span>(slice), <span class="hljs-built_in">cap</span>(slice), slice)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> slice []<span class="hljs-keyword">int</span>printSlice(slice)<span class="hljs-comment">//此时cap默认扩容2倍</span>slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">0</span>)printSlice(slice)<span class="hljs-comment">//此时cap默认扩容2倍</span>slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">1</span>)printSlice(slice)<span class="hljs-comment">//此时cap扩容规则出现变化，同时append追加多个数据时，cap会扩容到向上最近的偶数数值，以减少cap容量的浪费</span>slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)printSlice(slice)slice2 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(slice), <span class="hljs-built_in">cap</span>(slice)*<span class="hljs-number">2</span>)<span class="hljs-built_in">copy</span>(slice2, slice)printSlice(slice2)&#125;</code></pre></li><li><blockquote><p><strong>Slice切片的append()并没有改变参数中的原切片，而是改变了接受返回值的切片</strong></p></blockquote>  <pre><code class="hljs yaml"><span class="hljs-string">//[1</span> <span class="hljs-number">2</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span><span class="hljs-string">]</span><span class="hljs-string">//[1</span> <span class="hljs-number">2</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span><span class="hljs-string">]</span><span class="hljs-string">//[1</span> <span class="hljs-number">2</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span><span class="hljs-string">]</span><span class="hljs-string">//[1</span> <span class="hljs-number">2</span> <span class="hljs-number">9</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><span class="hljs-string">]</span><span class="hljs-string">package</span> <span class="hljs-string">main</span><span class="hljs-string">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-string">func</span> <span class="hljs-string">main()</span> <span class="hljs-string">&#123;</span><span class="hljs-string">original</span> <span class="hljs-string">:=</span> <span class="hljs-string">[]int&#123;1,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">&#125;</span> <span class="hljs-string">//a</span> <span class="hljs-string">slice</span> <span class="hljs-string">with</span> <span class="hljs-string">a</span> <span class="hljs-string">len</span> <span class="hljs-string">and</span> <span class="hljs-string">cap</span> <span class="hljs-string">of</span> <span class="hljs-number">4</span><span class="hljs-string">other</span> <span class="hljs-string">:=</span> <span class="hljs-string">original</span><span class="hljs-string">other[2]</span> <span class="hljs-string">=</span> <span class="hljs-number">8</span><span class="hljs-string">fmt.Println(original)</span><span class="hljs-string">fmt.Println(other)</span><span class="hljs-string">other</span> <span class="hljs-string">=</span> <span class="hljs-string">append(original,</span> <span class="hljs-number">5</span><span class="hljs-string">)</span><span class="hljs-string">other[2]</span> <span class="hljs-string">=</span> <span class="hljs-number">9</span><span class="hljs-string">fmt.Println(original)</span><span class="hljs-string">fmt.Println(other)</span><span class="hljs-string">&#125;</span></code></pre></li><li><blockquote><p>range（范围）用来循环迭代array（数组）、slice（切片）、channel（通道）、map（集合）</p></blockquote>  <pre><code class="hljs go"><span class="hljs-comment">//slice</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;nums := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;sum := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums&#123;sum += num&#125;fmt.Print(sum)&#125;</code></pre>  <pre><code class="hljs go"><span class="hljs-comment">//slice</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;kvs := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"1"</span>: <span class="hljs-string">"one"</span>, <span class="hljs-string">"2"</span>: <span class="hljs-string">"two"</span>&#125;<span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> kvs&#123;fmt.Printf(<span class="hljs-string">"%s -&gt; %s\n"</span>, k, v)&#125;&#125;</code></pre></li><li><blockquote><p>map是无序的键值对集合，delete函数删除map中的元素</p></blockquote>  <pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//定义map集合</span><span class="hljs-keyword">var</span> studentName <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span><span class="hljs-comment">//初始化创建集合</span>studentName = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>)studentName[<span class="hljs-number">0</span>] = <span class="hljs-string">"zhangsan"</span>studentName[<span class="hljs-number">1</span>] = <span class="hljs-string">"lisi"</span>studentName[<span class="hljs-number">2</span>] = <span class="hljs-string">"wangwu"</span><span class="hljs-comment">//由于map是hash表实现的，所以每次的迭代结果不确定</span><span class="hljs-keyword">for</span> ID := <span class="hljs-keyword">range</span> studentName&#123;fmt.Printf(<span class="hljs-string">"%d -&gt; %s\n"</span>, ID, studentName[ID])&#125;<span class="hljs-comment">//删除key为0的元素</span><span class="hljs-built_in">delete</span>(studentName, <span class="hljs-number">0</span>)fmt.Println(<span class="hljs-string">"delete"</span>, <span class="hljs-number">0</span>)<span class="hljs-keyword">for</span> ID := <span class="hljs-keyword">range</span> studentName&#123;fmt.Printf(<span class="hljs-string">"%d -&gt; %s\n"</span>, ID, studentName[ID])&#125;&#125;</code></pre></li><li><blockquote><p>interface接口，和JAVA中的接口相似</p></blockquote>  <pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span>)<span class="hljs-keyword">type</span> Action <span class="hljs-keyword">interface</span>&#123;sleep()eat()&#125;<span class="hljs-keyword">type</span> Human <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(hum Human)</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>&#123;fmt.Println(<span class="hljs-string">"human sleeping"</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(hum Human)</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;fmt.Println(<span class="hljs-string">"human eating"</span>)&#125;<span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(dog Dog)</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>&#123;fmt.Println(<span class="hljs-string">"dog sleeping"</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(dog Dog)</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;fmt.Println(<span class="hljs-string">"dog eating"</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">var</span> action Actionaction = <span class="hljs-built_in">new</span>(Human)action.sleep()action = <span class="hljs-built_in">new</span>(Dog)action.eat()&#125;</code></pre></li><li><blockquote><p>错误处理</p></blockquote>  <pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"fmt"</span>)<span class="hljs-comment">// 定义一个 DivideError 结构</span><span class="hljs-keyword">type</span> DivideError <span class="hljs-keyword">struct</span> &#123;dividee <span class="hljs-keyword">int</span>divider <span class="hljs-keyword">int</span>&#125;<span class="hljs-comment">// 实现 `error` 接口</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(de *DivideError)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;strFormat := <span class="hljs-string">`</span><span class="hljs-string">    Cannot proceed, the divider is zero.</span><span class="hljs-string">    dividee: %d</span><span class="hljs-string">    divider: 0</span><span class="hljs-string">`</span><span class="hljs-keyword">return</span> fmt.Sprintf(strFormat, de.dividee)&#125;<span class="hljs-comment">// 定义 `int` 类型除法运算的函数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Divide</span><span class="hljs-params">(varDividee <span class="hljs-keyword">int</span>, varDivider <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(result <span class="hljs-keyword">int</span>, errorMsg <span class="hljs-keyword">string</span>)</span></span> &#123;<span class="hljs-keyword">if</span> varDivider == <span class="hljs-number">0</span> &#123;dData := DivideError&#123;dividee: varDividee,divider: varDivider,&#125;errorMsg = dData.Error()<span class="hljs-keyword">return</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> varDividee / varDivider, <span class="hljs-string">"no error"</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 正常情况</span>result, errorMsg := Divide(<span class="hljs-number">100</span>, <span class="hljs-number">10</span>)<span class="hljs-keyword">if</span> errorMsg == <span class="hljs-string">"no error"</span> &#123;fmt.Println(<span class="hljs-string">"100/10 = "</span>, result, errorMsg)&#125;<span class="hljs-comment">// 当被除数为零的时候会返回错误信息</span>result, errorMsg = Divide(<span class="hljs-number">100</span>, <span class="hljs-number">0</span>)<span class="hljs-keyword">if</span> errorMsg != <span class="hljs-string">"no error"</span> &#123;fmt.Println(<span class="hljs-string">"errorMsg is: "</span>, result, errorMsg)&#125;&#125;</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令</title>
    <link href="/2020/07/02/git-cmd/"/>
    <url>/2020/07/02/git-cmd/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>今天看到了一份常用Git的命令总结，和大家分享一下~</em> *</strong></p><ul><li><p>git</p><ul><li><p>仓库设计原理</p><ul><li>工作区 Working Directory：就是本地建立git仓库的目录</li><li>版本库 Repository：工作区中的一个隐藏目录 .git，其主要存储了<ul><li>暂存区 stage</li><li>git自动创建的主分支master</li><li>指向主分支master的指针HEAD</li></ul></li><li>暂存区 stage<ul><li><code>git add</code> 的作用是将文件修改添加到暂存区中</li><li><code>git commit</code> 的作用是将修改提交到当前分支上</li><li><code>git commit</code> 后，一次性将所有存放在暂存区的修改提交到当前分支上，此时工作区clean，暂存区clean<br>－ git版本管理的不是文件，而是修改，或者说commit的来源只是暂存区中add的修改记录，所以版本回退会非常快</li></ul></li><li>HEAD指针<ul><li>HEAD指针记录当前最新的版本</li></ul></li></ul></li><li><p>创建仓库</p>  <pre><code class="hljs properties"><span class="hljs-attr">mkdir</span> <span class="hljs-string">RepositoriesName</span><span class="hljs-attr">cd</span> <span class="hljs-string">RepositoriesName</span><span class="hljs-attr">git</span> <span class="hljs-string">RepositoriesName</span></code></pre></li><li><p>添加文件并提交到仓库</p>  <pre><code class="hljs cs"><span class="hljs-comment">//参数m中可以简单说明本次修改的内容</span>git <span class="hljs-keyword">add</span> filenamegit commit -m <span class="hljs-string">"wrote a readme.txt"</span></code></pre></li><li><p>查看仓库当前状态</p>  <pre><code class="hljs ebnf"><span class="hljs-attribute">git status</span></code></pre></li><li><p>查看文件修改内容</p>  <pre><code class="hljs ebnf"><span class="hljs-attribute">git diff filename</span></code></pre></li><li><p>查看版本提交历史</p>  <pre><code class="hljs 1c">git <span class="hljs-built_in">log</span></code></pre></li><li><p>版本回退</p>  <pre><code class="hljs jboss-cli"><span class="hljs-string">//</span>回退历史／／一个^表示一个版本<span class="hljs-string">//</span>回退到上一个版本git reset <span class="hljs-params">--hard</span> HEAD^<span class="hljs-string">//</span>回退到上上一个版本git reset <span class="hljs-params">--hard</span> HEAD^^<span class="hljs-string">//</span>回退到前一百个版本git reset <span class="hljs-params">--hard</span> HEAD-100<span class="hljs-string">//</span>重返未来<span class="hljs-string">//</span>回退到commit ID指定的版本git reset <span class="hljs-params">--hard</span> CommitID</code></pre></li><li><p>查看命令历史，顺便找commit ID，重返未来必备</p>  <pre><code class="hljs angelscript">git <span class="hljs-built_in">ref</span>log</code></pre></li><li><p>撤销修改</p><ul><li><p>当修改还没有从工作区提交至暂存区时，撤销工作区的修改，此时工作区与版本库一致</p>  <pre><code class="hljs 1c"><span class="hljs-comment">//checkout的作用就是用版本库的版本替换工作区的版本</span>git checkout -- filenanme</code></pre></li><li><p>当修改已经从工作区add到暂存区时，先撤销暂存区的修改，再撤销工作区的修改，此时工作区与版本库一致</p>  <pre><code class="hljs 1c"><span class="hljs-comment">//先将暂存区的修改撤销</span>git reset HEAD filename<span class="hljs-comment">//再将工作区的修改撤销</span><span class="hljs-comment">//checkout的作用就是用版本库的版本替换工作区的版本</span>git checkout -- filename</code></pre></li><li><p>当修改已经从暂存区commit到版本库时，参考版本回退的方法</p></li><li><p>当修改已经从版本库push到远程库时，那就gg了。。。</p></li></ul></li><li><p>删除文件</p><ul><li><p>真心要删</p>  <pre><code class="hljs nginx"><span class="hljs-attribute">git</span> rm filenamegit commit -m <span class="hljs-string">"delete filename"</span></code></pre></li><li><p>手抖删错</p>  <pre><code class="hljs 1c"><span class="hljs-comment">//checkout的作用就是用版本库的版本替换工作区的版本</span>git checkout -- filename</code></pre></li></ul></li><li><p>GitHub</p><ul><li><p>连接远程仓库，设置SSHKEYS</p><ul><li><p>用户根目录没有.ssh目录时，生成该目录</p>  <pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">"email@example.com"</span></code></pre></li><li><p>有该目录时，目录下的id_rsa是密钥，id_rsa.pub是共钥，将共钥复制到GitHub中的SSHKEYS中</p><ul><li>这里得用cat把共钥输到屏幕上，要是在vim里直接复制，会有Linux和Windows换行符的差异，会报错（虽然这里直接是Linux环境。。但坑之前踩过。。）</li></ul></li></ul></li><li><p>克隆远程仓库到本地</p>  <pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@github.com:GitHubUserName/RepositoriesName.git</code></pre></li></ul></li><li><p>分支管理</p><ul><li><p>创建分支</p>  <pre><code class="hljs armasm">//先创建分支，再切换到分支上<span class="hljs-symbol">git</span> checkout -<span class="hljs-keyword">b </span><span class="hljs-keyword">branchName</span><span class="hljs-keyword"></span><span class="hljs-keyword">//相当于先创建分支</span><span class="hljs-keyword">git </span><span class="hljs-keyword">branch </span><span class="hljs-keyword">branchName</span><span class="hljs-keyword">//再切换到分支上</span><span class="hljs-keyword">git </span>checkout <span class="hljs-keyword">branchName</span></code></pre></li><li><p>查看当前分支</p>  <pre><code class="hljs ebnf"><span class="hljs-attribute">git branch</span></code></pre></li><li><p>切换分支</p>  <pre><code class="hljs ebnf"><span class="hljs-attribute">git checkout branchName</span></code></pre></li><li><p>合并制定分支branchName到当前分支 Fast forward模式</p>  <pre><code class="hljs cos"><span class="hljs-comment">//此时默认使用Fast forward模式合并，分支不会产生commit</span>git <span class="hljs-keyword">merge</span> branchName</code></pre></li><li><p>合并制定分支branchName到当前分支 普通模式</p>  <pre><code class="hljs stata"><span class="hljs-comment">//分支会产生一个commit</span>git <span class="hljs-keyword">merge</span> --<span class="hljs-keyword">no</span>-ff -<span class="hljs-keyword">m</span> <span class="hljs-string">"merge with no-ff"</span> branchName</code></pre></li><li><p>删除分支</p>  <pre><code class="hljs armasm">//此时分支必须是合并过的<span class="hljs-symbol">git</span> <span class="hljs-keyword">branch </span>-d <span class="hljs-keyword">branchName</span><span class="hljs-keyword"></span><span class="hljs-keyword">//删除一个未合并过的分支</span><span class="hljs-keyword">git </span><span class="hljs-keyword">branch </span>-D <span class="hljs-keyword">branchName</span></code></pre></li><li><p>解决合并冲突</p><ul><li><p>首先查看合并冲突的文件，文件中用符号已经标记出了冲突的内容</p></li><li><p>将内容统一后，再提交</p>  <pre><code class="hljs dockerfile">git <span class="hljs-keyword">add</span><span class="bash">git commit -m <span class="hljs-string">"what"</span></span></code></pre></li><li><p>此时合并自动完成</p>  <pre><code class="hljs gams"><span class="hljs-comment">//git log --graph 可以看到合并分支图</span>git <span class="hljs-built-in">log</span> --graph --pretty=oneline --abbrev-commit<span class="hljs-comment">*   c092d7a (HEAD -&gt; master) and</span>|\| * <span class="hljs-number">152</span>fb2a (featrue) <span class="hljs-keyword">AND</span><span class="hljs-comment">* | 6b80d04 &amp;</span>|/<span class="hljs-comment">* af8429a branch test</span><span class="hljs-comment">* 89adff2 delete test.txt</span><span class="hljs-comment">* 550c40a add new file test.txt</span><span class="hljs-comment">* 34a5dd7 append GPL</span><span class="hljs-comment">* f76a65d add distributed</span><span class="hljs-comment">* d290302 wrote a readme.txr</span></code></pre></li></ul></li><li><p>现场暂存</p>  <pre><code class="hljs ebnf"><span class="hljs-attribute">git stash</span></code></pre></li><li><p>现场暂存列表</p>  <pre><code class="hljs applescript">git stash <span class="hljs-built_in">list</span></code></pre></li><li><p>现场恢复</p>  <pre><code class="hljs angelscript"><span class="hljs-comment">//现场恢复，同时将stash内容删除</span>git stash pop<span class="hljs-comment">//相当于</span><span class="hljs-comment">//先现场恢复</span>git stash apply <span class="hljs-symbol">stash@</span>&#123;<span class="hljs-number">0</span>&#125;<span class="hljs-comment">//再删除暂存的现场</span>git stash drop <span class="hljs-symbol">stash@</span>&#123;<span class="hljs-number">0</span>&#125;</code></pre></li><li><p>查看远程库信息</p>  <pre><code class="hljs ebnf"><span class="hljs-attribute">git remote -v</span></code></pre></li><li><p>从本地推送分支</p>  <pre><code class="hljs gauss"><span class="hljs-comment">//先尝试推送</span>git <span class="hljs-keyword">push</span> origin branchName<span class="hljs-comment">//如果失败了，说明远程分支比本地分支更新，本地的推送与远程库的最新版本有冲突，此时将远程库的最新版本拉下来</span>git pull<span class="hljs-comment">//如果失败了，说明没有指定本地分支与远程分支的链接，此时建立设置链接</span>git branch --set-upstream branchName origin/branchName<span class="hljs-comment">//如果pull成功，但是报merge合并失败，则需要解决合并冲突，并在本地提交</span><span class="hljs-comment">//没有冲突或者解决掉冲突后，向远程库推送</span>git <span class="hljs-keyword">push</span> origin branchName</code></pre></li></ul></li><li><p>标签管理</p><ul><li><p>查看标签    </p>  <pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span></code></pre></li><li><p>创建标签</p>  <pre><code class="hljs lasso"><span class="hljs-comment">//-a 指定标签名</span><span class="hljs-comment">//-m 指定说明文字</span>git <span class="hljs-built_in">tag</span> tagName commitID</code></pre></li><li><p>查看标签内容</p>  <pre><code class="hljs dart">git <span class="hljs-keyword">show</span> tagName</code></pre></li><li><p>推送本地标签到远程库</p>  <pre><code class="hljs gauss"><span class="hljs-comment">//推送某个标签</span>git <span class="hljs-keyword">push</span> origin tagName<span class="hljs-comment">//推送所有未推送到远程库的本地标签</span>git <span class="hljs-keyword">push</span> origin --tags</code></pre></li><li><p>删除标签</p>  <pre><code class="hljs crmsh">//删除本地标签git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> tagName//删除远程标签git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> tagNamegit push origin :refs/tags/tagName</code></pre></li></ul></li></ul></li></ul><p><strong>图片来源：<a href="https://www.git-tower.com/blog/git-cheat-sheet/%20git-cheat-sheet" target="_blank" rel="noopener">git-cheat-sheet</a></strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTMwMTE1MjE3NzE4?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="Git常用命令总结"></p><p>顺便把我的Github贴出来。。。虽然现在还没有什么东西。。。→_→<br><strong>kongkongkkk的Github：<a href="https://github.com/kongkongk%20kongkongkkk%E7%9A%84Github" target="_blank" rel="noopener">Github</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github添加SSH key时的问题</title>
    <link href="/2020/07/02/github-ssh-key/"/>
    <url>/2020/07/02/github-ssh-key/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>这是一个小细节。。记录下来。。→_→</em> *</strong></p><ul><li>问题现象</li></ul><p>在此处Key部分添加SSH key</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI5MTA1MDU3NTQ2?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="添加SSH key&#39;"></p><p>需要将用户本地的如下所示文件中的内容复制到Key部分</p><pre><code class="hljs arcade">~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub</code></pre><p>这时问题来了，通过vim打开此文件，复制内容到Key部分进行add，但添加失败，出现如下信息</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI5MTEwMDExNTE3?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="无效的key"></p><ul><li>问题原因</li></ul><blockquote><p><strong>vim 遵循的是 Linux 的定义，结尾没有 \n 的文本文件不是一个合法的文本文件，因此默认加上了\n</strong><br><strong>windows 认为 \n 是文本行之间的「分隔符」， 所以只有两行之间才需要 \n，一行文本不需要 \n。windows 中具有 10 行的文本应该有 9 个 \n 「分隔符」</strong></p></blockquote><ul><li>解决方法</li></ul><p><strong>使用cat命令将文件中的内容输出到标准输出设备上，即屏幕。。</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI5MTEwOTE1OTUy?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="cat命令显示内容"></p><p>将内容复制到Key部分上，add成功~</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTI5MTExMDU1MjMw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="SSHkey添加成功"></p><p><strong>* <em>Bingo~</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang中unsafe.Sizeof()的问题</title>
    <link href="/2020/07/02/unsafe-sizeof-in-golang/"/>
    <url>/2020/07/02/unsafe-sizeof-in-golang/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>今天看到一段代码感觉很奇怪。。。</em> *</strong></p><p>代码的如下</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">"unsafe"</span><span class="hljs-keyword">const</span> (    a = <span class="hljs-string">"abc"</span>    b = <span class="hljs-built_in">len</span>(a)    c = unsafe.Sizeof(a))<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">println</span>(a, b, c)&#125;</code></pre><p>代码运行结果如下</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTIyMjAxMjEyOTg1?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="string内部实现"></p><p>感觉很奇怪。。为什么unsafe.Sizeof(a)计算出来的值是16？问题先写出来，我要去好好研究一下。。。</p><p><strong>初步解释：因为Golang中的sring内部实现由两部分组成，一部分是指向字符串起始地址的指针，另一部分是字符串的长度，两部分各是8字节，所以一共16字节</strong></p><pre><code class="hljs arduino"><span class="hljs-comment">//组成可以理解成此结构体</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><span class="hljs-keyword">char</span>* <span class="hljs-built_in">buffer</span>;size_tlen;&#125; <span class="hljs-built_in">string</span>;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hello world——再出发~</title>
    <link href="/2020/07/02/hello-world-by-docker/"/>
    <url>/2020/07/02/hello-world-by-docker/</url>
    
    <content type="html"><![CDATA[<p><em>** *新的征程开始喽~ hello world~</em> **</p><p><strong>今天第一次用docker，很开心：）</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTA4MTYxNzA1ODEx?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="hello world——再出发~"></p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感想随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 200. Number of Islands</title>
    <link href="/2020/07/02/number-of-islands/"/>
    <url>/2020/07/02/number-of-islands/</url>
    
    <content type="html"><![CDATA[<p><strong>问题描述：</strong></p><blockquote><p><strong>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</strong></p></blockquote><p><strong>测试用例：</strong></p><p><strong>Example 1:</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">11110</span><span class="hljs-number">11010</span><span class="hljs-number">11000</span><span class="hljs-number">00000</span></code></pre><p><strong>Answer: 1</strong></p><p><strong>Example 2:</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">11000</span><span class="hljs-number">11000</span><span class="hljs-number">00100</span><span class="hljs-number">00011</span></code></pre><p><strong>Answer: 3</strong></p><p><strong>实现如下：</strong></p><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;public:void <span class="hljs-constructor">DFS(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">vector</span>&lt;<span class="hljs-params">char</span>&gt; &gt;&amp; <span class="hljs-params">map</span>, <span class="hljs-params">int</span> <span class="hljs-params">row</span>, <span class="hljs-params">int</span> <span class="hljs-params">col</span>, <span class="hljs-params">int</span> <span class="hljs-params">x</span>, <span class="hljs-params">int</span> <span class="hljs-params">y</span>)</span>&#123;<span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span><span class="hljs-operator"> || </span>y &lt; <span class="hljs-number">0</span><span class="hljs-operator"> || </span>x &gt;= row<span class="hljs-operator"> || </span>y &gt;= col<span class="hljs-operator"> || </span>map<span class="hljs-literal">[<span class="hljs-identifier">x</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">y</span>]</span><span class="hljs-operator"> == </span><span class="hljs-character">'0'</span>)return;map<span class="hljs-literal">[<span class="hljs-identifier">x</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">y</span>]</span> = <span class="hljs-character">'0'</span>;<span class="hljs-comment">//向右</span><span class="hljs-constructor">DFS(<span class="hljs-params">map</span>, <span class="hljs-params">row</span>, <span class="hljs-params">col</span>, <span class="hljs-params">x</span>, <span class="hljs-params">y</span> + 1)</span>;<span class="hljs-comment">//向左</span><span class="hljs-constructor">DFS(<span class="hljs-params">map</span>, <span class="hljs-params">row</span>, <span class="hljs-params">col</span>, <span class="hljs-params">x</span>, <span class="hljs-params">y</span> - 1)</span>;<span class="hljs-comment">//向上</span><span class="hljs-constructor">DFS(<span class="hljs-params">map</span>, <span class="hljs-params">row</span>, <span class="hljs-params">col</span>, <span class="hljs-params">x</span> - 1, <span class="hljs-params">y</span>)</span>;<span class="hljs-comment">//向下</span><span class="hljs-constructor">DFS(<span class="hljs-params">map</span>, <span class="hljs-params">row</span>, <span class="hljs-params">col</span>, <span class="hljs-params">x</span> + 1, <span class="hljs-params">y</span>)</span>;&#125;<span class="hljs-built_in">int</span> islands<span class="hljs-constructor">NumCount(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">vector</span>&lt;<span class="hljs-params">char</span>&gt;&gt;&amp; <span class="hljs-params">map</span>)</span>&#123;<span class="hljs-built_in">int</span> row = map.size<span class="hljs-literal">()</span>;<span class="hljs-built_in">int</span> col = map<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>.size<span class="hljs-literal">()</span>;<span class="hljs-keyword">if</span> (row<span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> || </span>col<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)return <span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;for (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<span class="hljs-keyword">if</span> (map<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span><span class="hljs-operator"> == </span><span class="hljs-character">'1'</span>) &#123;<span class="hljs-comment">//深度遍历</span><span class="hljs-constructor">DFS(<span class="hljs-params">map</span>, <span class="hljs-params">row</span>, <span class="hljs-params">col</span>, <span class="hljs-params">i</span>, <span class="hljs-params">j</span>)</span>;++count;&#125;&#125;&#125;return count;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>判断某个字符串是不是一个合法的IP地址</title>
    <link href="/2020/07/02/determine-whether-a-string-is-a-legal-IP-address/"/>
    <url>/2020/07/02/determine-whether-a-string-is-a-legal-IP-address/</url>
    
    <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p><strong>写一个算法判断某个字符串是不是一个合法的IP地址。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-comment">//ip字符串输入默认采用IPV4的点分十进制法，合法地址为0.0.0.0-255.255.255.255</span><span class="hljs-built_in">bool</span> isLegalIP(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; ip)&#123;<span class="hljs-built_in">int</span> validSegSize = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录一共有多少个分段</span><span class="hljs-built_in">int</span> oneSeg = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录每个分段的数值</span><span class="hljs-built_in">int</span> segLen = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录是否分段有数值</span><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; ip.length(); ++i)&#123;<span class="hljs-comment">//计算每个分段的数值</span><span class="hljs-keyword">if</span> (ip[i] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; ip[i] &lt;= <span class="hljs-string">'9'</span>)&#123;oneSeg = oneSeg * <span class="hljs-number">10</span> + (ip[i] - <span class="hljs-string">'0'</span>);<span class="hljs-comment">//如果分段有数值，就置segLen为1</span>++segLen;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ip[i] == <span class="hljs-string">'.'</span>) <span class="hljs-comment">//如果此字符为'.'，那么就判断之前的那个分段的值是否合法且是否存在值</span>&#123;<span class="hljs-keyword">if</span> (oneSeg &lt;= <span class="hljs-number">255</span> &amp;&amp; segLen &gt; <span class="hljs-number">0</span>)validSegSize++;<span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;oneSeg = <span class="hljs-number">0</span>; <span class="hljs-comment">//重置分段值</span>segLen = <span class="hljs-number">0</span>; <span class="hljs-comment">//重置分段是否存在值</span>&#125;<span class="hljs-keyword">else</span> <span class="hljs-comment">//如果出现0-9或'.'以外的字符都判断为非法</span><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-comment">//判断最后一个分段的合法性</span><span class="hljs-keyword">if</span> (oneSeg &lt;= <span class="hljs-number">255</span> &amp;&amp; segLen &gt; <span class="hljs-number">0</span>)validSegSize++;<span class="hljs-comment">//判断是否一共有四个分段</span><span class="hljs-keyword">if</span> (validSegSize == <span class="hljs-number">4</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求字符串中的最长不重复子串</title>
    <link href="/2020/07/02/find-the-longest-unique-substring-in-a-string/"/>
    <url>/2020/07/02/find-the-longest-unique-substring-in-a-string/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>给定一字符串只包含数字，请写一个算法，找出该字符串中的最长不重复子串（不重复是指子串中每一元素不同于子串中其他元素）</strong><br><strong>如：“120135435”最长不重复子串为 “201354”</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs reasonml"><span class="hljs-comment">//时间复杂度O(n)</span><span class="hljs-comment">//空间复杂度O(m)</span><span class="hljs-keyword">class</span> Solution&#123;public:<span class="hljs-built_in">int</span> max<span class="hljs-constructor">Num(<span class="hljs-params">int</span> <span class="hljs-params">num1</span>, <span class="hljs-params">int</span> <span class="hljs-params">num2</span>)</span>&#123;return num1 &gt;= num2 ? num1 : num2;&#125;void max<span class="hljs-constructor">NonRepetitiveString(<span class="hljs-params">string</span> <span class="hljs-params">str</span>)</span>&#123;<span class="hljs-keyword">if</span> (str.empty<span class="hljs-literal">()</span>)return;<span class="hljs-comment">//map整形数组一共有10个元素，用来保存0-9数字的最后一次出现的下标</span><span class="hljs-built_in">int</span> map<span class="hljs-literal">[<span class="hljs-number">10</span>]</span>;<span class="hljs-comment">//将map数组的所有元素初始化为-1</span>for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)map<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = -<span class="hljs-number">1</span>;<span class="hljs-built_in">int</span> <span class="hljs-keyword">begin</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">//begin用来记录最长无重复子串的起始下标</span><span class="hljs-built_in">int</span> <span class="hljs-keyword">end</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">//end用来记录最长无重复子串的终止下标</span><span class="hljs-built_in">int</span> current = <span class="hljs-number">0</span>; <span class="hljs-comment">//current用来记录当前得到的无重复子串长度</span><span class="hljs-built_in">int</span> pre = -<span class="hljs-number">1</span>; <span class="hljs-comment">//pre用来记录当前无重复子串的起始位置-1</span><span class="hljs-built_in">int</span> len = <span class="hljs-number">0</span>; <span class="hljs-comment">//len用来记录最长无重复子串的长度</span>for (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; str.length<span class="hljs-literal">()</span>; ++j)&#123;<span class="hljs-comment">//判断pre在当前字符最后一次出现位置的左边还是右边</span><span class="hljs-comment">//如果在左边，即pre&lt;map[str[j]]，表示在str[j]的位置已经出现了重复的字符了</span><span class="hljs-comment">//如果在右边，即pre&gt;=map[str[j]]，表示在str[j]的位置没有出现重复字符</span>pre = max<span class="hljs-constructor">Num(<span class="hljs-params">pre</span>, <span class="hljs-params">map</span>[<span class="hljs-params">str</span>[<span class="hljs-params">j</span>]])</span>;<span class="hljs-comment">//计算当前无重复子串的长度</span>current = j - pre;<span class="hljs-comment">//比较当前无重复子串长度是否大于最大无重复子串长度</span><span class="hljs-keyword">if</span> (len &lt;= current)&#123;<span class="hljs-keyword">begin</span> = pre + <span class="hljs-number">1</span>; <span class="hljs-comment">//更新无重复子串的起始下标</span><span class="hljs-keyword">end</span> = j; <span class="hljs-comment">//更新无重复子串的终止下标</span>&#125;len = max<span class="hljs-constructor">Num(<span class="hljs-params">len</span>, <span class="hljs-params">current</span>)</span>; <span class="hljs-comment">//更新最长无重复子串的长度</span>map<span class="hljs-literal">[<span class="hljs-identifier">str</span>[<span class="hljs-identifier">j</span>]</span>] = j; <span class="hljs-comment">//更新str[j]字符最后一次出现的位置下标</span>&#125;<span class="hljs-comment">//打印最长无重复子串</span>for (<span class="hljs-built_in">int</span> k = <span class="hljs-keyword">begin</span>; k &lt;= <span class="hljs-keyword">end</span>; ++k)cout &lt;&lt; str<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux mtrace命令检测内存泄漏</title>
    <link href="/2020/07/02/mtrace-detects-memory-leaks/"/>
    <url>/2020/07/02/mtrace-detects-memory-leaks/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>这篇来学习一下Linux中的一个命令——mtrace，它是怎么用的呢？一起来看看。。。→_→</em> *</strong></p><h3 id="内存泄漏代码"><a href="#内存泄漏代码" class="headerlink" title="内存泄漏代码"></a><strong>内存泄漏代码</strong></h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> *p = <span class="hljs-literal">NULL</span>;p = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">1</span>);<span class="hljs-comment">//free(p);</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>这代码太简单了。。。不解释。。</p><h3 id="mtrace命令的使用"><a href="#mtrace命令的使用" class="headerlink" title="mtrace命令的使用"></a><strong>mtrace命令的使用</strong></h3><ul><li><p>将环境变量MALLOC_TRACE设置为所需输出文件的路径名<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODMwMTUzMDA5MzQ3?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="mtrace设置环境变量"></p></li><li><p>在源代码中引入<code>mcheck.h</code>头文件</p></li></ul><pre><code class="hljs autoit"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mcheck.h&gt;</span></span></code></pre><ul><li><p>在分配内存之前调用<code>mtrace();</code> ，一般在main函数的开头调用</p></li><li><p>在结束检测的地方调用<code>muntrace();</code> ，一般在return之前调用</p></li><li><p>编译程序时需要加上<code>-g</code> 选项，<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODMwMTU0ODU2MTM2?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="mtrace源代码编译"></p></li><li><p>内存泄漏信息将在MALLOC_TRACE环境变量指定的文件中报告，需要使用mtrace命令将信息转换</p></li></ul><pre><code class="hljs arduino"><span class="hljs-comment">//mtrace &lt;exec_file_name&gt; &lt;malloc_trace_filename&gt;</span>mtrace <span class="hljs-built_in">text</span> meminfo.txt</code></pre><pre><code class="hljs asciidoc">Memory not freed:-----------------<span class="hljs-code">   Address     Size     Caller</span>0x08049910      0x4  at /home/Zhang/Desktop/Linux/20170830/test.c:10</code></pre><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h3><pre><code class="hljs angelscript"> <span class="hljs-number">1</span> #include &lt;stdio.h&gt; <span class="hljs-number">2</span> #include &lt;malloc.h&gt; <span class="hljs-number">3</span> #include &lt;mcheck.h&gt; <span class="hljs-number">4</span>  <span class="hljs-number">5</span> <span class="hljs-built_in">int</span> main() <span class="hljs-number">6</span> &#123; <span class="hljs-number">7</span>     mtrace(); <span class="hljs-number">8</span>     <span class="hljs-built_in">int</span> *p = NULL; <span class="hljs-number">9</span> <span class="hljs-number">10</span>     p = (<span class="hljs-built_in">int</span> *)malloc(sizeof(<span class="hljs-built_in">int</span>) * <span class="hljs-number">1</span>);<span class="hljs-number">11</span> <span class="hljs-number">12</span>     <span class="hljs-comment">//free(p);</span><span class="hljs-number">13</span> <span class="hljs-number">14</span>     muntrace();<span class="hljs-number">15</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-number">16</span> &#125;</code></pre><p><strong>* <em>是不是很简单。。。嗯。。。→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转】Linux strace跟踪命令</title>
    <link href="/2020/07/02/strace/"/>
    <url>/2020/07/02/strace/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>遇到了一个问题。。。如何在用户空间跟踪系统调用、信号传递？本篇就来学习学习。。。→_→</em> *</strong></p><h3 id="strace介绍"><a href="#strace介绍" class="headerlink" title="strace介绍"></a><strong>strace介绍</strong></h3><p>strace命令是一个集诊断、调试、统计与一体的工具，我们可以使用strace对应用的系统调用和信号传递的跟踪结果来对应用进行分析，以达到解决问题或者是了解应用工作过程的目的。当然strace与专业的调试工具比如说gdb之类的是没法相比的，因为它不是一个专业的调试器。</p><p>strace的最简单的用法就是执行一个指定的命令，在指定的命令结束之后它也就退出了。在命令执行的过程中，strace会记录和解析命令进程的所有系统调用以及这个进程所接收到的所有的信号值。</p><h3 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a><strong>简单用法</strong></h3><pre><code class="hljs angelscript"><span class="hljs-symbol">root@</span>ubuntu:/usr# strace cat /dev/<span class="hljs-literal">null</span> execve(<span class="hljs-string">"/bin/cat"</span>, [<span class="hljs-string">"cat"</span>, <span class="hljs-string">"/dev/null"</span>], [<span class="hljs-comment">/* 22 vars */</span>]) = <span class="hljs-number">0</span>brk(<span class="hljs-number">0</span>)                                  = <span class="hljs-number">0xab1000</span>access(<span class="hljs-string">"/etc/ld.so.nohwcap"</span>, F_OK)      = <span class="hljs-number">-1</span> ENOENT (No such file <span class="hljs-keyword">or</span> directory)mmap(NULL, <span class="hljs-number">8192</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>) = <span class="hljs-number">0x7f29379a7000</span>access(<span class="hljs-string">"/etc/ld.so.preload"</span>, R_OK)      = <span class="hljs-number">-1</span> ENOENT (No such file <span class="hljs-keyword">or</span> directory)...brk(<span class="hljs-number">0</span>) = <span class="hljs-number">0xab1000</span>brk(<span class="hljs-number">0xad2000</span>) = <span class="hljs-number">0xad2000</span>fstat(<span class="hljs-number">1</span>, &#123;st_mode=S_IFCHR|<span class="hljs-number">0620</span>, st_rdev=makedev(<span class="hljs-number">136</span>, <span class="hljs-number">0</span>), ...&#125;) = <span class="hljs-number">0</span>open(<span class="hljs-string">"/dev/null"</span>, O_RDONLY) = <span class="hljs-number">3</span>fstat(<span class="hljs-number">3</span>, &#123;st_mode=S_IFCHR|<span class="hljs-number">0666</span>, st_rdev=makedev(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>), ...&#125;) = <span class="hljs-number">0</span>read(<span class="hljs-number">3</span>, <span class="hljs-string">""</span>, <span class="hljs-number">32768</span>) = <span class="hljs-number">0</span>close(<span class="hljs-number">3</span>) = <span class="hljs-number">0</span>close(<span class="hljs-number">1</span>) = <span class="hljs-number">0</span>close(<span class="hljs-number">2</span>) = <span class="hljs-number">0</span>exit_group(<span class="hljs-number">0</span>) = ?</code></pre><p>每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。</p><p>strace 显示这些调用的参数并返回符号形式的值。strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核</p><pre><code class="hljs mercury">strace -o output.txt -T -tt -e <span class="hljs-keyword">trace</span><span class="hljs-built_in">=</span><span class="hljs-built_in">all</span> -p <span class="hljs-number">28979</span></code></pre><p>上面的含义是 跟踪28979进程的所有系统调用（<code>-e trace=all</code>），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。</p><p>在堡垒机等等开发过程中,我们需要记录某用户链接用户的所有操作,可以使用下面方式:</p><pre><code class="hljs stylus">sudo strace -t -<span class="hljs-selector-tag">p</span> <span class="hljs-number">1211</span> -o ssh<span class="hljs-selector-class">.log</span> -f</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a><strong>参数</strong></h3><pre><code class="hljs ldif"><span class="hljs-literal">-c 统计每一系统调用的所执行的时间,次数和出错的次数等. </span><span class="hljs-literal">-d 输出strace关于标准错误的调试信息. </span><span class="hljs-literal">-f 跟踪由fork调用所产生的子进程. </span><span class="hljs-literal">-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号. </span><span class="hljs-literal">-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪. </span><span class="hljs-literal">-h 输出简要的帮助信息. </span><span class="hljs-literal">-i 输出系统调用的入口指针. </span><span class="hljs-literal">-q 禁止输出关于脱离的消息. </span><span class="hljs-literal">-r 打印出相对时间关于,,每一个系统调用. </span><span class="hljs-literal">-t 在输出中的每一行前加上时间信息. </span><span class="hljs-literal">-tt 在输出中的每一行前加上时间信息,微秒级. </span><span class="hljs-literal">-ttt 微秒级输出,以秒了表示时间. </span><span class="hljs-literal">-T 显示每一调用所耗的时间. </span><span class="hljs-literal">-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出. </span><span class="hljs-literal">-V 输出strace的版本信息. </span><span class="hljs-literal">-x 以十六进制形式输出非标准字符串 </span><span class="hljs-literal">-xx 所有字符串以十六进制形式输出. </span><span class="hljs-literal">-a column </span>设置返回值的输出位置.默认 为40. <span class="hljs-literal">-e expr </span>指定一个表达式,用来控制如何跟踪.格式如下: [qualifier=][!]value1[,value2]... <span class="hljs-attribute">qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如</span>: <span class="hljs-literal">-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none. </span>注意有些shell使用!来执行历史记录里的命令,所以要使用\\. <span class="hljs-literal">-e trace=set </span>只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all. <span class="hljs-literal">-e trace=file </span>只跟踪有关文件操作的系统调用. <span class="hljs-literal">-e trace=process </span>只跟踪有关进程控制的系统调用. <span class="hljs-literal">-e trace=network </span>跟踪与网络有关的所有系统调用. <span class="hljs-literal">-e strace=signal </span>跟踪所有与系统信号有关的 系统调用 <span class="hljs-literal">-e trace=ipc </span>跟踪所有与进程通讯有关的系统调用 <span class="hljs-literal">-e abbrev=set </span>设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all. <span class="hljs-literal">-e raw=set </span>将指 定的系统调用的参数以十六进制显示. <span class="hljs-literal">-e signal=set </span>指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号. <span class="hljs-literal">-e read=set </span>输出从指定文件中读出 的数据.例如: <span class="hljs-literal">-e read=3,5 </span><span class="hljs-literal">-e write=set </span>输出写入到指定文件中的数据. <span class="hljs-literal">-o filename </span>将strace的输出写入文件filename <span class="hljs-literal">-p pid </span>跟踪指定的进程pid. <span class="hljs-literal">-s strsize </span>指定输出的字符串的最大长度.默认为32.文件名一直全部输出. <span class="hljs-literal">-u username </span>以username 的UID和GID执行被跟踪的命令</code></pre><h3 id="strace案例"><a href="#strace案例" class="headerlink" title="strace案例"></a><strong>strace案例</strong></h3><h4 id="用strace调试程序"><a href="#用strace调试程序" class="headerlink" title="用strace调试程序"></a><strong>用strace调试程序</strong></h4><p>strace是一个必不可少的 调试工具，strace用来监视系统调用。你不仅可以调试一个新开始的程序，也可以调试一个已经在运行的程序（把strace绑定到一个已有的PID上 面）。</p><p>首先让我们看一个真实的例子：启动KDE时出现问题.</p><p>错误信息:</p><pre><code class="hljs sqf"><span class="hljs-variable">_KDE_IceTransSocketCreateListener</span>: failed <span class="hljs-keyword">to</span> bind listener<span class="hljs-variable">_KDE_IceTransSocketUNIXCreateListener</span>: ...SocketCreateListener() failed<span class="hljs-variable">_KDE_IceTransMakeAllCOTSServerListeners</span>: failed <span class="hljs-keyword">to</span> create listener <span class="hljs-keyword">for</span> <span class="hljs-built_in">local</span>Cannot establish any listening sockets DCOPServer self-test failed.</code></pre><p>对 我来说这个错误信息没有太多意义，只是一个对KDE来说至关重要的负责进程间通信的程序无法启动。我还可以知道这个错误和ICE协议（Inter Client Exchange）有关，除此之外，我不知道什么是KDE启动出错的原因。</p><p>我决定采用strace看一下在启动 dcopserver时到底程序做了什么：</p><pre><code class="hljs armasm"><span class="hljs-keyword">strace </span>-f -F -o ~/dcop-<span class="hljs-keyword">strace.txt </span>dcopserver</code></pre><p>这里 -f -F选项告诉strace同时跟踪fork和vfork出来的进程，-o选项把所有strace输出写到~/dcop-strace.txt里 面，dcopserver是要启动和调试的程序。</p><p>再次出现错误之后，我检查了错误输出文件dcop-strace.txt，文件里有很多 系统调用的记录。在程序运行出错前的有关记录如下：</p><pre><code class="hljs lsl">mkdir(<span class="hljs-string">"/tmp/.ICE-unix"</span>, <span class="hljs-number">0777</span>) = <span class="hljs-number">-1</span> EEXIST (File exists)lstat64(<span class="hljs-string">"/tmp/.ICE-unix"</span>, &#123;st_mode=S_IFDIR|S_ISVTX|<span class="hljs-number">0755</span>, st_size=<span class="hljs-number">4096</span>, ...&#125;) = <span class="hljs-number">0</span>unlink(<span class="hljs-string">"/tmp/.ICE-unix/dcop27207-1066844596"</span>) = <span class="hljs-number">-1</span> ENOENT (No such file or directory)bind(<span class="hljs-number">3</span>, &#123;sin_family=AF_UNIX, path=<span class="hljs-string">"/tmp/.ICE-unix/dcop27207-1066844596"</span>&#125;, <span class="hljs-number">38</span>) = <span class="hljs-number">-1</span> EACCES (Permission denied) write(<span class="hljs-number">2</span>, <span class="hljs-string">"_KDE_IceTrans"</span>, <span class="hljs-number">13</span>) = <span class="hljs-number">13</span>write(<span class="hljs-number">2</span>, <span class="hljs-string">"SocketCreateListener: failed to "</span>..., <span class="hljs-number">46</span>) = <span class="hljs-number">46</span>close(<span class="hljs-number">3</span>) = <span class="hljs-number">0</span> <span class="hljs-number">27207</span> write(<span class="hljs-number">2</span>, <span class="hljs-string">"_KDE_IceTrans"</span>, <span class="hljs-number">13</span>) = <span class="hljs-number">13</span>write(<span class="hljs-number">2</span>, <span class="hljs-string">"SocketUNIXCreateListener: ...Soc"</span>..., <span class="hljs-number">59</span>) = <span class="hljs-number">59</span>umask(<span class="hljs-number">0</span>) = <span class="hljs-number">0</span> <span class="hljs-number">27207</span> write(<span class="hljs-number">2</span>, <span class="hljs-string">"_KDE_IceTrans"</span>, <span class="hljs-number">13</span>) = <span class="hljs-number">13</span>write(<span class="hljs-number">2</span>, <span class="hljs-string">"MakeAllCOTSServerListeners: fail"</span>..., <span class="hljs-number">64</span>) = <span class="hljs-number">64</span>write(<span class="hljs-number">2</span>, <span class="hljs-string">"Cannot establish any listening s"</span>..., <span class="hljs-number">39</span>) = <span class="hljs-number">39</span></code></pre><p>其中第一行显示程序试图创建/tmp/.ICE-unix目录，权限为0777，这个操作因为目录已经存在而失败了。第二个系统调用（lstat64）检查 了目录状态，并显示这个目录的权限是0755，这里出现了第一个程序运行错误的线索：程序试图创建属性为0777的目录，但是已经存在了一个属性为 0755的目录。第三个系统调用（unlink）试图删除一个文件，但是这个文件并不存在。这并不奇怪，因为这个操作只是试图删掉可能存在的老文件。</p><p>但是，第四行确认了错误所在。他试图绑定到/tmp/.ICE-unix/dcop27207-1066844596，但是出现了拒绝访问错误。. ICE_unix目录的用户和组都是root，并且只有所有者具有写权限。一个非root用户无法在这个目录下面建立文件，如果把目录属性改成0777， 则前面的操作有可能可以执行，而这正是第一步错误出现时进行过的操作。</p><p>所以我运行了chmod 0777 /tmp/.ICE-unix之后KDE就可以正常启动了，问题解决了，用strace进行跟踪调试只需要花很短的几分钟时间跟踪程序运行，然后检查并分 析输出文件。</p><p>说明：运行chmod 0777只是一个测试，一般不要把一个目录设置成所有用户可读写，同时不设置粘滞位(sticky bit)。给目录设置粘滞位可以阻止一个用户随意删除可写目录下面其他人的文件。一般你会发现/tmp目录因为这个原因设置了粘滞位。KDE可以正常启动 之后，运行chmod +t /tmp/.ICE-unix给.ICE_unix设置粘滞位。</p><h4 id="解决依赖库问题"><a href="#解决依赖库问题" class="headerlink" title="解决依赖库问题"></a><strong>解决依赖库问题</strong></h4><p>starce 的另一个用处是解决和动态库相关的问题。当对一个可执行文件运行ldd时，它会告诉你程序使用的动态库和找到动态库的位置。但是如果你正在使用一个比较老 的glibc版本（2.2或更早），你可能会有一个有bug的ldd程序，它可能会报告在一个目录下发现一个动态库，但是真正运行程序时动态连接程序 （/lib/ld-linux.so.2）却可能到另外一个目录去找动态连接库。这通常因为/etc/ld.so.conf和 /etc/ld.so.cache文件不一致，或者/etc/ld.so.cache被破坏。在glibc 2.3.2版本上这个错误不会出现，可能ld-linux的这个bug已经被解决了。</p><p>尽管这样，ldd并不能把所有程序依赖的动态库列出 来，系统调用dlopen可以在需要的时候自动调入需要的动态库，而这些库可能不会被ldd列出来。作为glibc的一部分的NSS（Name Server Switch）库就是一个典型的例子，NSS的一个作用就是告诉应用程序到哪里去寻找系统帐号数据库。应用程序不会直接连接到NSS库，glibc则会通 过dlopen自动调入NSS库。如果这样的库偶然丢失，你不会被告知存在库依赖问题，但这样的程序就无法通过用户名解析得到用户ID了。让我们看一个例子：<br>whoami程序会给出你自己的用户名，这个程序在一些需要知道运行程序的真正用户的脚本程序里面非常有用，whoami的一个示例 输出如下：</p><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>whoamiroot</code></pre><p>假设因为某种原因在升 级glibc的过程中负责用户名和用户ID转换的库NSS丢失，我们可以通过把nss库改名来模拟这个环境：</p><pre><code class="hljs crystal">$ mv /<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">libnss_files</span>.<span class="hljs-title">so</span>.2 /<span class="hljs-title">lib</span>/<span class="hljs-title">libnss_files</span>.<span class="hljs-title">so</span>.2.<span class="hljs-title">backup</span> </span>$ whoami<span class="hljs-symbol">whoami:</span> cannot find username <span class="hljs-keyword">for</span> UID <span class="hljs-number">0</span></code></pre><p>这里你可以看到，运行whoami时出现了错误，ldd程序的输出不会提供有用的帮助：</p><pre><code class="hljs angelscript">$ ldd /usr/bin/whoamilibc.so<span class="hljs-number">.6</span> =&gt; /lib/libc.so<span class="hljs-number">.6</span> (<span class="hljs-number">0x4001f000</span>)/lib/ld-linux.so<span class="hljs-number">.2</span> =&gt; /lib/ld-linux.so<span class="hljs-number">.2</span> (<span class="hljs-number">0x40000000</span>)</code></pre><p>你只会看到whoami依赖Libc.so.6和ld-linux.so.2，它没有给出运行whoami所必须的其他库。这里时用strace跟踪 whoami时的输出：</p><pre><code class="hljs stylus">$ strace -o whoami-strace<span class="hljs-selector-class">.txt</span> whoami<span class="hljs-function"><span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-string">"/lib/libnss_files.so.2"</span>, O_RDONLY)</span></span> = -<span class="hljs-number">1</span> ENOENT (No such file or directory)<span class="hljs-function"><span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-string">"/lib/i686/mmx/libnss_files.so.2"</span>, O_RDONLY)</span></span> = -<span class="hljs-number">1</span> ENOENT (No such file or directory)<span class="hljs-function"><span class="hljs-title">stat64</span><span class="hljs-params">(<span class="hljs-string">"/lib/i686/mmx"</span>, <span class="hljs-number">0</span>xbffff190)</span></span> = -<span class="hljs-number">1</span> ENOENT (No such file or directory) <span class="hljs-function"><span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-string">"/lib/i686/libnss_files.so.2"</span>, O_RDONLY)</span></span> = -<span class="hljs-number">1</span> ENOENT (No such file or directory)<span class="hljs-function"><span class="hljs-title">stat64</span><span class="hljs-params">(<span class="hljs-string">"/lib/i686"</span>, <span class="hljs-number">0</span>xbffff190)</span></span> = -<span class="hljs-number">1</span> ENOENT (No such file or directory)<span class="hljs-function"><span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-string">"/lib/mmx/libnss_files.so.2"</span>, O_RDONLY)</span></span> = -<span class="hljs-number">1</span> ENOENT (No such file or directory)<span class="hljs-function"><span class="hljs-title">stat64</span><span class="hljs-params">(<span class="hljs-string">"/lib/mmx"</span>, <span class="hljs-number">0</span>xbffff190)</span></span> = -<span class="hljs-number">1</span> ENOENT (No such file or directory) <span class="hljs-function"><span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-string">"/lib/libnss_files.so.2"</span>, O_RDONLY)</span></span> = -<span class="hljs-number">1</span> ENOENT (No such file or directory)<span class="hljs-function"><span class="hljs-title">stat64</span><span class="hljs-params">(<span class="hljs-string">"/lib"</span>, &#123;st_mode=S_IFDIR|<span class="hljs-number">0755</span>, st_size=<span class="hljs-number">2352</span>, ...&#125;)</span></span> = <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-string">"/usr/lib/i686/mmx/libnss_files.so.2"</span>, O_RDONLY)</span></span> = -<span class="hljs-number">1</span> ENOENT (No such file or directory)<span class="hljs-function"><span class="hljs-title">stat64</span><span class="hljs-params">(<span class="hljs-string">"/usr/lib/i686/mmx"</span>, <span class="hljs-number">0</span>xbffff190)</span></span> = -<span class="hljs-number">1</span> ENOENT (No such file or directory) <span class="hljs-function"><span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-string">"/usr/lib/i686/libnss_files.so.2"</span>, O_RDONLY)</span></span> = -<span class="hljs-number">1</span> ENOENT (No such file or directory)</code></pre><p>你可以发现在不同目录下面查找libnss.so.2的尝试，但是都失败了。如果没有strace这样的工具，很难发现这个错误是由于缺少动态库造成的。现 在只需要找到libnss.so.2并把它放回到正确的位置就可以了。</p><p>限制strace只跟踪特定的系统调用</p><p>如果你已经知道你要找什么，你可以让strace只跟踪一些类型的系统调用。例如，你需要看看在configure脚本里面执行的程序，你需要监视的系统调 用就是execve。让strace只记录execve的调用用这个命令：</p><pre><code class="hljs armasm"><span class="hljs-keyword">strace </span>-f -o configure-<span class="hljs-keyword">strace.txt </span>-e execve ./configure</code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO复用——epoll内核源代码剖析</title>
    <link href="/2020/07/02/epoll/"/>
    <url>/2020/07/02/epoll/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>最近拖延症又犯了。。。嗯。。。废话不多说。。。直接上硬货。。。→_→</em> *</strong></p><p><strong>比较select系统调用请戳传送门——</strong><a href="http://blog.csdn.net/kongkongkkk/article/details/77099442" target="_blank" rel="noopener"><strong>select内核源代码剖析</strong></a></p><p><strong>了解poll机制请戳传送门——</strong><a href="http://blog.csdn.net/kongkongkkk/article/details/77273199" target="_blank" rel="noopener"><strong>poll机制内核源代码剖析</strong></a></p><ul><li><strong>epoll_create</strong></li></ul><p>这是Linux_3.0.12内核版本。。。和之前剖析的2.4.0内核版本的系统调用有一些差别。。。所以直接进SYSCALL_DEFINE1。。。</p><pre><code class="hljs gauss"><span class="hljs-comment">//为每一个监听的事件都分配一个epitem数据结构</span><span class="hljs-keyword">struct</span> <span class="hljs-type">epitem</span> &#123;<span class="hljs-comment">/* RB tree node used to link this structure to the eventpoll RB tree */</span><span class="hljs-comment">//每个epitem都存放在eventpoll中以rbr为根的红黑树中</span><span class="hljs-comment">//rbn记录epitem在红黑树中的结点</span><span class="hljs-keyword">struct</span> <span class="hljs-type">rb_node</span> rbn;<span class="hljs-comment">/* List header used to link this structure to the eventpoll ready list */</span><span class="hljs-comment">//每个就绪事件所对应的epitem都链入了eventpoll中的rdllink</span><span class="hljs-comment">//rdllink记录就绪链表头</span><span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> rdllink;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Works together "struct eventpoll"-&gt;ovflist in keeping the</span><span class="hljs-comment"> * single linked chain of items.</span><span class="hljs-comment"> */</span><span class="hljs-comment">//记录每个epitem在eventpoll数据结构中的ovflist的下一个epitem</span><span class="hljs-keyword">struct</span> <span class="hljs-type">epitem</span> *next;<span class="hljs-comment">/* The file descriptor information this item refers to */</span><span class="hljs-comment">//epoll_filefd数据结构记录epitem所对应的struct file和fd文件描述符</span><span class="hljs-keyword">struct</span> <span class="hljs-type">epoll_filefd</span> ffd;<span class="hljs-comment">/* Number of active wait queue attached to poll operations */</span><span class="hljs-comment">//poll操作上的等待队列个数</span>int nwait;<span class="hljs-comment">/* List containing poll wait queues */</span><span class="hljs-comment">//包含等待队列对头的单链表</span><span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> pwqlist;<span class="hljs-comment">/* The "container" of this item */</span><span class="hljs-comment">//记录epitem所属哪一个eventpoll数据结构</span><span class="hljs-keyword">struct</span> <span class="hljs-type">eventpoll</span> *ep;<span class="hljs-comment">/* List header used to link this item to the "struct file" items list */</span><span class="hljs-comment">//记录epitem所对应的struct file的单链表</span><span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> fllink;<span class="hljs-comment">/* The structure that describe the interested events and the source fd */</span><span class="hljs-comment">//记录epitem对应的epoll_event数据结构，epoll_event是epoll_ctl函数传入的参数 </span><span class="hljs-keyword">struct</span> <span class="hljs-type">epoll_event</span> event;&#125;;</code></pre><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> &#123;</span><span class="hljs-comment">/* Protect the access to this structure */</span><span class="hljs-keyword">spinlock_t</span> lock;<span class="hljs-comment">/*</span><span class="hljs-comment"> * This mutex is used to ensure that files are not removed</span><span class="hljs-comment"> * while epoll is using them. This is held during the event</span><span class="hljs-comment"> * collection loop, the file cleanup path, the epoll file exit</span><span class="hljs-comment"> * code and the ctl operations.</span><span class="hljs-comment"> */</span><span class="hljs-comment">//对事件进行处理时，内核都都会持有这个互斥锁，因此在内核态中epoll的相关操作可以保证是线程安全的</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> <span class="hljs-title">mtx</span>;</span><span class="hljs-comment">/* Wait queue used by sys_epoll_wait() */</span><span class="hljs-comment">//调用sys_epoll_wait()时，存放当前进程的等待队列</span><span class="hljs-keyword">wait_queue_head_t</span> wq;<span class="hljs-comment">/* Wait queue used by file-&gt;poll() */</span><span class="hljs-comment">//此等待队列存放监听事件的poll操作</span><span class="hljs-keyword">wait_queue_head_t</span> poll_wait;<span class="hljs-comment">/* List of ready file descriptors */</span><span class="hljs-comment">//为每个事件都会分配一个epitem，当事件就绪时其所对应的epitem就会链入rdllist双向链表中</span><span class="hljs-comment">//epitem数据类型定义在上面</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">rdllist</span>;</span><span class="hljs-comment">/* RB tree root used to store monitored fd structs */</span><span class="hljs-comment">//为每个事件都会分配一个epitem，所有的epitem都会存放在这个红黑树中</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> <span class="hljs-title">rbr</span>;</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * This is a single linked list that chains all the "struct epitem" that</span><span class="hljs-comment"> * happened while transferring ready events to userspace w/out</span><span class="hljs-comment"> * holding -&gt;lock.</span><span class="hljs-comment"> */</span><span class="hljs-comment">//就绪事件在转移到用户空间时，发生了就绪事件，其所对应的epitem被链入ovflist双向链表中</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">ovflist</span>;</span><span class="hljs-comment">/* The user that created the eventpoll descriptor */</span><span class="hljs-comment">//保存用户信息，比如资源的上限值</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span>;</span>&#125;;</code></pre><pre><code class="hljs mel">SYSCALL_DEFINE1(epoll_create1, <span class="hljs-keyword">int</span>, flags)&#123;<span class="hljs-keyword">int</span> <span class="hljs-keyword">error</span>;<span class="hljs-comment">//eventpoll是epoll中非常重要的数据结构！每一个epollfd都有一个对应的eventpoll数据结构</span><span class="hljs-comment">//eventpoll数据结构定义在上面</span>struct eventpoll *ep = NULL;<span class="hljs-comment">/* Check the EPOLL_* constant for consistency.  */</span>BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);<span class="hljs-keyword">if</span> (flags &amp; ~EPOLL_CLOEXEC)<span class="hljs-keyword">return</span> -EINVAL;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Create the internal data structure ("struct eventpoll").</span><span class="hljs-comment"> */</span><span class="hljs-comment">//初始化一个eventpoll数据结构</span><span class="hljs-comment">//ep_alloc定义在下面</span><span class="hljs-keyword">error</span> = ep_alloc(&amp;ep);<span class="hljs-keyword">if</span> (<span class="hljs-keyword">error</span> &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">error</span>;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Creates all the items needed to setup an eventpoll file. That is,</span><span class="hljs-comment"> * a file structure and a free file descriptor.</span><span class="hljs-comment"> */</span><span class="hljs-comment">//创建epollfd</span><span class="hljs-comment">//因为epollfd并不存在真正对应的文件，所以内核创建了一个虚拟的文件，并为这个虚拟文件分配struct file数据结构</span><span class="hljs-comment">//参数eventpoll_fops就是file operations，即文件支持的操作</span><span class="hljs-comment">//关于file operations在之前的poll机制内核源代码剖析一文中已经做了非常深入的解释</span><span class="hljs-comment">//这里简单解释一下，file operations中的每一个成员都是回调函数指针，对应每一种操作的具体实现</span><span class="hljs-comment">//epollfd文件实现了三种操作，即release、poll、llseek</span><span class="hljs-comment">//eventpoll_fops数据结构定义在下面</span><span class="hljs-comment">//参数ep就是epollfd所对应的eventpoll数据结构，在anon_inode_getfd中，将struct file的private_data成员赋值为ep的地址</span><span class="hljs-comment">//anon_inode_getfd定义在下面</span><span class="hljs-keyword">error</span> = anon_inode_getfd(<span class="hljs-string">"[eventpoll]"</span>, &amp;eventpoll_fops, ep, O_RDWR | (flags &amp; O_CLOEXEC));<span class="hljs-keyword">if</span> (<span class="hljs-keyword">error</span> &lt; <span class="hljs-number">0</span>)ep_free(ep);<span class="hljs-comment">//返回epollfd的值</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">error</span>;&#125;SYSCALL_DEFINE1(epoll_create, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">size</span>)&#123;<span class="hljs-comment">//实际上传入的size参数并没有什么用。。。</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">size</span> &lt;= <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> -EINVAL;<span class="hljs-comment">//sys_epoll_create1定义在上面</span><span class="hljs-keyword">return</span> sys_epoll_create1(<span class="hljs-number">0</span>);&#125;</code></pre><pre><code class="hljs reasonml">static <span class="hljs-built_in">int</span> ep<span class="hljs-constructor">_alloc(<span class="hljs-params">struct</span> <span class="hljs-params">eventpoll</span> <span class="hljs-operator">**</span><span class="hljs-params">pep</span>)</span>&#123;<span class="hljs-built_in">int</span> error;<span class="hljs-keyword">struct</span> user_struct *user;<span class="hljs-keyword">struct</span> eventpoll *ep;<span class="hljs-comment">//获取当前用户信息</span>user = get<span class="hljs-constructor">_current_user()</span>;error = -ENOMEM;<span class="hljs-comment">//通过kmalloc为eventpoll数据结构分配内存空间</span>ep = kzalloc(sizeof(*ep), GFP_KERNEL);<span class="hljs-keyword">if</span> (unlikely(!ep))goto free_uid;spin<span class="hljs-constructor">_lock_init(&amp;<span class="hljs-params">ep</span>-&gt;<span class="hljs-params">lock</span>)</span>;mutex<span class="hljs-constructor">_init(&amp;<span class="hljs-params">ep</span>-&gt;<span class="hljs-params">mtx</span>)</span>;<span class="hljs-comment">//初始化eventpoll中的wq</span>init<span class="hljs-constructor">_waitqueue_head(&amp;<span class="hljs-params">ep</span>-&gt;<span class="hljs-params">wq</span>)</span>;<span class="hljs-comment">//初始化eventpoll中的poll_wait</span>init<span class="hljs-constructor">_waitqueue_head(&amp;<span class="hljs-params">ep</span>-&gt;<span class="hljs-params">poll_wait</span>)</span>;<span class="hljs-comment">//初始化存放就绪事件所对应的epitem的双向链表</span><span class="hljs-constructor">INIT_LIST_HEAD(&amp;<span class="hljs-params">ep</span>-&gt;<span class="hljs-params">rdllist</span>)</span>;<span class="hljs-comment">//初始化存放所有事件对应的epiitem的红黑树，初始值为NULL</span><span class="hljs-comment">//#define RB_ROOT(struct rb_root) &#123; NULL, &#125;</span>ep-&gt;rbr = RB_ROOT;<span class="hljs-comment">//初始化转移到用户空间之前，存放就绪事件所对应的epitem的双向链表，初始值为-1L</span><span class="hljs-comment">//#define EP_UNACTIVE_PTR ((void *) -1L)</span>ep-&gt;ovflist = EP_UNACTIVE_PTR;<span class="hljs-comment">//初始化用户信息</span>ep-&gt;user = user;<span class="hljs-comment">//为eventpoll数据结构指针赋值</span>*pep = ep;return <span class="hljs-number">0</span>;free_uid:free<span class="hljs-constructor">_uid(<span class="hljs-params">user</span>)</span>;return error;&#125;</code></pre><pre><code class="hljs arduino"><span class="hljs-comment">//由此可见epollfd所对应的的匿名文件只实现了三种操作</span><span class="hljs-comment">//release操作为释放epollfd所对应的eventpoll数据结构</span><span class="hljs-comment">//ep_eventpoll_release定义在下面</span><span class="hljs-comment">//poll操作为事件就绪时，调用poll操作对应的回调函数对当前进程进行一些列操作</span><span class="hljs-comment">//ep_eventpoll_poll定义先放一边，在epoll_wait中会详细解释</span><span class="hljs-comment">//llseek操作为获取匿名文件的游标偏移</span><span class="hljs-comment">//noop_llseek定义在下面</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">eventpoll_fops</span> = &#123;</span>.<span class="hljs-built_in">release</span>= ep_eventpoll_release, .poll= ep_eventpoll_poll,.llseek= noop_llseek,&#125;;</code></pre><pre><code class="hljs reasonml">static <span class="hljs-built_in">int</span> ep<span class="hljs-constructor">_eventpoll_release(<span class="hljs-params">struct</span> <span class="hljs-params">inode</span> <span class="hljs-operator">*</span><span class="hljs-params">inode</span>, <span class="hljs-params">struct</span> <span class="hljs-params">file</span> <span class="hljs-operator">*</span><span class="hljs-params">file</span>)</span>&#123;<span class="hljs-comment">//通过struct file中的成员private_data得到epollfd所对应的eventpoll数据结构</span><span class="hljs-keyword">struct</span> eventpoll *ep = file-&gt;private_data;<span class="hljs-comment">//释放eventpoll数据结构</span><span class="hljs-keyword">if</span> (ep)ep<span class="hljs-constructor">_free(<span class="hljs-params">ep</span>)</span>;return <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs reasonml">loff_t noop<span class="hljs-constructor">_llseek(<span class="hljs-params">struct</span> <span class="hljs-params">file</span> <span class="hljs-operator">*</span><span class="hljs-params">file</span>, <span class="hljs-params">loff_t</span> <span class="hljs-params">offset</span>, <span class="hljs-params">int</span> <span class="hljs-params">origin</span>)</span>&#123;<span class="hljs-comment">//返回当前文件的偏移量</span>return file-&gt;f_pos;&#125;</code></pre><pre><code class="hljs mel"><span class="hljs-keyword">int</span> anon_inode_getfd(const char *name, const struct file_operations *fops,     void *priv, <span class="hljs-keyword">int</span> flags)&#123;<span class="hljs-keyword">int</span> <span class="hljs-keyword">error</span>, fd;struct <span class="hljs-keyword">file</span> *<span class="hljs-keyword">file</span>;<span class="hljs-comment">//分配文件描述符，即epollfd</span><span class="hljs-keyword">error</span> = get_unused_fd_flags(flags);<span class="hljs-keyword">if</span> (<span class="hljs-keyword">error</span> &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">error</span>;fd = <span class="hljs-keyword">error</span>;<span class="hljs-comment">//创建匿名文件</span><span class="hljs-keyword">file</span> = anon_inode_getfile(name, fops, priv, flags);<span class="hljs-keyword">if</span> (IS_ERR(<span class="hljs-keyword">file</span>)) &#123;<span class="hljs-keyword">error</span> = PTR_ERR(<span class="hljs-keyword">file</span>);goto err_put_unused_fd;&#125;<span class="hljs-comment">//将文件描述符fd和匿名文件绑定，即将file_struct中的fdtable的成员fd[fd]赋值为file</span>fd_install(fd, <span class="hljs-keyword">file</span>);<span class="hljs-comment">//返回epollfd的值</span><span class="hljs-keyword">return</span> fd;err_put_unused_fd:put_unused_fd(fd);<span class="hljs-keyword">return</span> <span class="hljs-keyword">error</span>;&#125;</code></pre><ul><li><strong>epoll_ctl</strong></li></ul><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span></span> &#123;__<span class="hljs-built_in">u32</span> events; <span class="hljs-comment">//epoll事件类型</span>__<span class="hljs-built_in">u64</span> data; <span class="hljs-comment">//指定所要监听的事件的文件描述符</span>&#125; EPOLL_PACKED;</code></pre><pre><code class="hljs mel"><span class="hljs-comment">//参数epfd就是epoll_create中返回的epollfd</span><span class="hljs-comment">//参数op指定对事件的操作类型，具体分为三种</span><span class="hljs-comment">//#define EPOLL_CTL_ADD 1 添加新的监听事件</span><span class="hljs-comment">//#define EPOLL_CTL_DEL 2 删除监听事件</span><span class="hljs-comment">//#define EPOLL_CTL_MOD 3 修改监听事件</span><span class="hljs-comment">//参数fd就是想要操作的文件描述符</span><span class="hljs-comment">//参数event表示监听的是什么事件类型</span><span class="hljs-comment">//数据可读事件EPOLLIN、高效工作事件模式EPOLLET、事件只被处理一次EPOLLONESHOT</span><span class="hljs-comment">//epoll_event数据结构定义在上面</span>SYSCALL_DEFINE4(epoll_ctl, <span class="hljs-keyword">int</span>, epfd, <span class="hljs-keyword">int</span>, op, <span class="hljs-keyword">int</span>, fd,struct epoll_event __user *, <span class="hljs-keyword">event</span>)&#123;<span class="hljs-keyword">int</span> <span class="hljs-keyword">error</span>; <span class="hljs-keyword">int</span> did_lock_epmutex = <span class="hljs-number">0</span>;struct <span class="hljs-keyword">file</span> *<span class="hljs-keyword">file</span>, *tfile;struct eventpoll *ep;struct epitem *epi;struct epoll_event epds;<span class="hljs-keyword">error</span> = -EFAULT;<span class="hljs-comment">//ep_op_has_event中为return op != EPOLL_CTL_DEL;即判断op操作是否为删除监听事件</span><span class="hljs-comment">//从用户拷贝epoll_event数据结构到内核空间</span><span class="hljs-keyword">if</span> (ep_op_has_event(op) &amp;&amp;    copy_from_user(&amp;epds, <span class="hljs-keyword">event</span>, sizeof(struct epoll_event)))goto error_return;<span class="hljs-comment">/* Get the "struct file *" for the eventpoll file */</span><span class="hljs-keyword">error</span> = -EBADF;<span class="hljs-comment">//获取epollfd所对应的匿名文件struct file数据结构</span><span class="hljs-keyword">file</span> = fget(epfd);<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">file</span>)goto error_return;<span class="hljs-comment">/* Get the "struct file *" for the target file */</span><span class="hljs-comment">//获取所要操作的文件描述符所对应的struct file数据结构</span>tfile = fget(fd);<span class="hljs-keyword">if</span> (!tfile)goto error_fput;<span class="hljs-comment">/* The target file descriptor must support poll */</span><span class="hljs-keyword">error</span> = -EPERM;<span class="hljs-comment">//判断所要监听的事件是否支持文件操作或poll操作</span><span class="hljs-keyword">if</span> (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll)goto error_tgt_fput;<span class="hljs-comment">/*</span><span class="hljs-comment"> * We have to check that the file structure underneath the file descriptor</span><span class="hljs-comment"> * the user passed to us _is_ an eventpoll file. And also we do not permit</span><span class="hljs-comment"> * adding an epoll file descriptor inside itself.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">error</span> = -EINVAL;<span class="hljs-comment">//判断所要监听的事件是否是epollfd本身、判断所要监听的事件是否支持epoll对文件的三种操作</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">file</span> == tfile || !is_file_epoll(<span class="hljs-keyword">file</span>))goto error_tgt_fput;<span class="hljs-comment">/*</span><span class="hljs-comment"> * At this point it is safe to assume that the "private_data" contains</span><span class="hljs-comment"> * our own data structure.</span><span class="hljs-comment"> */</span><span class="hljs-comment">//从struct file数据结构中获取eventpoll数据结构</span>ep = <span class="hljs-keyword">file</span>-&gt;private_data;<span class="hljs-comment">/*</span><span class="hljs-comment"> * When we insert an epoll file descriptor, inside another epoll file</span><span class="hljs-comment"> * descriptor, there is the change of creating closed loops, which are</span><span class="hljs-comment"> * better be handled here, than in more critical paths.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * We hold epmutex across the loop check and the insert in this case, in</span><span class="hljs-comment"> * order to prevent two separate inserts from racing and each doing the</span><span class="hljs-comment"> * insert "at the same time" such that ep_loop_check passes on both</span><span class="hljs-comment"> * before either one does the insert, thereby creating a cycle.</span><span class="hljs-comment"> */</span><span class="hljs-comment">//检查监听的事件是否支持epoll对文件的三种操作且为添加事件</span><span class="hljs-comment">//当我们插入一个epoll文件描述符时，在另一个epoll文件描述符中，创建闭环，这在这里更好地处理，而不是更关键的路径。</span><span class="hljs-comment">//在这种情况下，我们保留epmutex的循环检查和插入，以防止两个单独的插入，并且每个插入“同时进行”，使得ep_loop_check在两个插入之前都通过，从而创建一个周期。</span><span class="hljs-keyword">if</span> (unlikely(is_file_epoll(tfile) &amp;&amp; op == EPOLL_CTL_ADD)) &#123;mutex_lock(&amp;epmutex);did_lock_epmutex = <span class="hljs-number">1</span>;<span class="hljs-keyword">error</span> = -ELOOP;<span class="hljs-keyword">if</span> (ep_loop_check(ep, tfile) != <span class="hljs-number">0</span>)goto error_tgt_fput;&#125;mutex_lock_nested(&amp;ep-&gt;mtx, <span class="hljs-number">0</span>);<span class="hljs-comment">/*</span><span class="hljs-comment"> * Try to lookup the file inside our RB tree, Since we grabbed "mtx"</span><span class="hljs-comment"> * above, we can be sure to be able to use the item looked up by</span><span class="hljs-comment"> * ep_find() till we release the mutex.</span><span class="hljs-comment"> */</span><span class="hljs-comment">//epoll不允许重复添加fd</span><span class="hljs-comment">//在eventpoll数据结构中的rbr红黑树里，根据监听事件的struct和fd，与每一个epitem中的epoll_filefd数据结构进行比较</span><span class="hljs-comment">//找到返回监听事件对应的epitem，没有找到返回NULL</span>epi = ep_find(ep, tfile, fd);<span class="hljs-keyword">error</span> = -EINVAL;<span class="hljs-comment">//根据对事件的操作进行分类操作</span><span class="hljs-keyword">switch</span> (op) &#123;<span class="hljs-comment">//添加新的监听事件</span><span class="hljs-keyword">case</span> EPOLL_CTL_ADD:<span class="hljs-comment">//如果之前不存在此事件才可以添加</span><span class="hljs-keyword">if</span> (!epi) &#123;<span class="hljs-comment">//添加内核关心的事件类型POLLERR和POLLHUP</span>epds.events |= POLLERR | POLLHUP;<span class="hljs-comment">//真正的添加新的监听事件</span><span class="hljs-comment">//ep_insert定义在下面</span><span class="hljs-keyword">error</span> = ep_insert(ep, &amp;epds, tfile, fd);&#125; <span class="hljs-keyword">else</span><span class="hljs-keyword">error</span> = -EEXIST;<span class="hljs-keyword">break</span>;<span class="hljs-comment">//删除事件</span><span class="hljs-keyword">case</span> EPOLL_CTL_DEL:<span class="hljs-comment">//如果存在此事件才可以删除</span><span class="hljs-keyword">if</span> (epi)<span class="hljs-comment">//ep_remove就不剖了。。</span><span class="hljs-keyword">error</span> = ep_remove(ep, epi);<span class="hljs-keyword">else</span><span class="hljs-keyword">error</span> = -ENOENT;<span class="hljs-keyword">break</span>;<span class="hljs-comment">//修改事件</span><span class="hljs-keyword">case</span> EPOLL_CTL_MOD:<span class="hljs-keyword">if</span> (epi) &#123;epds.events |= POLLERR | POLLHUP;<span class="hljs-comment">//ep_modify就不剖了。。。</span><span class="hljs-keyword">error</span> = ep_modify(ep, epi, &amp;epds);&#125; <span class="hljs-keyword">else</span><span class="hljs-keyword">error</span> = -ENOENT;<span class="hljs-keyword">break</span>;&#125;mutex_unlock(&amp;ep-&gt;mtx);error_tgt_fput:<span class="hljs-keyword">if</span> (unlikely(did_lock_epmutex))mutex_unlock(&amp;epmutex);fput(tfile);error_fput:fput(<span class="hljs-keyword">file</span>);error_return:<span class="hljs-keyword">return</span> <span class="hljs-keyword">error</span>;&#125;</code></pre><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_struct</span> &#123;</span><span class="hljs-comment">//poll_queue_proc就是当监听事件就绪时，对事件进行具体操作的回调函数</span>poll_queue_proc qproc;<span class="hljs-comment">//key记录对监听事件的何种event感兴趣</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> key;&#125; poll_table;</code></pre><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ep_pqueue</span> &#123;</span><span class="hljs-comment">//poll_table数据结构和poll回调函数机制有关</span><span class="hljs-comment">//poll_table数据结构定义在上面</span>poll_table pt; <span class="hljs-comment">//记录对应的epitem数据结构</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span>;</span>&#125;;</code></pre><pre><code class="hljs reasonml">static inline void init<span class="hljs-constructor">_poll_funcptr(<span class="hljs-params">poll_table</span> <span class="hljs-operator">*</span><span class="hljs-params">pt</span>, <span class="hljs-params">poll_queue_proc</span> <span class="hljs-params">qproc</span>)</span>&#123;<span class="hljs-comment">//初始化poll机制的回调函数</span>pt-&gt;qproc = qproc;<span class="hljs-comment">//初始化感兴趣的事件类型，初值为对所有event都感兴趣</span>pt-&gt;key   = ~<span class="hljs-number">0</span>UL; <span class="hljs-comment">/* all events enabled */</span>&#125;</code></pre><pre><code class="hljs xl"><span class="hljs-comment">//ep参数为epollfd所对应的eventpoll数据结构</span><span class="hljs-comment">//event参数为新监听事件的epoll事件类型，即epoll_event数据结构</span><span class="hljs-comment">//tfile参数为新监听事件所对应的struct file数据结构</span><span class="hljs-comment">//fd参数为新监听事件的文件描述符</span>static int ep_insert(struct eventpoll *ep, struct epoll_event *event,     struct file *tfile, int fd)&#123;int error, revents, pwake = <span class="hljs-number">0</span>;unsigned long flags;long user_watches;struct epitem *epi;struct ep_pqueue epq;<span class="hljs-comment">//将当前用户的监听事件数加1</span><span class="hljs-function"><span class="hljs-title">user_watches</span> = atomic_long_read(&amp;ep-&gt;</span><span class="hljs-function"><span class="hljs-title">user</span>-&gt;</span>epoll_watches);<span class="hljs-comment">//判断是否超过当前用户的最大监听数</span><span class="hljs-keyword">if</span> (unlikely(user_watches &gt;= max_user_watches))return -ENOSPC;<span class="hljs-comment">//从slab中分配一个epitem数据结构</span><span class="hljs-keyword">if</span> (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))return -ENOMEM;<span class="hljs-comment">/* Item initialization follow here ... */</span><span class="hljs-comment">//初始化各个链表</span>INIT_LIST_HEAD(&amp;<span class="hljs-function"><span class="hljs-title">epi</span>-&gt;</span>rdllink);INIT_LIST_HEAD(&amp;<span class="hljs-function"><span class="hljs-title">epi</span>-&gt;</span>fllink);INIT_LIST_HEAD(&amp;<span class="hljs-function"><span class="hljs-title">epi</span>-&gt;</span>pwqlist);<span class="hljs-comment">//记录epitem所对应的eventpoll数据结构</span><span class="hljs-function"><span class="hljs-title">epi</span>-&gt;</span>ep = ep;<span class="hljs-comment">//在epitem中的epoll_filefd数据结构中记录新监听事件所对应的struct file数据结构和文件描述符fd</span><span class="hljs-function"><span class="hljs-title">ep_set_ffd</span>(&amp;epi-&gt;</span>ffd, tfile, fd);<span class="hljs-comment">//记录新监听事件，想要监听的事件类型</span><span class="hljs-function"><span class="hljs-title">epi</span>-&gt;</span>event = *event;<span class="hljs-comment">//poll操作上的等待队列个数初始化为0</span><span class="hljs-function"><span class="hljs-title">epi</span>-&gt;</span>nwait = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化epitem在eventpoll中的ovflist链表的后继为(void *) -1L</span><span class="hljs-function"><span class="hljs-title">epi</span>-&gt;</span>next = EP_UNACTIVE_PTR;<span class="hljs-comment">/* Initialize the poll table using the queue callback */</span><span class="hljs-comment">//记录ep_pqueue中的epitem数据结构</span><span class="hljs-comment">//epq数据类型为ep_pqueue，ep_pqueue数据结构定义在上面</span>epq.epi = epi;<span class="hljs-comment">//初始化poll_table数据结构</span><span class="hljs-comment">//init_poll_funcptr定义在上面</span>init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);<span class="hljs-comment">/*</span><span class="hljs-comment"> * Attach the item to the poll hooks and get current event bits.</span><span class="hljs-comment"> * We can safely use the file* here because its usage count has</span><span class="hljs-comment"> * been increased by the caller of this function. Note that after</span><span class="hljs-comment"> * this operation completes, the poll callback can start hitting</span><span class="hljs-comment"> * the new item.</span><span class="hljs-comment"> */</span><span class="hljs-comment">//对监听事件所对应的struct file中的file operation中的poll操作进行初始化，即对poll回调函数进行初始化，详细的poll机制回调函数在之前已经做了详细说明</span><span class="hljs-comment">//返回值为已经就绪的事件</span><span class="hljs-function"><span class="hljs-title">revents</span> = tfile-&gt;</span><span class="hljs-function"><span class="hljs-title">f_op</span>-&gt;</span>poll(tfile, &amp;epq.pt);<span class="hljs-comment">/*</span><span class="hljs-comment"> * We have to check if something went wrong during the poll wait queue</span><span class="hljs-comment"> * install process. Namely an allocation for a wait queue failed due</span><span class="hljs-comment"> * high memory pressure.</span><span class="hljs-comment"> */</span>error = -ENOMEM;<span class="hljs-comment">//如果内存不够，有可能导致等待队列分配失败，所以此时需要判断等待队列是否存在</span><span class="hljs-function"><span class="hljs-title">if</span> (epi-&gt;</span>nwait &lt; <span class="hljs-number">0</span>)goto error_unregister;<span class="hljs-comment">/* Add the current item to the list of active epoll hook for this file */</span><span class="hljs-function"><span class="hljs-title">spin_lock</span>(&amp;tfile-&gt;</span>f_lock);<span class="hljs-comment">//将epitem链入监听事件所对应的strcut file中的f_ep_links成员上</span><span class="hljs-function"><span class="hljs-title">list_add_tail</span>(&amp;epi-&gt;</span><span class="hljs-function"><span class="hljs-title">fllink</span>, &amp;tfile-&gt;</span>f_ep_links);<span class="hljs-function"><span class="hljs-title">spin_unlock</span>(&amp;tfile-&gt;</span>f_lock);<span class="hljs-comment">/*</span><span class="hljs-comment"> * Add the current item to the RB tree. All RB tree operations are</span><span class="hljs-comment"> * protected by "mtx", and ep_insert() is called with "mtx" held.</span><span class="hljs-comment"> */</span><span class="hljs-comment">//将epitem插入到epollfd所对应的eventpolld中的rbr红黑树中</span>ep_rbtree_insert(ep, epi);<span class="hljs-comment">/* We have to drop the new item inside our item list to keep track of it */</span><span class="hljs-function"><span class="hljs-title">spin_lock_irqsave</span>(&amp;ep-&gt;</span>lock, flags);<span class="hljs-comment">/* If the file is already "ready" we drop it inside the ready list */</span><span class="hljs-comment">//此时判断一下是不是新的监听事件已经就绪且就绪链表为空</span><span class="hljs-function"><span class="hljs-title">if</span> ((revents &amp; event-&gt;</span><span class="hljs-function"><span class="hljs-title">events</span>) &amp;&amp; !ep_is_linked(&amp;epi-&gt;</span>rdllink)) &#123;<span class="hljs-comment">//将epitem链入就绪链表中</span><span class="hljs-function"><span class="hljs-title">list_add_tail</span>(&amp;epi-&gt;</span><span class="hljs-function"><span class="hljs-title">rdllink</span>, &amp;ep-&gt;</span>rdllist);<span class="hljs-comment">/* Notify waiting tasks that events are available */</span><span class="hljs-comment">//判断eventpoll中的wq等待队列是否为NULL，如果不为空，就唤醒等待队列上对应的进程</span><span class="hljs-function"><span class="hljs-title">if</span> (waitqueue_active(&amp;ep-&gt;</span>wq))<span class="hljs-function"><span class="hljs-title">wake_up_locked</span>(&amp;ep-&gt;</span>wq);<span class="hljs-comment">//判断poll_wait等待队列是否为NULL，如果不为NULL，pwake加1</span><span class="hljs-function"><span class="hljs-title">if</span> (waitqueue_active(&amp;ep-&gt;</span>poll_wait))pwake++;&#125;<span class="hljs-function"><span class="hljs-title">spin_unlock_irqrestore</span>(&amp;ep-&gt;</span>lock, flags);<span class="hljs-function"><span class="hljs-title">atomic_long_inc</span>(&amp;ep-&gt;</span><span class="hljs-function"><span class="hljs-title">user</span>-&gt;</span>epoll_watches);<span class="hljs-comment">/* We have to call this outside the lock */</span><span class="hljs-keyword">if</span> (pwake)<span class="hljs-function"><span class="hljs-title">ep_poll_safewake</span>(&amp;ep-&gt;</span>poll_wait);return <span class="hljs-number">0</span>;error_unregister:ep_unregister_pollwait(ep, epi);<span class="hljs-comment">/*</span><span class="hljs-comment"> * We need to do this because an event could have been arrived on some</span><span class="hljs-comment"> * allocated wait queue. Note that we don't care about the ep-&gt;ovflist</span><span class="hljs-comment"> * list, since that is used/cleaned only inside a section bound by "mtx".</span><span class="hljs-comment"> * And ep_insert() is called with "mtx" held.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-title">spin_lock_irqsave</span>(&amp;ep-&gt;</span>lock, flags);<span class="hljs-function"><span class="hljs-title">if</span> (ep_is_linked(&amp;epi-&gt;</span>rdllink))<span class="hljs-function"><span class="hljs-title">list_del_init</span>(&amp;epi-&gt;</span>rdllink);<span class="hljs-function"><span class="hljs-title">spin_unlock_irqrestore</span>(&amp;ep-&gt;</span>lock, flags);kmem_cache_free(epi_cache, epi);return error;&#125;</code></pre><ul><li><strong>epoll_wait</strong></li></ul><pre><code class="hljs mel"><span class="hljs-comment">//参数epfd就是epollfd</span><span class="hljs-comment">//参数events指向一个数组，用来存放最后返回的就绪事件</span><span class="hljs-comment">//参数maxevents表示最多监听多少个事件</span><span class="hljs-comment">//参数timeout表示阻塞时间</span>SYSCALL_DEFINE4(epoll_wait, <span class="hljs-keyword">int</span>, epfd, struct epoll_event __user *, events,<span class="hljs-keyword">int</span>, maxevents, <span class="hljs-keyword">int</span>, timeout)&#123;<span class="hljs-keyword">int</span> <span class="hljs-keyword">error</span>;struct <span class="hljs-keyword">file</span> *<span class="hljs-keyword">file</span>;struct eventpoll *ep;<span class="hljs-comment">/* The maximum number of event must be greater than zero */</span><span class="hljs-comment">//判断maxevents是否合法</span><span class="hljs-keyword">if</span> (maxevents &lt;= <span class="hljs-number">0</span> || maxevents &gt; EP_MAX_EVENTS)<span class="hljs-keyword">return</span> -EINVAL;<span class="hljs-comment">/* Verify that the area passed by the user is writeable */</span><span class="hljs-comment">//判断用户传入的events指向的空间是否合法有效</span><span class="hljs-keyword">if</span> (!access_ok(VERIFY_WRITE, events, maxevents * sizeof(struct epoll_event))) &#123;<span class="hljs-keyword">error</span> = -EFAULT;goto error_return;&#125;<span class="hljs-comment">/* Get the "struct file *" for the eventpoll file */</span><span class="hljs-keyword">error</span> = -EBADF;<span class="hljs-comment">//通过epollfd获得其所对应的struct file数据结构</span><span class="hljs-keyword">file</span> = fget(epfd);<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">file</span>)goto error_return;<span class="hljs-comment">/*</span><span class="hljs-comment"> * We have to check that the file structure underneath the fd</span><span class="hljs-comment"> * the user passed to us _is_ an eventpoll file.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">error</span> = -EINVAL;<span class="hljs-comment">//判断file文件是否支持epoll对文件的操作</span><span class="hljs-keyword">if</span> (!is_file_epoll(<span class="hljs-keyword">file</span>))goto error_fput;<span class="hljs-comment">/*</span><span class="hljs-comment"> * At this point it is safe to assume that the "private_data" contains</span><span class="hljs-comment"> * our own data structure.</span><span class="hljs-comment"> */</span><span class="hljs-comment">//struct file中的private_data成员存储着epollfd对应的eventpoll数据结构</span>ep = <span class="hljs-keyword">file</span>-&gt;private_data;<span class="hljs-comment">/* Time to fish for events ... */</span><span class="hljs-comment">//ep_poll的定义在下面</span><span class="hljs-keyword">error</span> = ep_poll(ep, events, maxevents, timeout);error_fput:fput(<span class="hljs-keyword">file</span>);error_return:<span class="hljs-keyword">return</span> <span class="hljs-keyword">error</span>;&#125;</code></pre><pre><code class="hljs cs"><span class="hljs-comment">//参数ep为epollfd所对应的eventpoll数据结构</span><span class="hljs-comment">//其余参数与epoll_wait参数含义相同</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ep_poll</span>(<span class="hljs-params"><span class="hljs-keyword">struct</span> eventpoll *ep, <span class="hljs-keyword">struct</span> epoll_event __user *events,</span></span><span class="hljs-function"><span class="hljs-params">   <span class="hljs-keyword">int</span> maxevents, <span class="hljs-keyword">long</span> timeout</span>)</span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, eavail, timed_out = <span class="hljs-number">0</span>;unsigned <span class="hljs-keyword">long</span> flags;<span class="hljs-keyword">long</span> slack = <span class="hljs-number">0</span>;<span class="hljs-comment">//存放当前进程的等待队列</span>wait_queue_t wait;ktime_t expires, *to = NULL;<span class="hljs-comment">//如果阻塞时间大于0，就将timeout转化为计算机内部的时间</span><span class="hljs-keyword">if</span> (timeout &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">struct</span> timespec end_time = ep_set_mstimeout(timeout);slack = select_estimate_accuracy(&amp;end_time);to = &amp;expires;*to = timespec_to_ktime(end_time);&#125;<span class="hljs-comment">//如果阻塞时间等于0，即非阻塞模式就直接调转到check_events执行</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timeout == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Avoid the unnecessary trip to the wait queue loop, if the</span><span class="hljs-comment"> * caller specified a non blocking operation.</span><span class="hljs-comment"> */</span>timed_out = <span class="hljs-number">1</span>;spin_lock_irqsave(&amp;ep-&gt;<span class="hljs-keyword">lock</span>, flags);<span class="hljs-keyword">goto</span> check_events;&#125;fetch_events:spin_lock_irqsave(&amp;ep-&gt;<span class="hljs-keyword">lock</span>, flags);<span class="hljs-comment">//如果eventpoll中的rdllist为空或者ovflist为初始化值EP_UNACTIVE_PTR时，满足条件</span><span class="hljs-keyword">if</span> (!ep_events_available(ep)) &#123;<span class="hljs-comment">/*</span><span class="hljs-comment"> * We don't have any available event to return to the caller.</span><span class="hljs-comment"> * We need to sleep here, and we will be wake up by</span><span class="hljs-comment"> * ep_poll_callback() when events will become available.</span><span class="hljs-comment"> */</span><span class="hljs-comment">//初始化等待队列wait，参数current是一个宏，代表当前进程</span><span class="hljs-comment">//init_waitqueue_entry定义在下面</span>init_waitqueue_entry(&amp;wait, current);<span class="hljs-comment">//将等待队列wait添加到eventpoll中的wq等待队列中</span>__add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);<span class="hljs-keyword">for</span> (;;) &#123;<span class="hljs-comment">/*</span><span class="hljs-comment"> * We don't want to sleep if the ep_poll_callback() sends us</span><span class="hljs-comment"> * a wakeup in between. That's why we set the task state</span><span class="hljs-comment"> * to TASK_INTERRUPTIBLE before doing the checks.</span><span class="hljs-comment"> */</span><span class="hljs-comment">//将当前进程调度后的状态设置为浅睡眠，即可中断睡眠状态</span>set_current_state(TASK_INTERRUPTIBLE);<span class="hljs-comment">//如果此时eventpoll中的rdllist就绪链表不为NULL或ovflist不为EP_UNACTIVE_PTR或timed_out为0，那么就不再调度了，直接break跳出循环</span><span class="hljs-keyword">if</span> (ep_events_available(ep) || timed_out)<span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果此时收到了信号，那么也不再调度了，直接break跳出循环</span><span class="hljs-keyword">if</span> (signal_pending(current)) &#123;res = -EINTR;<span class="hljs-keyword">break</span>;&#125;spin_unlock_irqrestore(&amp;ep-&gt;<span class="hljs-keyword">lock</span>, flags);<span class="hljs-comment">//当前进程被调度，进入前睡眠状态</span><span class="hljs-comment">//在此期间，若发生事件就绪或收到信号，就执行poll回调机制</span><span class="hljs-keyword">if</span> (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS))timed_out = <span class="hljs-number">1</span>;spin_lock_irqsave(&amp;ep-&gt;<span class="hljs-keyword">lock</span>, flags);&#125;<span class="hljs-comment">//此时已从for循环中跳出</span><span class="hljs-comment">//从eventpoll中的wq等待队列里删除wait等待队列</span>__remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);<span class="hljs-comment">//设置当前进程下一次调度的状态为运行中状态</span>set_current_state(TASK_RUNNING);&#125;check_events:<span class="hljs-comment">/* Is it worth to try to dig for events ? */</span><span class="hljs-comment">//判断此时eventpoll中的rdllist是否为空或者ovflist为初始化值是否为EP_UNACTIVE_PTR</span>eavail = ep_events_available(ep);spin_unlock_irqrestore(&amp;ep-&gt;<span class="hljs-keyword">lock</span>, flags);<span class="hljs-comment">/*</span><span class="hljs-comment"> * Try to transfer events to user space. In case we get 0 events and</span><span class="hljs-comment"> * there's still timeout left over, we go trying again in search of</span><span class="hljs-comment"> * more luck.</span><span class="hljs-comment"> */</span><span class="hljs-comment">//此时尝试将就绪事件传输到用户空间</span><span class="hljs-comment">//如果我们得到0个就绪事件，还有超时时间，就跳转至fetch_events</span><span class="hljs-comment">//ep_send_events定义在下面</span><span class="hljs-keyword">if</span> (!res &amp;&amp; eavail &amp;&amp;    !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; !timed_out)<span class="hljs-keyword">goto</span> fetch_events;<span class="hljs-keyword">return</span> res;&#125;</code></pre><pre><code class="hljs reasonml">static inline void init<span class="hljs-constructor">_waitqueue_entry(<span class="hljs-params">wait_queue_t</span> <span class="hljs-operator">*</span><span class="hljs-params">q</span>, <span class="hljs-params">struct</span> <span class="hljs-params">task_struct</span> <span class="hljs-operator">*</span><span class="hljs-params">p</span>)</span>&#123;q-&gt;flags = <span class="hljs-number">0</span>; <span class="hljs-comment">//将等待队列状态初始化为0</span>q-&gt;<span class="hljs-keyword">private</span> = p; <span class="hljs-comment">//将等待队列的成员private指针初始化为p，即当前进程</span>q-&gt;func = default_wake_function; <span class="hljs-comment">//将等待队列的成员func初始化为default_wake_function，即唤醒进程时的函数</span>&#125;</code></pre><pre><code class="hljs cs"><span class="hljs-comment">//参数含义与ep_poll函数参数相同，不再赘述</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ep_send_events</span>(<span class="hljs-params"><span class="hljs-keyword">struct</span> eventpoll *ep,</span></span><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">struct</span> epoll_event __user *events, <span class="hljs-keyword">int</span> maxevents</span>)</span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//初始化ep_send_events_data数据结构，这个数据结构就只包含maxevents和events</span><span class="hljs-keyword">struct</span> ep_send_events_data esed;esed.maxevents = maxevents;esed.events = events;<span class="hljs-comment">//ep_scan_ready_list定义在下面</span><span class="hljs-keyword">return</span> ep_scan_ready_list(ep, ep_send_events_proc, &amp;esed, <span class="hljs-number">0</span>);&#125;</code></pre><pre><code class="hljs xl"><span class="hljs-comment">//参数ep为epollfd所对应的eventpoll</span><span class="hljs-comment">//参数sproc为函数指针，调用时赋值为ep_send_events_proc</span><span class="hljs-comment">//参数priv指向ep_send_events_data数据结构</span><span class="hljs-comment">//参数depth初始化为0</span>static int ep_scan_ready_list(struct eventpoll *ep,      int (*sproc)(struct eventpoll *,   struct list_head *, void *),      void *priv,      int depth)&#123;int error, pwake = <span class="hljs-number">0</span>;unsigned long flags;struct epitem *epi, *nepi;LIST_HEAD(txlist);<span class="hljs-comment">/*</span><span class="hljs-comment"> * We need to lock this because we could be hit by</span><span class="hljs-comment"> * eventpoll_release_file() and epoll_ctl().</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-title">mutex_lock_nested</span>(&amp;ep-&gt;</span>mtx, depth);<span class="hljs-comment">/*</span><span class="hljs-comment"> * Steal the ready list, and re-init the original one to the</span><span class="hljs-comment"> * empty list. Also, set ep-&gt;ovflist to NULL so that events</span><span class="hljs-comment"> * happening while looping w/out locks, are not lost. We cannot</span><span class="hljs-comment"> * have the poll callback to queue directly on ep-&gt;rdllist,</span><span class="hljs-comment"> * because we want the "sproc" callback to be able to do it</span><span class="hljs-comment"> * in a lockless way.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-title">spin_lock_irqsave</span>(&amp;ep-&gt;</span>lock, flags);<span class="hljs-comment">//此时所有发生就绪事件的epitem都已经链入了eventpoll中的rdllist就绪链表了</span><span class="hljs-comment">//此时将rdllist就绪链表上的所有元素都转移到txlist中，而rdllist被清空</span><span class="hljs-function"><span class="hljs-title">list_splice_init</span>(&amp;ep-&gt;</span>rdllist, &amp;txlist);<span class="hljs-comment">//将ovlist置NULL，是因为此时不希望再有新的就绪事件对应的epitem加入到rdllist中</span><span class="hljs-function"><span class="hljs-title">ep</span>-&gt;</span>ovflist = NULL;<span class="hljs-function"><span class="hljs-title">spin_unlock_irqrestore</span>(&amp;ep-&gt;</span>lock, flags);<span class="hljs-comment">/*</span><span class="hljs-comment"> * Now call the callback function.</span><span class="hljs-comment"> */</span><span class="hljs-comment">//此时调用参数传入的回调函数，即ep_send_events_proc</span><span class="hljs-comment">//ep_send_events_proc定义在下面</span>error = (*sproc)(ep, &amp;txlist, priv);<span class="hljs-function"><span class="hljs-title">spin_lock_irqsave</span>(&amp;ep-&gt;</span>lock, flags);<span class="hljs-comment">/*</span><span class="hljs-comment"> * During the time we spent inside the "sproc" callback, some</span><span class="hljs-comment"> * other events might have been queued by the poll callback.</span><span class="hljs-comment"> * We re-insert them inside the main ready-list here.</span><span class="hljs-comment"> */</span><span class="hljs-comment">//当调用ep_send_events_proc函数时，即向用户空间传递数据时</span><span class="hljs-comment">//发生了就绪事件，这些就绪事件对应的epitem都链入了eventpoll中的ovflist</span><span class="hljs-comment">//现在遍历ovflist链表，依次处理这些epitem</span><span class="hljs-function"><span class="hljs-title">for</span> (nepi = ep-&gt;</span>ovflist; (epi = nepi) != NULL;     <span class="hljs-function"><span class="hljs-title">nepi</span> = epi-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>, epi-&gt;</span>next = EP_UNACTIVE_PTR) &#123;<span class="hljs-comment">/*</span><span class="hljs-comment"> * We need to check if the item is already in the list.</span><span class="hljs-comment"> * During the "sproc" callback execution time, items are</span><span class="hljs-comment"> * queued into -&gt;ovflist but the "txlist" might already</span><span class="hljs-comment"> * contain them, and the list_splice() below takes care of them.</span><span class="hljs-comment"> */</span><span class="hljs-comment">//如果epitem存在，就将epitem尾插进rddlist中</span><span class="hljs-function"><span class="hljs-title">if</span> (!ep_is_linked(&amp;epi-&gt;</span>rdllink))<span class="hljs-function"><span class="hljs-title">list_add_tail</span>(&amp;epi-&gt;</span><span class="hljs-function"><span class="hljs-title">rdllink</span>, &amp;ep-&gt;</span>rdllist);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * We need to set back ep-&gt;ovflist to EP_UNACTIVE_PTR, so that after</span><span class="hljs-comment"> * releasing the lock, events will be queued in the normal way inside</span><span class="hljs-comment"> * ep-&gt;rdllist.</span><span class="hljs-comment"> */</span><span class="hljs-comment">//将ovflist置为EP_UNACTIVE_PTR，即((void *) -1L)</span><span class="hljs-function"><span class="hljs-title">ep</span>-&gt;</span>ovflist = EP_UNACTIVE_PTR;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Quickly re-inject items left on "txlist".</span><span class="hljs-comment"> */</span><span class="hljs-comment">//经过ep_send_events_proc对epitem的处理后，有的epitem还未被处理完，将这些epitem重新链入rdllist中</span><span class="hljs-function"><span class="hljs-title">list_splice</span>(&amp;txlist, &amp;ep-&gt;</span>rdllist);<span class="hljs-comment">//如果rdllist就绪链表不为NULL时</span><span class="hljs-function"><span class="hljs-title">if</span> (!list_empty(&amp;ep-&gt;</span>rdllist)) &#123;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Wake up (if active) both the eventpoll wait list and</span><span class="hljs-comment"> * the -&gt;poll() wait list (delayed after we release the lock).</span><span class="hljs-comment"> */</span><span class="hljs-comment">//当wq等待队列wq不为NULL时</span><span class="hljs-function"><span class="hljs-title">if</span> (waitqueue_active(&amp;ep-&gt;</span>wq))<span class="hljs-comment">//唤醒等待队列wq上的成员，及当前进程</span><span class="hljs-function"><span class="hljs-title">wake_up_locked</span>(&amp;ep-&gt;</span>wq);<span class="hljs-function"><span class="hljs-title">if</span> (waitqueue_active(&amp;ep-&gt;</span>poll_wait))pwake++;&#125;<span class="hljs-function"><span class="hljs-title">spin_unlock_irqrestore</span>(&amp;ep-&gt;</span>lock, flags);<span class="hljs-function"><span class="hljs-title">mutex_unlock</span>(&amp;ep-&gt;</span>mtx);<span class="hljs-comment">/* We have to call this outside the lock */</span><span class="hljs-keyword">if</span> (pwake)<span class="hljs-function"><span class="hljs-title">ep_poll_safewake</span>(&amp;ep-&gt;</span>poll_wait);return error;&#125;</code></pre><pre><code class="hljs xl"><span class="hljs-comment">//参数ep为epollfd所对应的eventpoll</span><span class="hljs-comment">//参数head为txlist</span><span class="hljs-comment">//参数priv为ep_send_events_data数据结构</span>static int ep_send_events_proc(struct eventpoll *ep, struct list_head *head,       void *priv)&#123;struct ep_send_events_data *esed = priv;int eventcnt;unsigned int revents;struct epitem *epi;struct epoll_event __user *uevent;<span class="hljs-comment">/*</span><span class="hljs-comment"> * We can loop without lock because we are passed a task private list.</span><span class="hljs-comment"> * Items cannot vanish during the loop because ep_scan_ready_list() is</span><span class="hljs-comment"> * holding "mtx" during this call.</span><span class="hljs-comment"> */</span><span class="hljs-comment">//遍历整个txlist链表</span><span class="hljs-function"><span class="hljs-title">for</span> (eventcnt = 0, uevent = esed-&gt;</span>events;     !<span class="hljs-function"><span class="hljs-title">list_empty</span>(head) &amp;&amp; eventcnt &lt; esed-&gt;</span>maxevents;) &#123;    <span class="hljs-comment">//获取txlist链表中的第一个节点</span>epi = list_first_entry(head, struct epitem, rdllink);<span class="hljs-comment">//从txlink链表中将epitem删除</span><span class="hljs-function"><span class="hljs-title">list_del_init</span>(&amp;epi-&gt;</span>rdllink);<span class="hljs-comment">//获取此时，最新的epitem的就绪事件类型</span><span class="hljs-function"><span class="hljs-title">revents</span> = epi-&gt;</span><span class="hljs-function"><span class="hljs-title">ffd</span>.file-&gt;</span><span class="hljs-function"><span class="hljs-title">f_op</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">poll</span>(epi-&gt;</span>ffd.file, NULL) &amp;<span class="hljs-function"><span class="hljs-title">epi</span>-&gt;</span>event.events;<span class="hljs-comment">/*</span><span class="hljs-comment"> * If the event mask intersect the caller-requested one,</span><span class="hljs-comment"> * deliver the event to userspace. Again, ep_scan_ready_list()</span><span class="hljs-comment"> * is holding "mtx", so no operations coming from userspace</span><span class="hljs-comment"> * can change the item.</span><span class="hljs-comment"> */</span><span class="hljs-comment">//再一次判断是否有就绪事件发生</span><span class="hljs-keyword">if</span> (revents) &#123;<span class="hljs-comment">//将当前的就绪事件拷贝到用户空间中</span><span class="hljs-comment">//如果此时epitem还没有处理完，就将epitem再链入txlist链表中</span><span class="hljs-function"><span class="hljs-title">if</span> (__put_user(revents, &amp;uevent-&gt;</span>events) ||    __<span class="hljs-function"><span class="hljs-title">put_user</span>(epi-&gt;</span><span class="hljs-function"><span class="hljs-title">event</span>.<span class="hljs-keyword">data</span>, &amp;uevent-&gt;</span><span class="hljs-keyword">data</span>)) &#123;<span class="hljs-function"><span class="hljs-title">list_add</span>(&amp;epi-&gt;</span>rdllink, head);return eventcnt ? eventcnt : -EFAULT;&#125;eventcnt++;uevent++;<span class="hljs-function"><span class="hljs-title">if</span> (epi-&gt;</span>event.events &amp; EPOLLONESHOT)<span class="hljs-function"><span class="hljs-title">epi</span>-&gt;</span>event.events &amp;= EP_PRIVATE_BITS;<span class="hljs-comment">//判断fd是否为ET模式，如果不是ET模式，就要将自己再一次链入rdllist就绪链表中，这是LT和ET模式本质区别</span><span class="hljs-comment">//以便下次调用epoll_wait（）会再次检查事件的可用性</span><span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (!(epi-&gt;</span>event.events &amp; EPOLLET)) &#123;<span class="hljs-comment">/*</span><span class="hljs-comment"> * If this file has been added with Level</span><span class="hljs-comment"> * Trigger mode, we need to insert back inside</span><span class="hljs-comment"> * the ready list, so that the next call to</span><span class="hljs-comment"> * epoll_wait() will check again the events</span><span class="hljs-comment"> * availability. At this point, no one can insert</span><span class="hljs-comment"> * into ep-&gt;rdllist besides us. The epoll_ctl()</span><span class="hljs-comment"> * callers are locked out by</span><span class="hljs-comment"> * ep_scan_ready_list() holding "mtx" and the</span><span class="hljs-comment"> * poll callback will queue them in ep-&gt;ovflist.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-title">list_add_tail</span>(&amp;epi-&gt;</span><span class="hljs-function"><span class="hljs-title">rdllink</span>, &amp;ep-&gt;</span>rdllist);&#125;&#125;&#125;return eventcnt;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是POD数据类型？</title>
    <link href="/2020/07/02/POD-data-type/"/>
    <url>/2020/07/02/POD-data-type/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>在之前的vector扩容问题源代码剖析中，发现源码中对数据类型进行了是否为POD类型的检查，这篇就看看什么是POD。。。→_→</em> *</strong></p><p><strong>了解vector扩容问题请戳传送门——</strong><a href="http://blog.csdn.net/kongkongkkk/article/details/77320794" target="_blank" rel="noopener"><strong>vector扩容问题源代码剖析</strong></a></p><p><strong>详细POD定义说明请戳传送门——</strong><a href="http://en.cppreference.com/w/cpp/concept/PODType" target="_blank" rel="noopener"><strong>POD数据类型解释说明</strong></a></p><p><strong>详细is_pod函数定义说明请戳传送门——</strong><a href="http://en.cppreference.com/w/cpp/types/is_pod" target="_blank" rel="noopener"><strong>is_pod函数定义说明</strong></a></p><ul><li><p><strong>POD，是Plain Old Data的缩写，普通旧数据类型</strong>，是C++中的一种数据类型概念</p></li><li><p><strong>POD类型与C编程语言中使用的类型兼容，POD数据类型可以使用C库函数进行操作，也可以使用std::malloc创建，可以使用std::memmove等进行复制，并且可以使用C语言库直接进行二进制形式的数据交换</strong></p></li><li><p>请注意，<strong>C++标准没有使用此名称定义命名的要求或概念</strong>。 这是由核心语言定义的类型类别。它被包括在这里作为概念，只是为了一致性。</p></li><li><p><strong>POD数据类型的要求</strong></p><ul><li><p>a scalar type（标量类型）</p></li><li><p>a class type (class or struct or union) that is（一个类类型（类、结构体或联合体））</p><ul><li><p>在C++11之前</p></li><li><p>an aggregate type（聚合类型）</p></li><li><p>has no non-static members that are non-POD（没有非POD的非静态成员）</p></li><li><p>has no members of reference type（没有参考类型的成员）</p></li><li><p>has no user-defined copy constructor（没有用户定义的拷贝构造函数）</p></li><li><p>has no user-defined destructor（没有用户定义的析构函数）</p></li><li><p>C++11之后</p></li><li><p>a trivial type（破碎的类型）</p></li><li><p>a standard layout type（标准布局类型）</p></li><li><p>has no non-static members that are non-POD（没有非POD的非静态成员）</p></li></ul></li><li><p>an array of such type（POD类型的数组）</p></li></ul></li><li><p><strong>C++中判断数据类型是否为POD的函数：is_pod(C++11)</strong></p>  <pre><code class="hljs cpp"><span class="hljs-comment">//since C++11</span>Defined in header &lt;type_traits&gt;<span class="hljs-keyword">template</span>&lt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> &gt;</span><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">is_pod</span>;</span></code></pre><ul><li><strong>如果T是PODType（“普通旧数据类型”），即简单和标准布局，则将成员常量值设置为true。 对于任何其他类型，值为false</strong></li></ul></li></ul><pre><code class="hljs cpp"><span class="hljs-comment">//输出为：</span><span class="hljs-comment">//true</span><span class="hljs-comment">//false</span><span class="hljs-comment">//false</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;type_traits&gt;</span></span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span>    <span class="hljs-keyword">int</span> m;&#125;; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span> &#123;</span>    <span class="hljs-keyword">int</span> m1;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> m2;&#125;; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">C</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;&#125;; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::boolalpha;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::is_pod&lt;A&gt;::value &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::is_pod&lt;B&gt;::value &lt;&lt; <span class="hljs-string">'\n'</span>;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::is_pod&lt;C&gt;::value &lt;&lt; <span class="hljs-string">'\n'</span>;&#125;</code></pre><p><strong>* <em>其实POD数据类型大概了解一下就行。。。这仅仅是一个概念而已。。。→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vector扩容问题源代码剖析</title>
    <link href="/2020/07/02/vector-expansion/"/>
    <url>/2020/07/02/vector-expansion/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>之前只知道理论。。。今天就来深入剖析一下源代码。。。→_→</em> *</strong></p><p><strong>了解POD数据类型请戳传送门——</strong><a href="http://blog.csdn.net/kongkongkkk/article/details/77414410" target="_blank" rel="noopener"><strong>什么是POD数据类型？</strong></a></p><p>直接从vector的push_back进。。。</p><pre><code class="hljs sqf"> <span class="hljs-comment">//stl\Stl_vector.h</span> <span class="hljs-comment">//尾插</span> void push_back(const <span class="hljs-variable">_Tp</span>&amp; <span class="hljs-variable">__x</span>) &#123;<span class="hljs-comment">//先检查是否还有备用空间</span>   <span class="hljs-keyword">if</span> (<span class="hljs-variable">_M_finish</span> != <span class="hljs-variable">_M_end_of_storage</span>) &#123;     <span class="hljs-comment">//如果有，就直接在备用空间上构造元素</span>     <span class="hljs-comment">//construct定义在下面</span>     construct(<span class="hljs-variable">_M_finish</span>, <span class="hljs-variable">__x</span>);      ++<span class="hljs-variable">_M_finish</span>; <span class="hljs-comment">//调整水位高高度</span>   &#125;   <span class="hljs-keyword">else</span>      <span class="hljs-comment">//此时已没有备用空间</span>     <span class="hljs-comment">//_M_insert_aux定义在下面</span>     <span class="hljs-variable">_M_insert_aux</span>(end(), <span class="hljs-variable">__x</span>); &#125;</code></pre><pre><code class="hljs sqf"><span class="hljs-comment">//stl\Stl_vector.h</span>template &lt;class <span class="hljs-variable">_Tp</span>, class <span class="hljs-variable">_Alloc</span>&gt;void vector&lt;<span class="hljs-variable">_Tp</span>, <span class="hljs-variable">_Alloc</span>&gt;::<span class="hljs-variable">_M_insert_aux</span>(iterator <span class="hljs-variable">__position</span>, const <span class="hljs-variable">_Tp</span>&amp; <span class="hljs-variable">__x</span>)&#123;  <span class="hljs-comment">//如果此时还有备用空间</span>  <span class="hljs-keyword">if</span> (<span class="hljs-variable">_M_finish</span> != <span class="hljs-variable">_M_end_of_storage</span>) &#123;    <span class="hljs-comment">//在备用空间起始处构造一个元素，并以vector最后一个元素值为初始值</span>    construct(<span class="hljs-variable">_M_finish</span>, *(<span class="hljs-variable">_M_finish</span> - <span class="hljs-number">1</span>));    ++<span class="hljs-variable">_M_finish</span>; <span class="hljs-comment">//调整水位</span>    <span class="hljs-variable">_Tp</span> <span class="hljs-variable">__x_copy</span> = <span class="hljs-variable">__x</span>;     copy_backward(<span class="hljs-variable">__position</span>, <span class="hljs-variable">_M_finish</span> - <span class="hljs-number">2</span>, <span class="hljs-variable">_M_finish</span> - <span class="hljs-number">1</span>);    *<span class="hljs-variable">__position</span> = <span class="hljs-variable">__x_copy</span>;  &#125;  <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//此时没有备用空间</span>    <span class="hljs-comment">//计算原vector的大小</span>    const size_type <span class="hljs-variable">__old_size</span> = <span class="hljs-built_in">size</span>();    <span class="hljs-comment">//如果原大小为0，则配置1个元素</span>    <span class="hljs-comment">//如果原大小不为0，则配置原大小的2倍</span>    const size_type <span class="hljs-variable">__len</span> = <span class="hljs-variable">__old_size</span> != <span class="hljs-number">0</span> ? <span class="hljs-number">2</span> * <span class="hljs-variable">__old_size</span> : <span class="hljs-number">1</span>;    iterator <span class="hljs-variable">__new_start</span> = <span class="hljs-variable">_M_allocate</span>(<span class="hljs-variable">__len</span>);    iterator <span class="hljs-variable">__new_finish</span> = <span class="hljs-variable">__new_start</span>;    <span class="hljs-variable">__STL_TRY</span> &#123;      <span class="hljs-comment">//将原vector的内容拷贝到新vector</span>      <span class="hljs-comment">//uninitialized_copy定义在下面</span>      <span class="hljs-variable">__new_finish</span> = uninitialized_copy(<span class="hljs-variable">_M_start</span>, <span class="hljs-variable">__position</span>, <span class="hljs-variable">__new_start</span>);      <span class="hljs-comment">//为新元素设定初始值为x</span>      construct(<span class="hljs-variable">__new_finish</span>, <span class="hljs-variable">__x</span>);      <span class="hljs-comment">//调整水位</span>      ++<span class="hljs-variable">__new_finish</span>;      <span class="hljs-comment">//将原vector的备用空间中的内容也拷贝到新vector中</span>      <span class="hljs-variable">__new_finish</span> = uninitialized_copy(<span class="hljs-variable">__position</span>, <span class="hljs-variable">_M_finish</span>, <span class="hljs-variable">__new_finish</span>);    &#125;    <span class="hljs-variable">__STL_UNWIND</span>((destroy(<span class="hljs-variable">__new_start</span>,<span class="hljs-variable">__new_finish</span>),                   <span class="hljs-variable">_M_deallocate</span>(<span class="hljs-variable">__new_start</span>,<span class="hljs-variable">__len</span>)));    <span class="hljs-comment">//析构并释放原vector</span>    <span class="hljs-comment">//destroy定义在下面</span>    destroy(begin(), end());    <span class="hljs-variable">_M_deallocate</span>(<span class="hljs-variable">_M_start</span>, <span class="hljs-variable">_M_end_of_storage</span> - <span class="hljs-variable">_M_start</span>);    <span class="hljs-comment">//调整迭代器，指向新vector</span>    <span class="hljs-variable">_M_start</span> = <span class="hljs-variable">__new_start</span>;    <span class="hljs-variable">_M_finish</span> = <span class="hljs-variable">__new_finish</span>;    <span class="hljs-variable">_M_end_of_storage</span> = <span class="hljs-variable">__new_start</span> + <span class="hljs-variable">__len</span>;  &#125;&#125;</code></pre><pre><code class="hljs angelscript"><span class="hljs-comment">//stl\Stl_uninitialized.h</span><span class="hljs-comment">//如果推导出的是POD类型，就采用针对POD最有效率的复制方法，即执行以下函数</span><span class="hljs-comment">//__true_type是由函数模板参数的推导机制得到的</span>template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">_InputIter, <span class="hljs-symbol">class</span></span> <span class="hljs-symbol">_ForwardIter</span>&gt;<span class="hljs-symbol">inline</span> <span class="hljs-symbol">_ForwardIter</span> <span class="hljs-symbol">__uninitialized_copy_aux</span>(<span class="hljs-symbol">_InputIter</span> <span class="hljs-symbol">__first, <span class="hljs-symbol">_InputIter</span></span> <span class="hljs-symbol">__last,</span>                         <span class="hljs-symbol">_ForwardIter</span> <span class="hljs-symbol">__result,</span>                         <span class="hljs-symbol">__true_type</span>)&#123;  <span class="hljs-comment">//调用STL的copy()算法，其底层使用memmove()函数，直接按照内存字节进行复制</span>  <span class="hljs-keyword">return</span> copy(__first, __last, __result);&#125;<span class="hljs-comment">//如果是non-POD类型，即执行以下函数</span>template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">_InputIter, <span class="hljs-symbol">class</span></span> <span class="hljs-symbol">_ForwardIter</span>&gt;<span class="hljs-symbol">_ForwardIter</span> <span class="hljs-symbol">__uninitialized_copy_aux</span>(<span class="hljs-symbol">_InputIter</span> <span class="hljs-symbol">__first, <span class="hljs-symbol">_InputIter</span></span> <span class="hljs-symbol">__last,</span>                         <span class="hljs-symbol">_ForwardIter</span> <span class="hljs-symbol">__result,</span>                         <span class="hljs-symbol">__false_type</span>)&#123;  <span class="hljs-comment">//获取输出端的欲初始化的起始处</span>  _ForwardIter __cur = __result;  __STL_TRY &#123;    <span class="hljs-comment">//依次从输出端的欲初始化的起始处开始构造元素</span>    <span class="hljs-keyword">for</span> ( ; __first != __last; ++__first, ++__cur)      <span class="hljs-comment">//一个一个的进行元素构造，而不是像POD一样，直接进行内存字节的复制</span>      <span class="hljs-comment">//_Construct定义在下面</span>      _Construct(&amp;*__cur, *__first);    <span class="hljs-keyword">return</span> __cur;  &#125;  __STL_UNWIND(_Destroy(__result, __cur));&#125;template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">_InputIter, <span class="hljs-symbol">class</span></span> <span class="hljs-symbol">_ForwardIter, <span class="hljs-symbol">class</span></span> <span class="hljs-symbol">_Tp</span>&gt;<span class="hljs-symbol">inline</span> <span class="hljs-symbol">_ForwardIter</span><span class="hljs-symbol">__uninitialized_copy</span>(<span class="hljs-symbol">_InputIter</span> <span class="hljs-symbol">__first, <span class="hljs-symbol">_InputIter</span></span> <span class="hljs-symbol">__last,</span>                     <span class="hljs-symbol">_ForwardIter</span> <span class="hljs-symbol">__result, <span class="hljs-symbol">_Tp</span></span>*)&#123;  <span class="hljs-comment">//萃取出迭代器result的value type</span>  <span class="hljs-comment">//然后判断该value type是否为POD，关于POD会在另一篇文章中详细解释</span>  <span class="hljs-comment">//编译器会将_Is_POD()的结果，作参数推导</span>  <span class="hljs-comment">//__uninitialized_copy_aux定义在上面</span>  <span class="hljs-keyword">typedef</span> typename __type_traits&lt;_Tp&gt;::is_POD_type _Is_POD;  <span class="hljs-keyword">return</span> __uninitialized_copy_aux(__first, __last, __result, _Is_POD());&#125;<span class="hljs-comment">//uninitialized_copy将内存的配置与对象的构造行为分离开来</span><span class="hljs-comment">//C++标准规格书要求uninitialized_copy具有"commit or rollback"语义</span><span class="hljs-comment">//即要么构造出所有必要元素，要么当有任何一个copy construct失败时，就不构造任何东西</span><span class="hljs-comment">//迭代器__first指向输入端的起始位置</span><span class="hljs-comment">//迭代器__last指向输入端的结束位置，前闭后开区间</span><span class="hljs-comment">//迭代器__result指向输出端的起始处，即欲初始化的起始处</span>template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">_InputIter, <span class="hljs-symbol">class</span></span> <span class="hljs-symbol">_ForwardIter</span>&gt;<span class="hljs-symbol">inline</span> <span class="hljs-symbol">_ForwardIter</span>  <span class="hljs-symbol">uninitialized_copy</span>(<span class="hljs-symbol">_InputIter</span> <span class="hljs-symbol">__first, <span class="hljs-symbol">_InputIter</span></span> <span class="hljs-symbol">__last,</span>                     <span class="hljs-symbol">_ForwardIter</span> <span class="hljs-symbol">__result</span>)&#123;  <span class="hljs-comment">//利用__VALUE_TYPE()取出__result的value type</span>  <span class="hljs-comment">//__uninitialized_copy定义在上面</span>  <span class="hljs-keyword">return</span> __uninitialized_copy(__first, __last, __result,                              __VALUE_TYPE(__result));&#125;</code></pre><pre><code class="hljs angelscript"><span class="hljs-comment">//stl\Stl_construct.h</span>template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">_T1, <span class="hljs-symbol">class</span></span> <span class="hljs-symbol">_T2</span>&gt;<span class="hljs-symbol">inline</span> <span class="hljs-symbol">void</span> <span class="hljs-symbol">_Construct</span>(<span class="hljs-symbol">_T1</span>* <span class="hljs-symbol">__p, <span class="hljs-symbol">const</span></span> <span class="hljs-symbol">_T2</span>&amp; <span class="hljs-symbol">__value</span>) &#123;  <span class="hljs-comment">//构造以T1为类型，值为__value的元素</span>  new ((<span class="hljs-built_in">void</span>*) __p) _T1(__value);&#125;</code></pre><pre><code class="hljs angelscript"><span class="hljs-comment">//stl\Stl_construct.h</span>template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">_Tp</span>&gt;<span class="hljs-symbol">inline</span> <span class="hljs-symbol">void</span> <span class="hljs-symbol">destroy</span>(<span class="hljs-symbol">_Tp</span>* <span class="hljs-symbol">__pointer</span>) &#123;  _Destroy(__pointer);&#125;<span class="hljs-comment">//析构并释放元素与内存</span>template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">_ForwardIterator</span>&gt;<span class="hljs-symbol">inline</span> <span class="hljs-symbol">void</span> <span class="hljs-symbol">destroy</span>(<span class="hljs-symbol">_ForwardIterator</span> <span class="hljs-symbol">__first, <span class="hljs-symbol">_ForwardIterator</span></span> <span class="hljs-symbol">__last</span>) &#123;  <span class="hljs-comment">//_Destroy定义在下面</span>  _Destroy(__first, __last);&#125;</code></pre><pre><code class="hljs angelscript"><span class="hljs-comment">//stl\Stl_construct.h</span>template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">_Tp</span>&gt;<span class="hljs-symbol">inline</span> <span class="hljs-symbol">void</span> <span class="hljs-symbol">_Destroy</span>(<span class="hljs-symbol">_Tp</span>* <span class="hljs-symbol">__pointer</span>) &#123;  <span class="hljs-comment">//调用每个迭代器所指数据类型的析构函数</span>  __pointer-&gt;~_Tp();&#125;<span class="hljs-comment">//如果为__false_type，即non-trivial destructor，那么就遍历整个范围，对每一个对象都调用一个参数的destroy()</span>template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">_ForwardIterator</span>&gt;<span class="hljs-symbol">void</span><span class="hljs-symbol">__destroy_aux</span>(<span class="hljs-symbol">_ForwardIterator</span> <span class="hljs-symbol">__first, <span class="hljs-symbol">_ForwardIterator</span></span> <span class="hljs-symbol">__last, <span class="hljs-symbol">__false_type</span></span>)&#123;  <span class="hljs-comment">//遍历整个范围，依次析构每个对象</span>  <span class="hljs-comment">//destroy定义在上面</span>  <span class="hljs-keyword">for</span> ( ; __first != __last; ++__first)    destroy(&amp;*__first);&#125;<span class="hljs-comment">//如果为__true_type，即trivial destructor，那么析构其实什么都不做</span>template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">_ForwardIterator</span>&gt; <span class="hljs-symbol">inline</span> <span class="hljs-symbol">void</span> <span class="hljs-symbol">__destroy_aux</span>(<span class="hljs-symbol">_ForwardIterator, <span class="hljs-symbol">_ForwardIterator</span>, <span class="hljs-symbol">__true_type</span></span>) &#123;&#125;template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">_ForwardIterator, <span class="hljs-symbol">class</span></span> <span class="hljs-symbol">_Tp</span>&gt;<span class="hljs-symbol">inline</span> <span class="hljs-symbol">void</span> <span class="hljs-symbol">__destroy</span>(<span class="hljs-symbol">_ForwardIterator</span> <span class="hljs-symbol">__first, <span class="hljs-symbol">_ForwardIterator</span></span> <span class="hljs-symbol">__last, <span class="hljs-symbol">_Tp</span></span>*)&#123;  <span class="hljs-comment">//判断元素的数值类型value type是否有trivial destructor</span>  <span class="hljs-comment">//准备将[first, last)范围内的所有对象析构，但不知道这个范围有多大</span>  <span class="hljs-comment">//如果很大的话，而每一个对象的析构函数都是trivial destructor，那么每一次调用都是对效率的伤害</span>  <span class="hljs-comment">//所以使用了value_type()获取了迭代器所指对象的类型</span>  <span class="hljs-comment">//再利用__type_traits&lt;_Tp&gt;判断该类型的析构函数是否为trivial destructor</span>  <span class="hljs-comment">//根据__type_traits&lt;_Tp&gt;选择最合适的析构方法</span>  <span class="hljs-keyword">typedef</span> typename __type_traits&lt;_Tp&gt;::has_trivial_destructor          _Trivial_destructor;  <span class="hljs-comment">//__destroy_aux定义在上面</span>  __destroy_aux(__first, __last, _Trivial_destructor());&#125;template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">_ForwardIterator</span>&gt;<span class="hljs-symbol">inline</span> <span class="hljs-symbol">void</span> <span class="hljs-symbol">_Destroy</span>(<span class="hljs-symbol">_ForwardIterator</span> <span class="hljs-symbol">__first, <span class="hljs-symbol">_ForwardIterator</span></span> <span class="hljs-symbol">__last</span>) &#123;  <span class="hljs-comment">//使用__VALUE_TYPE获取迭代器__first所指对象的value type</span>  <span class="hljs-comment">//__destroy定义在上面</span>  __destroy(__first, __last, __VALUE_TYPE(__first));&#125;</code></pre><p><strong>* <em>码完收工。。。一会把POD和trivial destruct总结一下。。。→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO复用——poll机制内核源代码剖析</title>
    <link href="/2020/07/02/poll/"/>
    <url>/2020/07/02/poll/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>select内核源代码已经剖析了，但是有个问题还没有解决。。。面对每一种文件描述符如何进行查询？这就和poll机制有关了。。。这篇就来看看poll机制内核源代码。。。→_→</em> *</strong></p><p><strong>了解select底层实现请戳传送门——</strong><a href="http://blog.csdn.net/kongkongkkk/article/details/77099442" target="_blank" rel="noopener"><strong>IO复用——select内核源代码剖析</strong></a></p><p><strong>每一个进程都会有一个与之对应的files_struct结构，files_struct结构中存储着该进程打开的文件的集合</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span> &#123;</span><span class="hljs-keyword">atomic_t</span> count;<span class="hljs-keyword">rwlock_t</span> file_lock;<span class="hljs-keyword">int</span> max_fds;<span class="hljs-keyword">int</span> max_fdset;<span class="hljs-keyword">int</span> next_fd;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> ** <span class="hljs-title">fd</span>;</span><span class="hljs-comment">/* current fd array */</span> <span class="hljs-comment">//fd指向fd_array</span>fd_set *close_on_exec;fd_set *open_fds;fd_set close_on_exec_init;fd_set open_fds_init;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">fd_array</span>[<span class="hljs-title">NR_OPEN_DEFAULT</span>];</span> <span class="hljs-comment">//记录该进程打开文件的数组集合</span>&#125;;</code></pre><p><strong>每一个文件都有与之对应的file_operations类型的文件操作方法</strong></p><pre><code class="hljs cpp"><span class="hljs-comment">//linux-2.4.0\include\linux\Fs.h</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">f_list</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span>*<span class="hljs-title">f_dentry</span>;</span> <span class="hljs-comment">//dentry结构中的d_inode结构中记录着本文件的等待队列，即监听本文件的进程对应的wait_queue_t结构</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vfsmount</span>         *<span class="hljs-title">f_vfsmnt</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span>*<span class="hljs-title">f_op</span>;</span> <span class="hljs-comment">//这是很关键的部分，它决定了poll机制是否可用</span><span class="hljs-keyword">atomic_t</span>f_count;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> f_flags;<span class="hljs-keyword">mode_t</span>f_mode;<span class="hljs-keyword">loff_t</span>f_pos;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> f_reada, f_ramax, f_raend, f_ralen, f_rawin;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fown_struct</span><span class="hljs-title">f_owner</span>;</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>f_uid, f_gid;<span class="hljs-keyword">int</span>f_error;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>f_version;<span class="hljs-comment">/* needed for tty driver, and maybe others */</span><span class="hljs-keyword">void</span>*private_data;&#125;;</code></pre><p><strong>对文件的操作方法有很多种，而每一种实现在机制上都使用回调函数的方法，其中就包括一种poll操作的回调函数</strong></p><pre><code class="hljs rust"><span class="hljs-comment">//linux-2.4.0\include\linux\Fs.h</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span></span> &#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span></span> *owner;loff_t (*llseek) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *, loff_t, int);ssize_t (*read) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *, <span class="hljs-built_in">char</span> *, size_t, loff_t *);ssize_t (*write) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *, <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> *, size_t, loff_t *);int (*readdir) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *, void *, filldir_t);unsigned int (*poll) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_struct</span></span> *); <span class="hljs-comment">//poll操作所对应的回调函数，函数的具体实现和文件的类型有关，如果文件不支持poll操作也就无法在select中使用</span>int (*ioctl) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span></span> *, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *, unsigned int, unsigned long);int (*mmap) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span></span> *);int (*open) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span></span> *, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *);int (*flush) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *);int (*release) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span></span> *, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *);int (*fsync) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span></span> *, int datasync);int (*fasync) (int, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *, int);int (*lock) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *, int, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_lock</span></span> *);ssize_t (*readv) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *, <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span></span> *, unsigned long, loff_t *);ssize_t (*writev) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *, <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span></span> *, unsigned long, loff_t *);&#125;;</code></pre><p>在每一种文件的poll操作回调函数中都会调用有poll_wait函数，目的是将监听本文件的进程的对应wait_queue_t结构，添加进本文件的等待队列中</p><pre><code class="hljs reasonml"><span class="hljs-comment">//linux-2.4.0\arch\i386\math-emu\Poly.h</span><span class="hljs-comment">//wait_address记录着本文件的等待队列队头的地址</span><span class="hljs-comment">//p指向该进程的poll_table结构</span>extern inline void poll<span class="hljs-constructor">_wait(<span class="hljs-params">struct</span> <span class="hljs-params">file</span> <span class="hljs-operator">*</span> <span class="hljs-params">filp</span>, <span class="hljs-params">wait_queue_head_t</span> <span class="hljs-operator">*</span> <span class="hljs-params">wait_address</span>, <span class="hljs-params">poll_table</span> <span class="hljs-operator">*</span><span class="hljs-params">p</span>)</span>&#123;<span class="hljs-keyword">if</span> (p<span class="hljs-operator"> &amp;&amp; </span>wait_address) <span class="hljs-constructor">__pollwait(<span class="hljs-params">filp</span>, <span class="hljs-params">wait_address</span>, <span class="hljs-params">p</span>)</span>;&#125;</code></pre><pre><code class="hljs reasonml"><span class="hljs-comment">//linux-2.4.0\arch\i386\math-emu\Poly.h</span>void <span class="hljs-constructor">__pollwait(<span class="hljs-params">struct</span> <span class="hljs-params">file</span> <span class="hljs-operator">*</span> <span class="hljs-params">filp</span>, <span class="hljs-params">wait_queue_head_t</span> <span class="hljs-operator">*</span> <span class="hljs-params">wait_address</span>, <span class="hljs-params">poll_table</span> <span class="hljs-operator">*</span><span class="hljs-params">p</span>)</span>&#123;<span class="hljs-comment">//table记录当前进程由poll_table_page结构组成的单链的第一个可用结点</span><span class="hljs-keyword">struct</span> poll_table_page *table = p-&gt;table;<span class="hljs-comment">//如果单链不存在或所有poll_table_page结构的页面都被poll_table_entry结构使用，即没有空闲空间时</span><span class="hljs-keyword">if</span> (!table<span class="hljs-operator"> || </span><span class="hljs-constructor">POLL_TABLE_FULL(<span class="hljs-params">table</span>)</span>) &#123;<span class="hljs-keyword">struct</span> poll_table_page *new_table;<span class="hljs-comment">//为其分配一个新的页面，扩充其容量</span>new_table = (<span class="hljs-keyword">struct</span> poll_table_page *) <span class="hljs-constructor">__get_free_page(GFP_KERNEL)</span>;<span class="hljs-keyword">if</span> (!new_table) &#123;p-&gt;error = -ENOMEM;<span class="hljs-constructor">__set_current_state(TASK_RUNNING)</span>;return;&#125;<span class="hljs-comment">//设置新poll_table_page结构页面的第一个可用poll_table_entry结构为poll_table_entry结构数组的第一个元素</span>new_table-&gt;entry = new_table-&gt;entries;<span class="hljs-comment">//poll_table_page结构页面的单链表进行更新</span>new_table-&gt;next = table;<span class="hljs-comment">//当前进程的poll_table结构成员进行更新</span>p-&gt;table = new_table;table = new_table;&#125;<span class="hljs-comment">/* Add a new entry */</span>&#123;<span class="hljs-comment">//获取当前进程的第一个空闲poll_table_entry结构</span><span class="hljs-keyword">struct</span> poll_table_entry<span class="hljs-operator"> * </span>entry = table-&gt;entry;<span class="hljs-comment">//更新第一个空闲poll_table_entry结构</span>table-&gt;entry = entry+<span class="hljs-number">1</span>;<span class="hljs-comment">//对该文件的引用计数加1</span> get<span class="hljs-constructor">_file(<span class="hljs-params">filp</span>)</span>; <span class="hljs-comment">//将此poll_table_entry结构的filp成员设置为该文件</span> entry-&gt;filp = filp; <span class="hljs-comment">//将此poll_table_entry结构的wait_address成员，即等待队列的队头设置为该文件的等待队列的队头</span>entry-&gt;wait_address = wait_address;<span class="hljs-comment">//将此poll_table_entry结构的wait成员，即每个进程对应的wait_queue_t结构，将其中的task_struck结构设置为当前进程的task_struck</span><span class="hljs-comment">//init_waitqueue_entry定义在下面</span>init<span class="hljs-constructor">_waitqueue_entry(&amp;<span class="hljs-params">entry</span>-&gt;<span class="hljs-params">wait</span>, <span class="hljs-params">current</span>)</span>;<span class="hljs-comment">//将该进程对应的wait_queue_t结构链入该文件的等待队列中</span><span class="hljs-comment">//add_wait_queue定义在下面</span>add<span class="hljs-constructor">_wait_queue(<span class="hljs-params">wait_address</span>,&amp;<span class="hljs-params">entry</span>-&gt;<span class="hljs-params">wait</span>)</span>;&#125;&#125;</code></pre><pre><code class="hljs cpp"><span class="hljs-comment">//linux-2.4.0\include\linux\Wait.h</span><span class="hljs-comment">//在init_waitqueue_entry中，将wait_queue_t结构中p设置为指向当前进程task_struck结构，所以当驱动设备唤醒该文件的等待队列中每一个wait_queue_t结构对应的进程时，就可以从wait_queue_t结构中的p成员找到进程的task_struck结构</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init_waitqueue_entry</span><span class="hljs-params">(<span class="hljs-keyword">wait_queue_t</span> *q,</span></span><span class="hljs-function"><span class="hljs-params"> struct task_struct *p)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> WAITQUEUE_DEBUG</span><span class="hljs-keyword">if</span> (!q || !p)WQ_BUG();<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>q-&gt;flags = <span class="hljs-number">0</span>; <span class="hljs-comment">//wait_queue_t结构的flags置为0</span>q-&gt;task = p;<span class="hljs-comment">//wait_queue_t结构的p设置为指向当前进程的task_struck结构</span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> WAITQUEUE_DEBUG</span>q-&gt;__magic = (<span class="hljs-keyword">long</span>)&amp;q-&gt;__magic;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>&#125;</code></pre><pre><code class="hljs reasonml"><span class="hljs-comment">//linux-2.4.0\kernel\Fork.c</span>void add<span class="hljs-constructor">_wait_queue(<span class="hljs-params">wait_queue_head_t</span> <span class="hljs-operator">*</span><span class="hljs-params">q</span>, <span class="hljs-params">wait_queue_t</span> <span class="hljs-operator">*</span> <span class="hljs-params">wait</span>)</span>&#123;unsigned long flags;wq<span class="hljs-constructor">_write_lock_irqsave(&amp;<span class="hljs-params">q</span>-&gt;<span class="hljs-params">lock</span>, <span class="hljs-params">flags</span>)</span>;wait-&gt;flags = <span class="hljs-number">0</span>; <span class="hljs-comment">//wait_queue_t结构的flags置为0</span><span class="hljs-constructor">__add_wait_queue(<span class="hljs-params">q</span>, <span class="hljs-params">wait</span>)</span>;<span class="hljs-comment">//将该进程对应的wait_queue_t结构链入该文件的等待队列中</span>wq<span class="hljs-constructor">_write_unlock_irqrestore(&amp;<span class="hljs-params">q</span>-&gt;<span class="hljs-params">lock</span>, <span class="hljs-params">flags</span>)</span>;&#125;</code></pre><p><strong>通过对Linux内核源代码的剖析，我们对poll机制已经有了深入地了解，现在我们再回到select中，解决最后的问题</strong></p><pre><code class="hljs reasonml"><span class="hljs-comment">//linux-2.4.0\fs\Select.c（部分截取）</span>......for (;;) &#123;set<span class="hljs-constructor">_current_state(TASK_INTERRUPTIBLE)</span>;for (i = <span class="hljs-number">0</span> ; i &lt; n; i++) &#123;unsigned long bit = <span class="hljs-constructor">BIT(<span class="hljs-params">i</span>)</span>;unsigned long mask;<span class="hljs-keyword">struct</span> file *file; <span class="hljs-comment">//记录文件结构体</span>off = i<span class="hljs-operator"> / </span>__NFDBITS;<span class="hljs-keyword">if</span> (!(bit &amp; <span class="hljs-constructor">BITS(<span class="hljs-params">fds</span>, <span class="hljs-params">off</span>)</span>))continue;file = fget(i); <span class="hljs-comment">//利用文件描述符从该进程打开的文件描述符数组中，获取对应的文件结构体</span>mask = POLLNVAL;<span class="hljs-keyword">if</span> (file) &#123;mask = DEFAULT_POLLMASK;<span class="hljs-comment">//此时需要判断该文件是否支持操作和poll操作</span><span class="hljs-keyword">if</span> (file-&gt;f_op<span class="hljs-operator"> &amp;&amp; </span>file-&gt;f_op-&gt;poll)<span class="hljs-comment">//如果支持，就调用该类型文件的poll操作所对应的回调函数，并传入该文件结构体和该进程所对应的wait_queue_t结构，mask记录返回值</span><span class="hljs-comment">//这一操作就是在剖析select时提到的查询，所以真正的查询由poll回调函数完成</span>mask = file-&gt;f_op-&gt;poll(file, wait);fput(file);&#125;<span class="hljs-keyword">if</span> ((mask &amp; POLLIN_SET)<span class="hljs-operator"> &amp;&amp; </span><span class="hljs-constructor">ISSET(<span class="hljs-params">bit</span>, <span class="hljs-params">__IN</span>(<span class="hljs-params">fds</span>,<span class="hljs-params">off</span>)</span>)) &#123;<span class="hljs-constructor">SET(<span class="hljs-params">bit</span>, <span class="hljs-params">__RES_IN</span>(<span class="hljs-params">fds</span>,<span class="hljs-params">off</span>)</span>);retval++;wait = NULL;&#125;<span class="hljs-keyword">if</span> ((mask &amp; POLLOUT_SET)<span class="hljs-operator"> &amp;&amp; </span><span class="hljs-constructor">ISSET(<span class="hljs-params">bit</span>, <span class="hljs-params">__OUT</span>(<span class="hljs-params">fds</span>,<span class="hljs-params">off</span>)</span>)) &#123;<span class="hljs-constructor">SET(<span class="hljs-params">bit</span>, <span class="hljs-params">__RES_OUT</span>(<span class="hljs-params">fds</span>,<span class="hljs-params">off</span>)</span>);retval++;wait = NULL;&#125;<span class="hljs-keyword">if</span> ((mask &amp; POLLEX_SET)<span class="hljs-operator"> &amp;&amp; </span><span class="hljs-constructor">ISSET(<span class="hljs-params">bit</span>, <span class="hljs-params">__EX</span>(<span class="hljs-params">fds</span>,<span class="hljs-params">off</span>)</span>)) &#123;<span class="hljs-constructor">SET(<span class="hljs-params">bit</span>, <span class="hljs-params">__RES_EX</span>(<span class="hljs-params">fds</span>,<span class="hljs-params">off</span>)</span>);retval++;wait = NULL;&#125;&#125;wait = NULL;<span class="hljs-keyword">if</span> (retval<span class="hljs-operator"> || </span>!__timeout<span class="hljs-operator"> || </span>signal<span class="hljs-constructor">_pending(<span class="hljs-params">current</span>)</span>)break;<span class="hljs-keyword">if</span>(table.error) &#123;retval = table.error;break;&#125;__timeout = schedule<span class="hljs-constructor">_timeout(<span class="hljs-params">__timeout</span>)</span>;&#125;......</code></pre><p><strong>* <em>下一篇就来总结epoll喽。。。睡觉。。。→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO复用——select函数应用实例</title>
    <link href="/2020/07/02/select-function-application-example/"/>
    <url>/2020/07/02/select-function-application-example/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>趁着刚刚总结完select的内核源码。。。现在就来应用一下。。。→_→</em> *</strong></p><p><strong>深入理解select底层原理请戳传送门——</strong><a href="http://blog.csdn.net/kongkongkkk/article/details/77099442" target="_blank" rel="noopener"><strong>IO复用——select内核源代码剖析</strong></a></p><p><strong>本次网络通信socket套接字是基于TCP协议的可靠传输，因为只开了一台虚拟机。。。所以服务器IP地址采用回环地址——127.0.0.1，服务器端口号port为6000</strong></p><p><strong>server</strong></p><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/select.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_FD 10 <span class="hljs-comment">//设定最多监听的文件描述符的数量为10</span></span><span class="hljs-keyword">int</span> fds[MAX_FD]; <span class="hljs-comment">//存储多个文件描述符的数组</span><span class="hljs-comment">//初始化文件描述符数组</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fds_init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(;i&lt;MAX_FD;i++)&#123;fds[i] = <span class="hljs-number">-1</span>; <span class="hljs-comment">//将所有的元素初始化为-1</span>&#125;&#125;<span class="hljs-comment">//在文件描述符数组中寻找第一个值为-1的元素，即此元素存放新添加的文件描述符</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fds_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(;i&lt;MAX_FD;i++)&#123;<span class="hljs-keyword">if</span>(fds[i] == <span class="hljs-number">-1</span>)&#123;fds[i] = fd;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-comment">//在文件描述符数组中寻找指定值的元素，将其删除，即将该元素置为-1</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fds_del</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(;i&lt;MAX_FD;i++)&#123;<span class="hljs-keyword">if</span>(fds[i] == fd)&#123;fds[i] = <span class="hljs-number">-1</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> sockfd = socket(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);assert(sockfd != <span class="hljs-number">-1</span>);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">saddr</span>,<span class="hljs-title">caddr</span>;</span><span class="hljs-built_in">memset</span>(&amp;saddr,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(saddr));saddr.sin_family = AF_INET;saddr.sin_port = htons(<span class="hljs-number">6000</span>);saddr.sin_addr.s_addr = inet_addr(<span class="hljs-string">"127.0.0.1"</span>);<span class="hljs-keyword">int</span> res = bind(sockfd,(struct sockaddr *)&amp;saddr,<span class="hljs-keyword">sizeof</span>(saddr));assert(res != <span class="hljs-number">-1</span>);<span class="hljs-built_in">listen</span>(sockfd,<span class="hljs-number">5</span>);<span class="hljs-comment">//这里只对读事件进行验证，所以只定义一个fd_set结构</span>fd_set fdset;<span class="hljs-comment">//初始化存放文件描述符的数组</span>fds_init();fds_add(sockfd); <span class="hljs-comment">//将socket也作为要监听的文件描述符</span><span class="hljs-comment">//服务器开始进入while循环</span><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//因为调用select后，有可能改变文件描述符在fdset位图中的标志，所以每一次开始监听之前都要重新轻灵标志</span>FD_ZERO(&amp;fdset);<span class="hljs-keyword">int</span> maxfd = <span class="hljs-number">-1</span>; <span class="hljs-comment">//记录当前要监听的文件描述符的最大值</span><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(; i &lt; MAX_FD; ++i)&#123;<span class="hljs-keyword">if</span>(fds[i] != <span class="hljs-number">-1</span>) <span class="hljs-comment">//如果文件描述符数组中的元素不为-1，就将此元素设置到fds位图中</span>&#123;FD_SET(fds[i], &amp;fdset);<span class="hljs-keyword">if</span>(fds[i] &gt; maxfd)&#123;maxfd = fds[i];&#125;&#125;&#125;<span class="hljs-comment">//设置浅睡眠时间为5毫秒整</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">tv</span> = &#123;</span><span class="hljs-number">5</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//返回值为一共就绪事件的总和</span><span class="hljs-keyword">int</span> n = select(maxfd + <span class="hljs-number">1</span>, &amp;fdset, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;tv);<span class="hljs-keyword">if</span>(n == <span class="hljs-number">-1</span>) <span class="hljs-comment">//如果返回值为-1，表示出错</span>&#123;perror(<span class="hljs-string">"select error"</span>);<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-comment">//如果返回值为0，表示睡眠期间没有事件就绪，继续循环监听</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"time out\n"</span>);<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//再一次遍历文件描述符数组，查看哪一个是就绪事件</span><span class="hljs-keyword">for</span>(; i &lt; MAX_FD; ++i)&#123;<span class="hljs-keyword">if</span>(fds[i] == <span class="hljs-number">-1</span>)&#123;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-comment">//测试此文件描述符元素在位图中对应的位是否被设置</span><span class="hljs-keyword">if</span>(FD_ISSET(fds[i], &amp;fdset))&#123;<span class="hljs-comment">//如果就绪的是sockfd，表示有了新连接</span><span class="hljs-keyword">if</span>(sockfd == fds[i])&#123;<span class="hljs-keyword">int</span> len = <span class="hljs-keyword">sizeof</span>(caddr);<span class="hljs-keyword">int</span> c = accept(sockfd, (struct sockaddr *)&amp;caddr, &amp;len);<span class="hljs-keyword">if</span>(c &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">continue</span>;&#125;fds_add(c);&#125;<span class="hljs-keyword">else</span> <span class="hljs-comment">//否则就读取就绪事件的数据</span>&#123;<span class="hljs-keyword">char</span> buff[<span class="hljs-number">128</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//如果返回值小于等于0，表示连接中断或出错</span><span class="hljs-keyword">if</span>(recv(fds[i], buff, <span class="hljs-number">127</span>, <span class="hljs-number">0</span>) &lt;= <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//此时需要关闭该连接</span><span class="hljs-built_in">close</span>(fds[i]);<span class="hljs-comment">//并从文件描述符数组中删除此元素</span>fds_del(fds[i]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"one client over\n"</span>);<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"read:%s\n"</span>,buff);<span class="hljs-comment">//读取全部数据后，向客户端发送"ok"</span>send(fds[i], <span class="hljs-string">"ok"</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);&#125;&#125;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>client</strong></p><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;assert.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> sockfd = socket(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);assert(sockfd != <span class="hljs-number">-1</span>);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">saddr</span>,<span class="hljs-title">caddr</span>;</span><span class="hljs-built_in">memset</span>(&amp;saddr,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(saddr));saddr.sin_family = AF_INET;saddr.sin_port = htons(<span class="hljs-number">6000</span>);saddr.sin_addr.s_addr = inet_addr(<span class="hljs-string">"127.0.0.1"</span>);<span class="hljs-keyword">int</span> res = <span class="hljs-built_in">connect</span>(sockfd,(struct sockaddr*)&amp;saddr,<span class="hljs-keyword">sizeof</span>(saddr));assert(res != <span class="hljs-number">-1</span>);<span class="hljs-built_in">listen</span>(sockfd,<span class="hljs-number">5</span>);<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"input:\n"</span>);<span class="hljs-comment">//输入缓冲区</span><span class="hljs-keyword">char</span> buff[<span class="hljs-number">128</span>] = &#123;<span class="hljs-number">0</span>&#125;;fgets(buff,<span class="hljs-number">128</span>,<span class="hljs-built_in">stdin</span>);        <span class="hljs-comment">//如果输入的数据为"end"，表示要关闭客户端，此时跳出循环</span>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strncmp</span>(buff,<span class="hljs-string">"end"</span>,<span class="hljs-number">3</span> ) == <span class="hljs-number">0</span>)&#123; <span class="hljs-keyword">break</span>;&#125;<span class="hljs-comment">//否则就发送所输入的数据</span>send(sockfd,buff,<span class="hljs-built_in">strlen</span>(buff),<span class="hljs-number">0</span>);<span class="hljs-comment">//再将缓冲区清零</span><span class="hljs-built_in">memset</span>(buff,<span class="hljs-number">0</span>,<span class="hljs-number">128</span>);<span class="hljs-comment">//接收服务器端的回复</span>recv(sockfd,buff,<span class="hljs-number">127</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"buff = %s\n"</span>,buff);&#125;<span class="hljs-comment">//关闭该连接</span>    <span class="hljs-built_in">close</span>(sockfd);     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>运行结果</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODE2MjMwMzE1MjQ0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="IO复用select"></p><p><strong>* <em>其实这些代码是之前写的。。。一会就来总结poll机制。。。→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转】C++11标准新特性：右值引用与转移语义</title>
    <link href="/2020/07/01/rvalue-reference-and-transfer-semantics/"/>
    <url>/2020/07/01/rvalue-reference-and-transfer-semantics/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>碰巧看到这篇文章。。。学习了。。。→_→</em> *</strong></p><p><strong>原文链接请戳传送门</strong>：<a href="https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/index.html" target="_blank" rel="noopener"><strong>C++11标准新特性：右值引用与转移语义</strong></a></p><ol><li><p><strong>新特性的目的</strong></p><ul><li><p>右值引用 (Rvalue Referene) 是 C++ 新标准 (C++11, 11 代表 2011 年 ) 中引入的新特性 , 它实现了转移语义 (Move Sementics) 和精确传递 (Perfect Forwarding)。</p></li><li><p>它的主要目的有两个方面</p><ul><li><p>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</p></li><li><p>能够更简洁明确地定义泛型函数。</p></li></ul></li></ul></li><li><p><strong>左值与右值的定义</strong></p><ul><li><p>C++( 包括 C) 中所有的表达式和变量要么是左值，要么是右值。<strong>通俗的左值的定义就是非临时对象，那些可以在多条语句中使用的对象。</strong>所有的变量都满足这个定义，在多条代码中都可以使用，都是左值。<strong>右值是指临时的对象，它们只在当前的语句中有效。</strong></p><p>  如简单的赋值语句 <code>int i = 0;</code><br>  在这条语句中，<strong>i 是左值，0 是临时值，就是右值</strong>。在下面的代码中，i 可以被引用，0 就不可以了。立即数都是右值。</p></li><li><p><strong>右值也可以出现在赋值表达式的左边，但是不能作为赋值的对象，因为右值只在当前语句有效，赋值没有意义</strong>。</p><p>  如<code>((i&gt;0) ? i : j) = 1;</code><br>  在这个例子中，0 作为右值出现在了”=”的左边。但是<strong>赋值对象是 i 或者 j，都是左值。</strong></p></li><li><p><strong>在 C++11 之前，右值是不能被引用的，最大限度就是用常量引用绑定一个右值</strong>，如<code>const int &amp;a = 1;</code></p><p>  <strong>在这种情况下，右值不能被修改的。但是实际上右值是可以被修改的</strong>，如<code>T().set().get();</code></p><p>  T 是一个类，set 是一个函数为 T 中的一个变量赋值，get 用来取出这个变量的值。在这句中，T() 生成一个临时对象，就是右值，set() 修改了变量的值，也就修改了这个右值。</p><p>  既然右值可以被修改，那么就可以实现右值引用。右值引用能够方便地解决实际工程中的问题，实现非常有吸引力的解决方案。</p></li></ul></li><li><p><strong>左值和右值的语法符号</strong></p><p> <strong>左值的声明符号为”&amp;”， 为了和左值区分，右值的声明符号为”&amp;&amp;”。</strong></p> <pre><code class="hljs cpp"><span class="hljs-comment">//运行结果</span><span class="hljs-comment">//LValue processed: 0 </span><span class="hljs-comment">//RValue processed: 1</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_value</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; i)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"LValue processed: "</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; &#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_value</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp;&amp; i)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"RValue processed: "</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; &#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;     process_value(a);     process_value(<span class="hljs-number">1</span>); &#125;</code></pre><p> Process_value 函数被重载，分别接受左值和右值。由输出结果可以看出，临时对象是作为右值处理的。</p><p> <strong>但是如果临时对象通过一个接受右值的函数传递给另一个函数时，就会变成左值，因为这个临时对象在传递过程中，变成了命名对象。</strong></p> <pre><code class="hljs cpp"><span class="hljs-comment">//运行结果</span><span class="hljs-comment">//LValue processed: 0 </span><span class="hljs-comment">//RValue processed: 1 </span><span class="hljs-comment">//LValue processed: 2</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_value</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; i)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"LValue processed: "</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; &#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_value</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp;&amp; i)</span></span><span class="hljs-function"></span>&#123; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"RValue processed: "</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; &#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">forward_value</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp;&amp; i)</span></span><span class="hljs-function"></span>&#123;process_value(i); &#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;     process_value(a);     process_value(<span class="hljs-number">1</span>);     forward_value(<span class="hljs-number">2</span>); &#125;</code></pre><p> 虽然 2 这个立即数在函数 forward_value 接收时是右值，但到了 process_value 接收时，变成了左值。</p></li><li><p><strong>转移语义的定义</strong></p><ul><li><p><strong>右值引用是用来支持转移语义的。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。</strong></p></li><li><p>转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。</p></li><li><p>通过转移语义，临时对象中的资源能够转移其它的对象里。</p></li><li><p>在现有的 C++ 机制中，我们可以定义拷贝构造函数和赋值函数。<strong>要实现转移语义，需要定义转移构造函数，还可以定义转移赋值操作符。对于右值的拷贝和赋值会调用转移构造函数和转移赋值操作符。如果转移构造函数和转移拷贝操作符没有定义，那么就遵循现有的机制，拷贝构造函数和赋值操作符会被调用。</strong></p></li><li><p><strong>普通的函数和操作符也可以利用右值引用操作符实现转移语义。</strong></p></li></ul></li><li><p><strong>实现转移构造函数和转移赋值函数</strong></p><p> 以一个简单的 string 类为示例，实现拷贝构造函数和拷贝赋值操作符。</p> <pre><code class="hljs cpp"><span class="hljs-comment">//运行结果</span><span class="hljs-comment">//Copy Assignment is called! source: Hello </span><span class="hljs-comment">//Copy Constructor is called! source: World</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyString</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:<span class="hljs-keyword">char</span>* _data;<span class="hljs-keyword">size_t</span>   _len;<span class="hljs-keyword">void</span> _init_data(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s)&#123;_data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[_len + <span class="hljs-number">1</span>];<span class="hljs-built_in">memcpy</span>(_data, s, _len);_data[_len] = <span class="hljs-string">'\0'</span>;&#125;<span class="hljs-keyword">public</span>:MyString()&#123;_data = <span class="hljs-literal">NULL</span>;_len = <span class="hljs-number">0</span>;&#125;MyString(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* p)&#123;_len = <span class="hljs-built_in">strlen</span>(p);_init_data(p);&#125;MyString(<span class="hljs-keyword">const</span> MyString&amp; str)&#123;_len = str._len;_init_data(str._data);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Copy Constructor is called! source: "</span> &lt;&lt; str._data &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;MyString&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> MyString&amp; str)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;str)&#123;_len = str._len;_init_data(str._data);&#125;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Copy Assignment is called! source: "</span> &lt;&lt; str._data &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-keyword">virtual</span> ~MyString()&#123;<span class="hljs-keyword">if</span> (_data)<span class="hljs-built_in">free</span>(_data);&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;MyString a;a = MyString(<span class="hljs-string">"Hello"</span>);<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;MyString&gt; vec;vec.push_back(MyString(<span class="hljs-string">"World"</span>));&#125;</code></pre><p> 这个 string 类已经基本满足我们演示的需要。在 main 函数中，实现了调用拷贝构造函数的操作和拷贝赋值操作符的操作。<strong>MyString(“Hello”) 和MyString(“World”) 都是临时对象，也就是右值。虽然它们是临时的，但程序仍然调用了拷贝构造和拷贝赋值，造成了没有意义的资源申请和释放的操作。如果能够直接使用临时对象已经申请的资源，既能节省资源，有能节省资源申请和释放的时间。这正是定义转移语义的目的。</strong></p><p> 我们先定义<strong>转移构造函数</strong>。</p> <pre><code class="hljs sqf">MyString(MyString&amp;&amp; <span class="hljs-built_in">str</span>) &#123;std::cout &lt;&lt; <span class="hljs-string">"Move Constructor is called! source: "</span> &lt;&lt; <span class="hljs-built_in">str</span>.<span class="hljs-variable">_data</span> &lt;&lt; std::<span class="hljs-literal">endl</span>;<span class="hljs-variable">_len</span> = <span class="hljs-built_in">str</span>.<span class="hljs-variable">_len</span>;<span class="hljs-variable">_data</span> = <span class="hljs-built_in">str</span>.<span class="hljs-variable">_data</span>;<span class="hljs-built_in">str</span>.<span class="hljs-variable">_len</span> = <span class="hljs-number">0</span>;<span class="hljs-built_in">str</span>.<span class="hljs-variable">_data</span> = NULL;&#125;</code></pre><p> <strong>和拷贝构造函数类似</strong>，有几点需要注意：</p><ul><li><p><strong>参数（右值）的符号必须是右值引用符号，即“&amp;&amp;”。</strong></p></li><li><p><strong>参数（右值）不可以是常量，因为我们需要修改右值。</strong></p></li><li><p><strong>参数（右值）的资源链接和标记必须修改。否则，右值的析构函数就会释放资源。转移到新对象的资源也就无效了。</strong></p><p>现在我们<strong>定义转移赋值操作符。</strong></p><pre><code class="hljs sqf">MyString&amp; operator=(MyString&amp;&amp; <span class="hljs-built_in">str</span>)&#123;std::cout &lt;&lt; <span class="hljs-string">"Move Assignment is called! source: "</span> &lt;&lt; <span class="hljs-built_in">str</span>.<span class="hljs-variable">_data</span> &lt;&lt; std::<span class="hljs-literal">endl</span>;<span class="hljs-keyword">if</span> (this != &amp;<span class="hljs-built_in">str</span>)&#123;<span class="hljs-variable">_len</span> = <span class="hljs-built_in">str</span>.<span class="hljs-variable">_len</span>;<span class="hljs-variable">_data</span> = <span class="hljs-built_in">str</span>.<span class="hljs-variable">_data</span>;<span class="hljs-built_in">str</span>.<span class="hljs-variable">_len</span> = <span class="hljs-number">0</span>;<span class="hljs-built_in">str</span>.<span class="hljs-variable">_data</span> = NULL;&#125;return *this;&#125;</code></pre><p>这里需要注意的问题和转移构造函数是一样的。</p><p>增加了转移构造函数和转移复制操作符后，我们的程序运行结果为 :</p><pre><code class="hljs pgsql">//<span class="hljs-keyword">Move</span> Assignment <span class="hljs-keyword">is</span> <span class="hljs-keyword">called</span>! source: Hello //<span class="hljs-keyword">Move</span> Constructor <span class="hljs-keyword">is</span> <span class="hljs-keyword">called</span>! source: World</code></pre></li></ul><p> <strong>由此看出，编译器区分了左值和右值，对右值调用了转移构造函数和转移赋值操作符。节省了资源，提高了程序运行的效率。</strong></p><p> <strong>有了右值引用和转移语义，我们在设计和实现类时，对于需要动态申请大量资源的类，应该设计转移构造函数和转移赋值函数，以提高应用程序的效率。</strong></p></li><li><p><strong>标准库函数 std::move</strong></p><p> 既然编译器只对右值引用才能调用转移构造函数和转移赋值函数，而所有命名对象都只能是左值引用，<strong>如果已知一个命名对象不再被使用而想对它调用转移构造函数和转移赋值函数，也就是把一个左值引用当做右值引用来使用</strong>，怎么做呢？<strong>标准库提供了函数 std::move，这个函数以非常简单的方式将左值引用转换为右值引用。</strong></p> <pre><code class="hljs arduino"><span class="hljs-comment">//运行结果</span><span class="hljs-comment">//LValue processed: 0 </span><span class="hljs-comment">//RValue processed: 0</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; i)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"LValue processed: "</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp;&amp; i)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"RValue processed: "</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;ProcessValue(a);ProcessValue(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(a));&#125;</code></pre><p> std::move在提高 swap 函数的的性能上非常有帮助，一般来说，swap函数的通用定义如下：</p> <pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt; <span class="hljs-symbol">swap</span>(<span class="hljs-symbol">T</span>&amp; <span class="hljs-symbol">a, <span class="hljs-symbol">T</span></span>&amp; <span class="hljs-symbol">b</span>)&#123;T tmp(a);   <span class="hljs-comment">// copy a to tmp </span>a = b;      <span class="hljs-comment">// copy b to a </span>b = tmp;    <span class="hljs-comment">// copy tmp to b </span>&#125;</code></pre><p> 有了 std::move，swap 函数的定义变为 :</p> <pre><code class="hljs arduino"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; <span class="hljs-title">swap</span>(<span class="hljs-title">T</span>&amp; <span class="hljs-title">a</span>, <span class="hljs-title">T</span>&amp; <span class="hljs-title">b</span>)</span><span class="hljs-class">&#123;</span><span class="hljs-function">T <span class="hljs-title">tmp</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(a))</span></span>; <span class="hljs-comment">// move a to tmp </span>a = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(b);    <span class="hljs-comment">// move b to a </span>b = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(tmp);  <span class="hljs-comment">// move tmp to b </span>&#125;</code></pre><p> <strong>通过 std::move，一个简单的 swap 函数就避免了 3 次不必要的拷贝操作。</strong></p></li><li><p><strong>精确传递 (Perfect Forwarding)</strong></p><p> 本文采用精确传递表达这个意思。”Perfect Forwarding”也被翻译成完美转发，精准转发等，说的都是一个意思。</p><p> <strong>精确传递适用于这样的场景：需要将一组参数原封不动的传递给另一个函数。</strong></p><p> “原封不动”不仅仅是参数的值不变，在 C++ 中，除了参数值之外，还有一下两组属性：<strong>左值／右值和 const/non-const</strong>。 </p><p> <strong>精确传递就是在参数传递过程中，所有这些属性和参数值都不能改变。在泛型函数中，这样的需求非常普遍。</strong></p><p> 下面举例说明。函数 forward_value 是一个泛型函数，它将一个参数传递给另一个函数 process_value。</p><p> forward_value 的定义为：</p> <pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">forward_value</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; val)</span></span><span class="hljs-function"></span>&#123;process_value(val);&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">forward_value</span><span class="hljs-params">(T&amp; val)</span> </span><span class="hljs-function"></span>&#123;process_value(val);&#125;</code></pre><p> <strong>函数 forward_value 为每一个参数必须重载两种类型，T&amp; 和 const T&amp;，否则，下面四种不同类型参数的调用中就不能同时满足  :</strong></p> <pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> a = <span class="hljs-number">0</span>;const <span class="hljs-built_in">int</span> &amp;b = <span class="hljs-number">1</span>;forward<span class="hljs-constructor">_value(<span class="hljs-params">a</span>)</span>; <span class="hljs-comment">// int&amp; </span>forward<span class="hljs-constructor">_value(<span class="hljs-params">b</span>)</span>; <span class="hljs-comment">// const int&amp; </span>forward<span class="hljs-constructor">_value(2)</span>; <span class="hljs-comment">// int&amp;</span></code></pre><p> <strong>对于一个参数就要重载两次，也就是函数重载的次数和参数的个数是一个正比的关系。这个函数的定义次数对于程序员来说，是非常低效的。</strong>我们看看右值引用如何帮助我们解决这个问题  :</p> <pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">forward_value</span><span class="hljs-params">(T&amp;&amp; val)</span></span><span class="hljs-function"></span>&#123;process_value(val);&#125;</code></pre><p> <strong>只需要定义一次，接受一个右值引用的参数，就能够将所有的参数类型原封不动的传递给目标函数。四种不用类型参数的调用都能满足，参数的左右值属性和 const/non-cosnt 属性完全传递给目标函数 process_value</strong>。这个解决方案不是简洁优雅吗？</p> <pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> a = <span class="hljs-number">0</span>;const <span class="hljs-built_in">int</span> &amp;b = <span class="hljs-number">1</span>;forward<span class="hljs-constructor">_value(<span class="hljs-params">a</span>)</span>; <span class="hljs-comment">// int&amp; </span>forward<span class="hljs-constructor">_value(<span class="hljs-params">b</span>)</span>; <span class="hljs-comment">// const int&amp; </span>forward<span class="hljs-constructor">_value(2)</span>; <span class="hljs-comment">// int&amp;&amp;</span></code></pre><p> <strong>C++11 中定义的 T&amp;&amp; 的推导规则为：</strong></p><ul><li><p><strong>右值实参为右值引用，左值实参仍然为左值引用。</strong></p><p>一句话，就是参数的属性不变。这样也就完美的实现了参数的完整传递。</p></li></ul><p> <strong>右值引用，表面上看只是增加了一个引用符号，但它对 C++ 软件设计和类库的设计有非常大的影响。它既能简化代码，又能提高程序运行效率。</strong>每一个 C++ 软件设计师和程序员都应该理解并能够应用它。<strong>我们在设计类的时候如果有动态申请的资源，也应该设计转移构造函数和转移拷贝函数。在设计类库时，还应该考虑 std::move 的使用场景并积极使用它。</strong></p></li><li><p><strong>总结</strong></p><p> 右值引用和转移语义是 C++ 新标准中的一个重要特性。每一个专业的 C++ 开发人员都应该掌握并应用到实际项目中。在有机会重构代码时，也应该思考是否可以应用新也行。在使用之前，需要检查一下编译器的支持情况。</p></li></ol><p><strong>* <em>学习了。。。从IBM 为 AIX 和 UNIX 用户提供的文章、教程和技术资源中看到的。。。嗯。。。select没总结完。。。→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO复用——select内核源代码剖析</title>
    <link href="/2020/07/01/anatomy-of-select-kernel-source-code/"/>
    <url>/2020/07/01/anatomy-of-select-kernel-source-code/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>在高并发编程中，多次使用IO复用select函数，本篇就来深入剖析一下其内核源码。。。→_→</em> *</strong></p><p><strong>了解poll机制底层原理请戳传送门——</strong><a href="http://blog.csdn.net/kongkongkkk/article/details/77273199" target="_blank" rel="noopener"><strong>IO复用——poll机制内核源代码分析</strong></a></p><p><strong>了解select应用实例请戳传送门——</strong><a href="http://blog.csdn.net/kongkongkkk/article/details/77278144" target="_blank" rel="noopener"><strong>IO复用——select函数应用实例</strong></a></p><p><strong>&lt; – 2017-08-11 23:40 – &gt;</strong><br><strong>还有一部分代码没贴。。。明天把select这个硬骨头啃下来。。。</strong></p><p><strong>&lt; – 2017-08-16 13:32 – &gt;</strong><br><strong>宿舍没网。。我的流量啊。。因为源代码大部分都在Select.c中。。。所以会有点多。。。看官请直接进sys_select。。。</strong></p><pre><code class="hljs reasonml"><span class="hljs-comment">//linux-2.4.0\fs\Select.c</span><span class="hljs-comment">//提供了6个宏函数，返回要求位图或结果位图中对应的下标元素的值</span>#define <span class="hljs-constructor">__IN(<span class="hljs-params">fds</span>, <span class="hljs-params">n</span>)</span>(fds-&gt;<span class="hljs-keyword">in</span> + n)#define <span class="hljs-constructor">__OUT(<span class="hljs-params">fds</span>, <span class="hljs-params">n</span>)</span>(fds-&gt;out + n)#define <span class="hljs-constructor">__EX(<span class="hljs-params">fds</span>, <span class="hljs-params">n</span>)</span>(fds-&gt;ex + n)#define <span class="hljs-constructor">__RES_IN(<span class="hljs-params">fds</span>, <span class="hljs-params">n</span>)</span>(fds-&gt;res_in + n)#define <span class="hljs-constructor">__RES_OUT(<span class="hljs-params">fds</span>, <span class="hljs-params">n</span>)</span>(fds-&gt;res_out + n)#define <span class="hljs-constructor">__RES_EX(<span class="hljs-params">fds</span>, <span class="hljs-params">n</span>)</span>(fds-&gt;res_ex + n)<span class="hljs-comment">//这个元素下标可以同时对应三种位图，所以在一个位图中监听存在就行</span>#define <span class="hljs-constructor">BITS(<span class="hljs-params">fds</span>, <span class="hljs-params">n</span>)</span>(*<span class="hljs-constructor">__IN(<span class="hljs-params">fds</span>, <span class="hljs-params">n</span>)</span><span class="hljs-pattern-match">|<span class="hljs-operator">*</span><span class="hljs-constructor">__OUT(<span class="hljs-params">fds</span>, <span class="hljs-params">n</span>)</span>|<span class="hljs-operator">*</span><span class="hljs-constructor">__EX(<span class="hljs-params">fds</span>, <span class="hljs-params">n</span>)</span>)</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match">static <span class="hljs-built_in">int</span> max<span class="hljs-constructor">_select_fd(<span class="hljs-params">unsigned</span> <span class="hljs-params">long</span> <span class="hljs-params">n</span>, <span class="hljs-params">fd_set_bits</span> <span class="hljs-operator">*</span><span class="hljs-params">fds</span>)</span></span><span class="hljs-pattern-match">&#123;</span><span class="hljs-pattern-match">unsigned long <span class="hljs-operator">*</span><span class="hljs-keyword">open</span><span class="hljs-constructor">_fds</span>;</span><span class="hljs-pattern-match">unsigned long set;</span><span class="hljs-pattern-match"><span class="hljs-built_in">int</span> max;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">*</span> handle last <span class="hljs-keyword">in</span>-complete long-word first <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><span class="hljs-pattern-match">set = ~(~0<span class="hljs-constructor">UL</span> &lt;&lt; (n &amp; (<span class="hljs-constructor">__NFDBITS</span>-1)));</span><span class="hljs-pattern-match">n <span class="hljs-operator">/</span>= <span class="hljs-constructor">__NFDBITS</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>将所监听的文件描述符的个数转化为位图的元素下标</span><span class="hljs-pattern-match"><span class="hljs-keyword">open</span><span class="hljs-constructor">_fds</span> = current-&gt;files-&gt;<span class="hljs-keyword">open</span><span class="hljs-constructor">_fds</span>-&gt;fds<span class="hljs-constructor">_bits</span>+n;</span><span class="hljs-pattern-match">max = 0; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>记录最大的序号</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (set) &#123;</span><span class="hljs-pattern-match">set &amp;= <span class="hljs-constructor">BITS(<span class="hljs-params">fds</span>, <span class="hljs-params">n</span>)</span>;</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (set) &#123;</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (!(set &amp; ~<span class="hljs-operator">*</span><span class="hljs-keyword">open</span><span class="hljs-constructor">_fds</span>))</span><span class="hljs-pattern-match">goto get<span class="hljs-constructor">_max</span>;</span><span class="hljs-pattern-match">return -<span class="hljs-constructor">EBADF</span>;</span><span class="hljs-pattern-match">&#125;</span><span class="hljs-pattern-match">&#125;</span><span class="hljs-pattern-match"><span class="hljs-keyword">while</span> (n) &#123;</span><span class="hljs-pattern-match"><span class="hljs-keyword">open</span><span class="hljs-constructor">_fds</span>--;</span><span class="hljs-pattern-match">n--;</span><span class="hljs-pattern-match">set = <span class="hljs-constructor">BITS(<span class="hljs-params">fds</span>, <span class="hljs-params">n</span>)</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>判断在位图下标位n的元素中是否有要监听的文件描述符</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (!set) <span class="hljs-operator">/</span><span class="hljs-operator">/</span>如果位图中下标为n的元素中没有要监听的文件描述符，就继续寻找</span><span class="hljs-pattern-match">continue;</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (set &amp; ~<span class="hljs-operator">*</span><span class="hljs-keyword">open</span><span class="hljs-constructor">_fds</span>)</span><span class="hljs-pattern-match">return -<span class="hljs-constructor">EBADF</span>;</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (max) <span class="hljs-operator">/</span><span class="hljs-operator">/</span>这里的最大序号可以理解为一个标志位</span><span class="hljs-pattern-match">continue;</span><span class="hljs-pattern-match">get<span class="hljs-constructor">_max</span>:</span><span class="hljs-pattern-match"><span class="hljs-keyword">do</span> &#123;</span><span class="hljs-pattern-match">max<span class="hljs-operator">++</span>;</span><span class="hljs-pattern-match">set &gt;&gt;= 1;</span><span class="hljs-pattern-match">&#125; <span class="hljs-keyword">while</span> (set);</span><span class="hljs-pattern-match">max += n <span class="hljs-operator">*</span> <span class="hljs-constructor">__NFDBITS</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>再将位图中的元素序号转化为文件描述符对应的个数</span><span class="hljs-pattern-match">&#125;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match">return max;</span><span class="hljs-pattern-match">&#125;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match">#define <span class="hljs-constructor">BIT(<span class="hljs-params">i</span>)</span>(1<span class="hljs-constructor">UL</span> &lt;&lt; ((i)&amp;(<span class="hljs-constructor">__NFDBITS</span>-1)))</span><span class="hljs-pattern-match">#define <span class="hljs-constructor">MEM(<span class="hljs-params">i</span>,<span class="hljs-params">m</span>)</span>((m)+(unsigned)(i)<span class="hljs-operator">/</span><span class="hljs-constructor">__NFDBITS</span>)</span><span class="hljs-pattern-match">#define <span class="hljs-constructor">ISSET(<span class="hljs-params">i</span>,<span class="hljs-params">m</span>)</span>(((i)&amp;<span class="hljs-operator">*</span>(m)) != 0)</span><span class="hljs-pattern-match">#define <span class="hljs-constructor">SET(<span class="hljs-params">i</span>,<span class="hljs-params">m</span>)</span>(<span class="hljs-operator">*</span>(m) |= (i))</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match">#define <span class="hljs-constructor">POLLIN_SET</span> (<span class="hljs-constructor">POLLRDNORM</span> | <span class="hljs-constructor">POLLRDBAND</span> | <span class="hljs-constructor">POLLIN</span> | <span class="hljs-constructor">POLLHUP</span> | <span class="hljs-constructor">POLLERR</span>)</span><span class="hljs-pattern-match">#define <span class="hljs-constructor">POLLOUT_SET</span> (<span class="hljs-constructor">POLLWRBAND</span> | <span class="hljs-constructor">POLLWRNORM</span> | <span class="hljs-constructor">POLLOUT</span> | <span class="hljs-constructor">POLLERR</span>)</span><span class="hljs-pattern-match">#define <span class="hljs-constructor">POLLEX_SET</span> (<span class="hljs-constructor">POLLPRI</span>)</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match"><span class="hljs-built_in">int</span> <span class="hljs-keyword">do</span><span class="hljs-constructor">_select(<span class="hljs-params">int</span> <span class="hljs-params">n</span>, <span class="hljs-params">fd_set_bits</span> <span class="hljs-operator">*</span><span class="hljs-params">fds</span>, <span class="hljs-params">long</span> <span class="hljs-operator">*</span><span class="hljs-params">timeout</span>)</span></span><span class="hljs-pattern-match">&#123;</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>poll<span class="hljs-constructor">_table</span>类型结构在下面有解释说明</span><span class="hljs-pattern-match">poll<span class="hljs-constructor">_table</span> table, <span class="hljs-operator">*</span>wait;</span><span class="hljs-pattern-match"><span class="hljs-built_in">int</span> retval, i, off;</span><span class="hljs-pattern-match">long <span class="hljs-constructor">__timeout</span> = <span class="hljs-operator">*</span>timeout;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match"> read<span class="hljs-constructor">_lock(&amp;<span class="hljs-params">current</span>-&gt;<span class="hljs-params">files</span>-&gt;<span class="hljs-params">file_lock</span>)</span>;</span><span class="hljs-pattern-match"> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>计算所监听的文件描述符在位图中的最大的序号是多少，高于这个序号的文件描述符都与本次操作无关</span><span class="hljs-pattern-match"> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>max<span class="hljs-constructor">_select_fd</span>定义在上面</span><span class="hljs-pattern-match">retval = max<span class="hljs-constructor">_select_fd(<span class="hljs-params">n</span>, <span class="hljs-params">fds</span>)</span>;</span><span class="hljs-pattern-match">read<span class="hljs-constructor">_unlock(&amp;<span class="hljs-params">current</span>-&gt;<span class="hljs-params">files</span>-&gt;<span class="hljs-params">file_lock</span>)</span>;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (retval &lt; 0)</span><span class="hljs-pattern-match">return retval;</span><span class="hljs-pattern-match">n = retval;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>当一个进程要进入睡眠，而想要某个设备的驱动程序在设备的状态发生变化时将其唤醒，就要准备一个wait<span class="hljs-constructor">_queue_t</span>数据结构，并将这个数据结构挂入目标设备的某个等待队列中。而wait<span class="hljs-constructor">_queue_t</span>就封装在poll<span class="hljs-constructor">_table</span>类型结构中</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>初始化poll<span class="hljs-constructor">_table</span>类型结构变量，将table成员置为<span class="hljs-constructor">NULL</span>，error成员置为0</span><span class="hljs-pattern-match">poll<span class="hljs-constructor">_initwait(&amp;<span class="hljs-params">table</span>)</span>;</span><span class="hljs-pattern-match">wait = &amp;table;</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (!<span class="hljs-constructor">__timeout</span>)</span><span class="hljs-pattern-match">wait = <span class="hljs-constructor">NULL</span>;</span><span class="hljs-pattern-match">retval = 0;</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>进入for循环，直到所监听的事件就绪，或指定的睡眠等待时间到期，或者当前进程收到了信号时才会结束</span><span class="hljs-pattern-match">for (;;) &#123;</span><span class="hljs-pattern-match">set<span class="hljs-constructor">_current_state(TASK_INTERRUPTIBLE)</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>将当前进程的状态置为可中断阻塞，即当前进程将会进入浅睡眠状态</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>内层for循环中，对所要监视的文件描述符对应的位图进行一次扫描</span><span class="hljs-pattern-match">for (i = 0 ; i &lt; n; i<span class="hljs-operator">++</span>) &#123;</span><span class="hljs-pattern-match">unsigned long bit = <span class="hljs-constructor">BIT(<span class="hljs-params">i</span>)</span>;</span><span class="hljs-pattern-match">unsigned long mask;</span><span class="hljs-pattern-match"><span class="hljs-keyword">struct</span> file <span class="hljs-operator">*</span>file;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match">off = i <span class="hljs-operator">/</span> <span class="hljs-constructor">__NFDBITS</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>将文件描述符的个数i转化为位图中所对应的元素下标off</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (!(bit &amp; <span class="hljs-constructor">BITS(<span class="hljs-params">fds</span>, <span class="hljs-params">off</span>)</span>)) <span class="hljs-operator">/</span><span class="hljs-operator">/</span>如果三种位图的某一位为1，就对相应的文件描述符做一次询问</span><span class="hljs-pattern-match">continue;</span><span class="hljs-pattern-match">file = fget(i);</span><span class="hljs-pattern-match">mask = <span class="hljs-constructor">POLLNVAL</span>;</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>文件的具体询问方式和其类型有关，即是通过file<span class="hljs-constructor">_operations</span>数据结构中的函数指针poll进行的。关于poll操作将会在另一篇文章中总结。。</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (file) &#123;</span><span class="hljs-pattern-match">mask = <span class="hljs-constructor">DEFAULT_POLLMASK</span>;</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (file-&gt;f<span class="hljs-constructor">_op</span> <span class="hljs-operator">&amp;&amp;</span> file-&gt;f<span class="hljs-constructor">_op</span>-&gt;poll)</span><span class="hljs-pattern-match">mask = file-&gt;f<span class="hljs-constructor">_op</span>-&gt;poll(file, wait);</span><span class="hljs-pattern-match">fput(file);</span><span class="hljs-pattern-match">&#125;</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>retval记录一共有几个事件就绪</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>将询问的输入结果汇集到fds所指的fd<span class="hljs-constructor">_set_bits</span>变量中</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> ((mask &amp; <span class="hljs-constructor">POLLIN_SET</span>) <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-constructor">ISSET(<span class="hljs-params">bit</span>, <span class="hljs-params">__IN</span>(<span class="hljs-params">fds</span>,<span class="hljs-params">off</span>)</span>)) &#123;</span><span class="hljs-pattern-match"><span class="hljs-constructor">SET(<span class="hljs-params">bit</span>, <span class="hljs-params">__RES_IN</span>(<span class="hljs-params">fds</span>,<span class="hljs-params">off</span>)</span>);</span><span class="hljs-pattern-match">retval<span class="hljs-operator">++</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>记录一共有多少个事件就绪</span><span class="hljs-pattern-match">wait = <span class="hljs-constructor">NULL</span>;</span><span class="hljs-pattern-match">&#125;</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>将询问的输出结果汇集到fds所指的fd<span class="hljs-constructor">_set_bits</span>变量中</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> ((mask &amp; <span class="hljs-constructor">POLLOUT_SET</span>) <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-constructor">ISSET(<span class="hljs-params">bit</span>, <span class="hljs-params">__OUT</span>(<span class="hljs-params">fds</span>,<span class="hljs-params">off</span>)</span>)) &#123;</span><span class="hljs-pattern-match"><span class="hljs-constructor">SET(<span class="hljs-params">bit</span>, <span class="hljs-params">__RES_OUT</span>(<span class="hljs-params">fds</span>,<span class="hljs-params">off</span>)</span>);</span><span class="hljs-pattern-match">retval<span class="hljs-operator">++</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>记录一共有多少个事件就绪</span><span class="hljs-pattern-match">wait = <span class="hljs-constructor">NULL</span>;</span><span class="hljs-pattern-match">&#125;</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>将询问的异常结果汇集到fds所指的fd<span class="hljs-constructor">_set_bits</span>变量中</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> ((mask &amp; <span class="hljs-constructor">POLLEX_SET</span>) <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-constructor">ISSET(<span class="hljs-params">bit</span>, <span class="hljs-params">__EX</span>(<span class="hljs-params">fds</span>,<span class="hljs-params">off</span>)</span>)) &#123;</span><span class="hljs-pattern-match"><span class="hljs-constructor">SET(<span class="hljs-params">bit</span>, <span class="hljs-params">__RES_EX</span>(<span class="hljs-params">fds</span>,<span class="hljs-params">off</span>)</span>);</span><span class="hljs-pattern-match">retval<span class="hljs-operator">++</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>记录一共有多少个事件就绪</span><span class="hljs-pattern-match">wait = <span class="hljs-constructor">NULL</span>;</span><span class="hljs-pattern-match">&#125;</span><span class="hljs-pattern-match">&#125;</span><span class="hljs-pattern-match">wait = <span class="hljs-constructor">NULL</span>;</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>对所有的文件描述符进行询问后，检查是否有事件就绪、睡眠等待时间超时、接收到了信号，如果有条件满足，就不会再进入睡眠状态，直接结束大循环</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>统计好就绪事件后，此时retval不为0，从break跳出，结束大循环</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (retval <span class="hljs-operator">||</span> !<span class="hljs-constructor">__timeout</span> <span class="hljs-operator">||</span> signal<span class="hljs-constructor">_pending(<span class="hljs-params">current</span>)</span>)</span><span class="hljs-pattern-match">break;</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>检查是否出错，如果出错，也不会进入睡眠状态，直接结束大循环</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span>(table.error) &#123;</span><span class="hljs-pattern-match">retval = table.error;</span><span class="hljs-pattern-match">break;</span><span class="hljs-pattern-match">&#125;</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>进入睡眠状态，被唤醒后再进行一次扫描询问</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>除第一次以外，以后都是在进程被唤醒时才执行一遍循环，从本质上讲是一种<span class="hljs-keyword">do</span>-<span class="hljs-keyword">while</span>循环</span><span class="hljs-pattern-match"><span class="hljs-constructor">__timeout</span> = schedule<span class="hljs-constructor">_timeout(<span class="hljs-params">__timeout</span>)</span>;</span><span class="hljs-pattern-match">&#125;</span><span class="hljs-pattern-match">current-&gt;state = <span class="hljs-constructor">TASK_RUNNING</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>设置当前进程的状态为运行态</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>将所有进程对应的wait<span class="hljs-constructor">_queue_t</span>结构从各个等待队列中删除</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>poll<span class="hljs-constructor">_freewait</span>定义在下面</span><span class="hljs-pattern-match">poll<span class="hljs-constructor">_freewait(&amp;<span class="hljs-params">table</span>)</span>;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">*</span></span><span class="hljs-pattern-match"> <span class="hljs-operator">*</span> <span class="hljs-constructor">Up</span>-<span class="hljs-keyword">to</span>-date the caller timeout.</span><span class="hljs-pattern-match"> <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><span class="hljs-pattern-match"><span class="hljs-operator">*</span>timeout = <span class="hljs-constructor">__timeout</span>;</span><span class="hljs-pattern-match">return retval; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>返回就绪事件的总数</span><span class="hljs-pattern-match">&#125;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match">static void <span class="hljs-operator">*</span>select<span class="hljs-constructor">_bits_alloc(<span class="hljs-params">int</span> <span class="hljs-params">size</span>)</span></span><span class="hljs-pattern-match">&#123;</span><span class="hljs-pattern-match">return kmalloc(6 <span class="hljs-operator">*</span> size, <span class="hljs-constructor">GFP_KERNEL</span>); <span class="hljs-operator">/</span><span class="hljs-operator">/</span>通过kmalloc分配6个位图</span><span class="hljs-pattern-match">&#125;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match">static void select<span class="hljs-constructor">_bits_free(<span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">bits</span>, <span class="hljs-params">int</span> <span class="hljs-params">size</span>)</span></span><span class="hljs-pattern-match">&#123;</span><span class="hljs-pattern-match">kfree(bits);</span><span class="hljs-pattern-match">&#125;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">*</span></span><span class="hljs-pattern-match"> <span class="hljs-operator">*</span> <span class="hljs-constructor">We</span> can actually return <span class="hljs-constructor">ERESTARTSYS</span> instead <span class="hljs-keyword">of</span> <span class="hljs-constructor">EINTR</span>, but <span class="hljs-constructor">I</span>'d</span><span class="hljs-pattern-match"> <span class="hljs-operator">*</span> like <span class="hljs-keyword">to</span> be certain this leads <span class="hljs-keyword">to</span> no problems. <span class="hljs-constructor">So</span> <span class="hljs-constructor">I</span> return</span><span class="hljs-pattern-match"> <span class="hljs-operator">*</span> <span class="hljs-constructor">EINTR</span> just for safety.</span><span class="hljs-pattern-match"> <span class="hljs-operator">*</span></span><span class="hljs-pattern-match"> <span class="hljs-operator">*</span> <span class="hljs-constructor">Update</span>: <span class="hljs-constructor">ERESTARTSYS</span> breaks at least the xview clock binary, so</span><span class="hljs-pattern-match"> <span class="hljs-operator">*</span> <span class="hljs-constructor">I</span>'m trying <span class="hljs-constructor">ERESTARTNOHAND</span> which restart only <span class="hljs-keyword">when</span> you want <span class="hljs-keyword">to</span>.</span><span class="hljs-pattern-match"> <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><span class="hljs-pattern-match">#define <span class="hljs-constructor">MAX_SELECT_SECONDS</span> \</span><span class="hljs-pattern-match">((unsigned long) (<span class="hljs-constructor">MAX_SCHEDULE_TIMEOUT</span> <span class="hljs-operator">/</span> <span class="hljs-constructor">HZ</span>)-1)</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>n表示调用时的参数表中一共有多少个位图，即需要监听的文件描述符最大值，一般为最大值加1</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>fd<span class="hljs-constructor">_set</span>类型结构在下面有解释说明</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>fd<span class="hljs-constructor">_set</span>表示已打开文件的位图，位图的每一位都代表着当前进程的一个已打开文件，根据其结构定义得知，select最多可以监听1024个文件描述符</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>timeval类型结构在下面有解释说明</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>tvp表示睡眠等待的最长时间，如果为0则表示立即返回，如果为<span class="hljs-constructor">NULL</span>则表示阻塞等待，直到所监听的事件就绪</span><span class="hljs-pattern-match">asmlinkage long</span><span class="hljs-pattern-match">sys<span class="hljs-constructor">_select(<span class="hljs-params">int</span> <span class="hljs-params">n</span>, <span class="hljs-params">fd_set</span> <span class="hljs-operator">*</span><span class="hljs-params">inp</span>, <span class="hljs-params">fd_set</span> <span class="hljs-operator">*</span><span class="hljs-params">outp</span>, <span class="hljs-params">fd_set</span> <span class="hljs-operator">*</span><span class="hljs-params">exp</span>, <span class="hljs-params">struct</span> <span class="hljs-params">timeval</span> <span class="hljs-operator">*</span><span class="hljs-params">tvp</span>)</span></span><span class="hljs-pattern-match">&#123;</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>fd<span class="hljs-constructor">_set_bits</span>类型结构在下面有解释说明</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>其中分别保存了3种位图的要求和结果</span><span class="hljs-pattern-match">fd<span class="hljs-constructor">_set_bits</span> fds;</span><span class="hljs-pattern-match"><span class="hljs-built_in">char</span> <span class="hljs-operator">*</span>bits;</span><span class="hljs-pattern-match">long timeout;</span><span class="hljs-pattern-match"><span class="hljs-built_in">int</span> ret, size;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match">timeout = <span class="hljs-constructor">MAX_SCHEDULE_TIMEOUT</span>;</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (tvp) &#123;</span><span class="hljs-pattern-match">time<span class="hljs-constructor">_t</span> sec, usec;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>将所需数据数据从用户空间拷贝到内核空间</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> ((ret = verify<span class="hljs-constructor">_area(VERIFY_READ, <span class="hljs-params">tvp</span>, <span class="hljs-params">sizeof</span>(<span class="hljs-operator">*</span><span class="hljs-params">tvp</span>)</span>))</span><span class="hljs-pattern-match">    <span class="hljs-operator">||</span> (ret = <span class="hljs-constructor">__get_user(<span class="hljs-params">sec</span>, &amp;<span class="hljs-params">tvp</span>-&gt;<span class="hljs-params">tv_sec</span>)</span>)</span><span class="hljs-pattern-match">    <span class="hljs-operator">||</span> (ret = <span class="hljs-constructor">__get_user(<span class="hljs-params">usec</span>, &amp;<span class="hljs-params">tvp</span>-&gt;<span class="hljs-params">tv_usec</span>)</span>))</span><span class="hljs-pattern-match">goto out<span class="hljs-constructor">_nofds</span>;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match">ret = -<span class="hljs-constructor">EINVAL</span>;</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (sec &lt; 0 <span class="hljs-operator">||</span> usec &lt; 0)</span><span class="hljs-pattern-match">goto out<span class="hljs-constructor">_nofds</span>;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> ((unsigned long) sec &lt; <span class="hljs-constructor">MAX_SELECT_SECONDS</span>) &#123;</span><span class="hljs-pattern-match">timeout = <span class="hljs-constructor">ROUND_UP(<span class="hljs-params">usec</span>, 1000000<span class="hljs-operator">/</span>HZ)</span>;</span><span class="hljs-pattern-match">timeout += sec <span class="hljs-operator">*</span> (unsigned long) <span class="hljs-constructor">HZ</span>;</span><span class="hljs-pattern-match">&#125;</span><span class="hljs-pattern-match">&#125;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match">ret = -<span class="hljs-constructor">EINVAL</span>;</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (n &lt; 0)</span><span class="hljs-pattern-match">goto out<span class="hljs-constructor">_nofds</span>;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>判断文件描述符数量有没有超过最大值</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (n &gt; current-&gt;files-&gt;max<span class="hljs-constructor">_fdset</span>)</span><span class="hljs-pattern-match">n = current-&gt;files-&gt;max<span class="hljs-constructor">_fdset</span>;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">*</span></span><span class="hljs-pattern-match"> <span class="hljs-operator">*</span> <span class="hljs-constructor">We</span> need 6 bitmaps (<span class="hljs-keyword">in</span><span class="hljs-operator">/</span>out<span class="hljs-operator">/</span>ex for both incoming <span class="hljs-keyword">and</span> outgoing),</span><span class="hljs-pattern-match"> <span class="hljs-operator">*</span> since we used fdset we need <span class="hljs-keyword">to</span> allocate memory <span class="hljs-keyword">in</span> units <span class="hljs-keyword">of</span></span><span class="hljs-pattern-match"> <span class="hljs-operator">*</span> long-words. </span><span class="hljs-pattern-match"> <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><span class="hljs-pattern-match">ret = -<span class="hljs-constructor">ENOMEM</span>;</span><span class="hljs-pattern-match">size = <span class="hljs-constructor">FDS_BYTES(<span class="hljs-params">n</span>)</span>;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>select<span class="hljs-constructor">_bits_alloc</span>定义在上面</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>一共分配6个位图</span><span class="hljs-pattern-match">bits = select<span class="hljs-constructor">_bits_alloc(<span class="hljs-params">size</span>)</span>;</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>为要求和结果，一共6个位图初始化</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (!bits)</span><span class="hljs-pattern-match">goto out<span class="hljs-constructor">_nofds</span>;</span><span class="hljs-pattern-match">fds.<span class="hljs-keyword">in</span>      = (unsigned long <span class="hljs-operator">*</span>)  bits;</span><span class="hljs-pattern-match">fds.out     = (unsigned long <span class="hljs-operator">*</span>) (bits +   size);</span><span class="hljs-pattern-match">fds.ex      = (unsigned long <span class="hljs-operator">*</span>) (bits + 2<span class="hljs-operator">*</span>size);</span><span class="hljs-pattern-match">fds.res<span class="hljs-constructor">_in</span>  = (unsigned long <span class="hljs-operator">*</span>) (bits + 3<span class="hljs-operator">*</span>size);</span><span class="hljs-pattern-match">fds.res<span class="hljs-constructor">_out</span> = (unsigned long <span class="hljs-operator">*</span>) (bits + 4<span class="hljs-operator">*</span>size);</span><span class="hljs-pattern-match">fds.res<span class="hljs-constructor">_ex</span>  = (unsigned long <span class="hljs-operator">*</span>) (bits + 5<span class="hljs-operator">*</span>size);</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>将3个要求位图从用户空间复制到内核空间中的fds的要求位图</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> ((ret = get<span class="hljs-constructor">_fd_set(<span class="hljs-params">n</span>, <span class="hljs-params">inp</span>, <span class="hljs-params">fds</span>.<span class="hljs-params">in</span>)</span>) <span class="hljs-operator">||</span></span><span class="hljs-pattern-match">    (ret = get<span class="hljs-constructor">_fd_set(<span class="hljs-params">n</span>, <span class="hljs-params">outp</span>, <span class="hljs-params">fds</span>.<span class="hljs-params">out</span>)</span>) <span class="hljs-operator">||</span></span><span class="hljs-pattern-match">    (ret = get<span class="hljs-constructor">_fd_set(<span class="hljs-params">n</span>, <span class="hljs-params">exp</span>, <span class="hljs-params">fds</span>.<span class="hljs-params">ex</span>)</span>))</span><span class="hljs-pattern-match">goto out;</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>将内核空间的fds的结果位图初始化为0</span><span class="hljs-pattern-match">zero<span class="hljs-constructor">_fd_set(<span class="hljs-params">n</span>, <span class="hljs-params">fds</span>.<span class="hljs-params">res_in</span>)</span>;</span><span class="hljs-pattern-match">zero<span class="hljs-constructor">_fd_set(<span class="hljs-params">n</span>, <span class="hljs-params">fds</span>.<span class="hljs-params">res_out</span>)</span>;</span><span class="hljs-pattern-match">zero<span class="hljs-constructor">_fd_set(<span class="hljs-params">n</span>, <span class="hljs-params">fds</span>.<span class="hljs-params">res_ex</span>)</span>;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>好戏开始。。。<span class="hljs-keyword">do</span><span class="hljs-constructor">_select</span>定义在上面。。。→<span class="hljs-constructor">_</span>→</span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> ret记录就绪事件的总数</span><span class="hljs-pattern-match">ret = <span class="hljs-keyword">do</span><span class="hljs-constructor">_select(<span class="hljs-params">n</span>, &amp;<span class="hljs-params">fds</span>, &amp;<span class="hljs-params">timeout</span>)</span>;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (tvp <span class="hljs-operator">&amp;&amp;</span> !(current-&gt;personality &amp; <span class="hljs-constructor">STICKY_TIMEOUTS</span>)) &#123;</span><span class="hljs-pattern-match">time<span class="hljs-constructor">_t</span> sec = 0, usec = 0;</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (timeout) &#123;</span><span class="hljs-pattern-match">sec = timeout <span class="hljs-operator">/</span> <span class="hljs-constructor">HZ</span>;</span><span class="hljs-pattern-match">usec = timeout % <span class="hljs-constructor">HZ</span>;</span><span class="hljs-pattern-match">usec <span class="hljs-operator">*</span>= (1000000<span class="hljs-operator">/</span><span class="hljs-constructor">HZ</span>);</span><span class="hljs-pattern-match">&#125;</span><span class="hljs-pattern-match">put<span class="hljs-constructor">_user(<span class="hljs-params">sec</span>, &amp;<span class="hljs-params">tvp</span>-&gt;<span class="hljs-params">tv_sec</span>)</span>;</span><span class="hljs-pattern-match">put<span class="hljs-constructor">_user(<span class="hljs-params">usec</span>, &amp;<span class="hljs-params">tvp</span>-&gt;<span class="hljs-params">tv_usec</span>)</span>;</span><span class="hljs-pattern-match">&#125;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (ret &lt; 0)</span><span class="hljs-pattern-match">goto out;</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (!ret) &#123;</span><span class="hljs-pattern-match">ret = -<span class="hljs-constructor">ERESTARTNOHAND</span>;</span><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> (signal<span class="hljs-constructor">_pending(<span class="hljs-params">current</span>)</span>)</span><span class="hljs-pattern-match">goto out;</span><span class="hljs-pattern-match">ret = 0;</span><span class="hljs-pattern-match">&#125;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>将3个结果位图的内容复制到用户空间中</span><span class="hljs-pattern-match">set<span class="hljs-constructor">_fd_set(<span class="hljs-params">n</span>, <span class="hljs-params">inp</span>, <span class="hljs-params">fds</span>.<span class="hljs-params">res_in</span>)</span>; </span><span class="hljs-pattern-match">set<span class="hljs-constructor">_fd_set(<span class="hljs-params">n</span>, <span class="hljs-params">outp</span>, <span class="hljs-params">fds</span>.<span class="hljs-params">res_out</span>)</span>;</span><span class="hljs-pattern-match">set<span class="hljs-constructor">_fd_set(<span class="hljs-params">n</span>, <span class="hljs-params">exp</span>, <span class="hljs-params">fds</span>.<span class="hljs-params">res_ex</span>)</span>;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match">out:</span><span class="hljs-pattern-match">select<span class="hljs-constructor">_bits_free(<span class="hljs-params">bits</span>, <span class="hljs-params">size</span>)</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>释放要求和结果位图的6个位图的空间</span><span class="hljs-pattern-match">out<span class="hljs-constructor">_nofds</span>:</span><span class="hljs-pattern-match">return ret; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>返回就绪事件的总数</span><span class="hljs-pattern-match">&#125;</span></code></pre><pre><code class="hljs cpp"><span class="hljs-comment">// linux-2.4.0\include\linux\\Poll.h</span><span class="hljs-comment">//记录要求的3个位图和结果的3个位图</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *in, *out, *ex; <span class="hljs-comment">//要求</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *res_in, *res_out, *res_ex; <span class="hljs-comment">//结果</span>&#125; fd_set_bits;</code></pre><pre><code class="hljs cpp"><span class="hljs-comment">//linux-2.4.0\include\linux\Time.h</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> &#123;</span><span class="hljs-keyword">time_t</span>tv_sec;<span class="hljs-comment">/* 秒数 seconds */</span><span class="hljs-keyword">suseconds_t</span>tv_usec;<span class="hljs-comment">/* 微秒数 microseconds */</span>&#125;;</code></pre><pre><code class="hljs cpp"><span class="hljs-comment">//fd_set类型的定义</span><span class="hljs-comment">//linux-2.4.0\include\linux\Posix_types.h</span><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> __NFDBITS</span><span class="hljs-comment">//__NFDBITS的值为32</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NFDBITS(8 * sizeof(unsigned long))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> __FD_SETSIZE</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __FD_SETSIZE1024</span><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> __FDSET_LONGS</span><span class="hljs-comment">//__FDSET_LONGS的值为32</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __FDSET_LONGS(__FD_SETSIZE/__NFDBITS)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> __FDELT</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>__FDELT(d)((d) / __NFDBITS)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> __FDMASK</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>__FDMASK(d)(1UL &lt;&lt; ((d) % __NFDBITS))</span><span class="hljs-comment">//因此fd_set实际上是一个具有32个元素的unsigned long类型的数组</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> fds_bits [__FDSET_LONGS];&#125; __kernel_fd_set;<span class="hljs-keyword">typedef</span> __kernel_fd_setfd_set;</code></pre><pre><code class="hljs cpp"><span class="hljs-comment">//linux-2.4.0\include\linux\Poll.h</span><span class="hljs-comment">//poll_table_page类型结构在下面有解释说明</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_struct</span> &#123;</span><span class="hljs-keyword">int</span> error;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_page</span> * <span class="hljs-title">table</span>;</span>&#125; poll_table;</code></pre><pre><code class="hljs cpp"><span class="hljs-comment">//linux-2.4.0\fs\Select.c</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_entry</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">filp</span>;</span><span class="hljs-keyword">wait_queue_t</span> wait; <span class="hljs-comment">//被封装的wait_queue_t</span><span class="hljs-keyword">wait_queue_head_t</span> * wait_address; <span class="hljs-comment">//等待队列的队头</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_page</span> &#123;</span><span class="hljs-comment">//一个页面用完了就再分配一个，通过next链成一条单链</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_page</span> * <span class="hljs-title">next</span>;</span><span class="hljs-comment">//poll_table_entry类型结构上面有解释说明</span><span class="hljs-comment">//entry总是指向entries中第一个空闲的poll_table_entry结构，根据需要动态的分配entries中的表项</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_entry</span> * <span class="hljs-title">entry</span>;</span><span class="hljs-comment">//表示该数组可以动态地确定大小，实际使用中分配一个页面，页面中能容纳几个poll_table_entry，这个数组就有多大</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_entry</span> <span class="hljs-title">entries</span>[0];</span> &#125;;</code></pre><pre><code class="hljs reasonml"><span class="hljs-comment">//linux-2.4.0\fs\Select.c</span>void poll<span class="hljs-constructor">_freewait(<span class="hljs-params">poll_table</span><span class="hljs-operator">*</span> <span class="hljs-params">pt</span>)</span>&#123;<span class="hljs-keyword">struct</span> poll_table_page<span class="hljs-operator"> * </span>p = pt-&gt;table; <span class="hljs-comment">//p指向第一个poll_table_page结构，poll_table_page结构由next成员链成单链</span><span class="hljs-comment">//当p不为NULL时，继续循环</span><span class="hljs-keyword">while</span> (p) &#123;<span class="hljs-keyword">struct</span> poll_table_entry<span class="hljs-operator"> * </span>entry;<span class="hljs-keyword">struct</span> poll_table_page *old;entry = p-&gt;entry; <span class="hljs-comment">//entry指向entries中第一个空闲的poll_table_entry结构，entries是一个数组</span><span class="hljs-keyword">do</span> &#123;entry--; <span class="hljs-comment">//entry前移</span>remove<span class="hljs-constructor">_wait_queue(<span class="hljs-params">entry</span>-&gt;<span class="hljs-params">wait_address</span>,&amp;<span class="hljs-params">entry</span>-&gt;<span class="hljs-params">wait</span>)</span>; <span class="hljs-comment">//将entry表示的wait_queue_t结构从等待队列中删除</span>fput(entry-&gt;filp);&#125; <span class="hljs-keyword">while</span> (entry &gt; p-&gt;entries); <span class="hljs-comment">//判断此entries数组中是否还有元素未删除</span>old = p; <span class="hljs-comment">//此时poll_table_page结构中的entries数组中已没有元素，此时old记录当前poll_table_page 结构</span>p = p-&gt;next; <span class="hljs-comment">//p指向下一个poll_table_page 结构</span>free<span class="hljs-constructor">_page((<span class="hljs-params">unsigned</span> <span class="hljs-params">long</span>)</span> old); <span class="hljs-comment">//释放old所指向的poll_table_page结构页面</span>&#125;&#125;</code></pre><p><strong>* <em>哇。。。终于分析完了！！！一会儿直接上poll操作的源码分析和select的应用实例。。。→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx中的负载均衡</title>
    <link href="/2020/07/01/load-balancing-in-nginx/"/>
    <url>/2020/07/01/load-balancing-in-nginx/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>快马加鞭。。。再看看Nginx中的负载均衡是如何实现的。。。轮询。。。？一致性哈希。。。？→_→</em> *</strong></p><ul><li><p>在Nginx中<strong>每一个worker进程都有一个自己的ngx_accept_disabled</strong>，它就是实现负载均衡机制的关键阈值</p>  <pre><code class="hljs cpp"><span class="hljs-keyword">ngx_int_t</span>ngx_accept_disabled;<span class="hljs-comment">//整形</span></code></pre></li><li><p>在Nginx启动时，<strong>初始化ngx_accept_disabled为一个负数，其值为连接总数的7/8</strong></p>  <pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">ngx_accept_disabled</span> = ngx_cycle-&gt;</span>connection_n / <span class="hljs-number">8</span>                              - <span class="hljs-function"><span class="hljs-title">ngx_cycle</span>-&gt;</span>free_connection_n;</code></pre></li><li><p><strong>当ngx_accept_disabled为负数时触发负载均衡，而当ngx_accept_disabled为正数时就会触发负载均衡了</strong></p>  <pre><code class="hljs gauss"><span class="hljs-comment">//当ngx_accept_disabled大于0时，当前worker进程不再处理新连接事件，而是将ngx_accept_disabled只将减1</span><span class="hljs-keyword">if</span> (ngx_accept_disabled &gt; <span class="hljs-number">0</span>) &#123;            ngx_accept_disabled--;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ngx_trylock_accept_mutex</span>(cycle) == NGX_ERROR) &#123;                <span class="hljs-keyword">return</span>;            &#125;</code></pre></li><li><p>当<strong>ngx_accept_disabled大于0</strong>时，即<strong>当前使用的连接数到达总连接数的7/8</strong>时，就<strong>不会再处理新连接事件</strong>了，且每次调用ngx_process_events_and_timers时都会<strong>将ngx_accept_disabled减1</strong></p><p>  当<strong>ngx_accept_disabled小于等于0</strong>时，即<strong>当前使用的连接数没有到达总连接数的7/8</strong>时，才会<strong>调用ngx_trylock_accept_mutex试图去处理新的新的连接事件</strong></p></li><li><p><strong>Nginx中各个worker进程间的负载均衡仅在某个worker进程处理的连接数到达它的最大处理总数的7/8时才会触发，这时该worker进程就减少了处理新连接的机会，有助于其他空闲的worker进程有机会去处理更多的新连接</strong></p></li></ul><p><strong>* <em>码完收工。。。准备睡觉。。。→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx中的惊群现象解决方法</title>
    <link href="/2020/07/01/shock-group-phenomenon-in-Nginx/"/>
    <url>/2020/07/01/shock-group-phenomenon-in-Nginx/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>什么是惊群现象？Nginx中用了什么方法来避免这种问题的发生？本篇就解决这两个问题。。。→_→</em> *</strong></p><ol><li><p>惊群现象的定义与危害</p><ul><li><p><strong>在Nginx中，每一个worker进程都是由master进程fork出来的</strong>。master进程创建socket后进行listen、bind操作，<strong>fork出来的worker继承了socket</strong>，调用accpet开始监听等待网络连接</p></li><li><p><strong>如果这时有多个worker进程都在等待事件的发生。当事件发生时，这些worker进程被同时唤醒，但最终只有一个worker进程可以处理事件成功，其他的worker进程就会重新进入阻塞状态</strong></p></li><li><p><strong>当惊群现象发生时，内核会依次唤醒所有的worker进程，这种操作会导致系统在瞬时占用极大的资源，但最后却只有一个worker进程处理事件成功，这就造成了极大的资源浪费</strong></p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODA3MTc1MTA4ODUx?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="Nginx中的master-worker架构"></p></li></ul></li><li><p>Nginx中解决惊群现象的方法</p><ul><li>Nginx中规定同一时刻只能有唯一一个的worker进程监听Web端口，这样就不会发生惊群了，此时新连接事件只能唤醒唯一正在监听端口的worker进程</li></ul></li><li><p>源码剖析</p></li></ol><pre><code class="hljs cpp"><span class="hljs-keyword">ngx_int_t</span>ngx_trylock_accept_mutex(<span class="hljs-keyword">ngx_cycle_t</span> *cycle)&#123;<span class="hljs-comment">//使用worker进程间同步锁——ngx_accept_mutex，ngx_shmtx_trylock返回1表示成功获取锁，返回0表示获取锁失败。ngx_shmtx_trylock是非阻塞的，如果此时ngx_accept_mutex被其他worker进程占有，那么ngx_shmtx_trylock会立即返回</span>    <span class="hljs-keyword">if</span> (ngx_shmtx_trylock(&amp;ngx_accept_mutex)) &#123;        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,                       <span class="hljs-string">"accept mutex locked"</span>);                       <span class="hljs-comment">//ngx_accept_mutex_held为1时表示当前worker进程已经获取到了锁，那么就立即返回</span>        <span class="hljs-keyword">if</span> (ngx_accept_mutex_held            &amp;&amp; ngx_accept_events == <span class="hljs-number">0</span>            &amp;&amp; !(ngx_event_flags &amp; NGX_USE_RTSIG_EVENT))        &#123;            <span class="hljs-keyword">return</span> NGX_OK;        &#125;<span class="hljs-comment">//将所有监听连接的读事件添加到当前的epoll等事件驱动模块中</span>        <span class="hljs-keyword">if</span> (ngx_enable_accept_events(cycle) == NGX_ERROR) &#123;<span class="hljs-comment">//如果将所有监听连接的读事件添加到当前的epoll等事件驱动模块中失败，那么就必须释放ngx_accept_mutex锁</span>            ngx_shmtx_unlock(&amp;ngx_accept_mutex);            <span class="hljs-keyword">return</span> NGX_ERROR;        &#125;<span class="hljs-comment">//此时需要把ngx_accept_mutex_held置为1，方便本进程的其他驱动模块它已经获取到了锁</span>        ngx_accept_events = <span class="hljs-number">0</span>;        ngx_accept_mutex_held = <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> NGX_OK;    &#125;    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,                   <span class="hljs-string">"accept mutex lock failed: %ui"</span>, ngx_accept_mutex_held);<span class="hljs-comment">//此时ngx_shmtx_trylock返回了0，表示获取ngx_shmtx_trylock锁失败。但是此时ngx_accept_mutex_held还为1，即当前worker进程还在占有ngx_accept_mutex锁，就说明有问题</span>    <span class="hljs-keyword">if</span> (ngx_accept_mutex_held) &#123;    <span class="hljs-comment">//将所有监听连接的读事件从事件模块中移出</span>        <span class="hljs-keyword">if</span> (ngx_disable_accept_events(cycle) == NGX_ERROR) &#123;            <span class="hljs-keyword">return</span> NGX_ERROR;        &#125;<span class="hljs-comment">//没有获取到ngx_accept_mutex锁时，将ngx_accept_mutex_held置为0</span>        ngx_accept_mutex_held = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> NGX_OK;&#125;</code></pre><p><strong>* <em>本篇只分析了Nginx中如何保证不发生惊群现象的解决方法，后面其实还有worker进程何时释放ngx_accept_mutex锁的问题。。其超出了本篇的范围。。。就不在这里继续讨论了。。明天加油。。。→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核中的互斥操作（3）——读写锁</title>
    <link href="/2020/07/01/read-write-lock/"/>
    <url>/2020/07/01/read-write-lock/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>对内核中的信号量和自旋锁经过源码剖析后，再来看最后一个内核中的互斥操作——读写锁。。。→_→</em> *</strong></p><ol><li><p><strong>初始化读写锁</strong></p><ul><li><p><strong>读写锁的类型定义</strong></p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-comment">//不调试时，读写锁实际上就是一个无符号整形。通过下面的代码还可以看出其实质就是一个计数器</span><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> lock;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SPINLOCK_DEBUG</span><span class="hljs-keyword">unsigned</span> magic;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>&#125; <span class="hljs-keyword">rwlock_t</span>;</code></pre></li><li><p><strong>rwlock_init()源代码</strong></p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RW_LOCK_BIAS 0x01000000</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RW_LOCK_BIAS_STR<span class="hljs-meta-string">"0x01000000"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RWLOCK_MAGIC0xdeaf1eed</span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SPINLOCK_DEBUG</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RWLOCK_MAGIC_INIT, RWLOCK_MAGIC</span><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RWLOCK_MAGIC_INIT<span class="hljs-comment">/* */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RW_LOCK_UNLOCKED (rwlock_t) &#123; RW_LOCK_BIAS RWLOCK_MAGIC_INIT &#125;</span><span class="hljs-comment">//初始化读写锁时，将读写锁的lock初始化为0x01000000</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rwlock_init(x)do &#123; *(x) = RW_LOCK_UNLOCKED; &#125; while(0)</span></code></pre></li></ul></li><li><p><strong>内核中的read_lock()</strong></p><ul><li><p><strong>read_lock()源代码</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read_lock</span><span class="hljs-params">(<span class="hljs-keyword">rwlock_t</span> *rw)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SPINLOCK_DEBUG</span><span class="hljs-keyword">if</span> (rw-&gt;magic != RWLOCK_MAGIC)BUG();<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-comment">//第一个参数为读写锁指针，第二个为获取读锁失败时的处理函数的函数指针</span>__build_read_lock(rw, <span class="hljs-string">"__read_lock_failed"</span>);&#125;</code></pre></li><li><p><strong>__build_read_lock()源代码</strong></p><pre><code class="hljs reasonml">#define <span class="hljs-constructor">__build_read_lock(<span class="hljs-params">rw</span>, <span class="hljs-params">helper</span>)</span><span class="hljs-keyword">do</span> &#123; \<span class="hljs-comment">//是编译器gcc的内置函数，用于判断一个值是否为编译时常量，如果是常数，函数返回1，否则返回0</span><span class="hljs-keyword">if</span> (<span class="hljs-constructor">__builtin_constant_p(<span class="hljs-params">rw</span>)</span>) \ <span class="hljs-constructor">__build_read_lock_const(<span class="hljs-params">rw</span>, <span class="hljs-params">helper</span>)</span>; \<span class="hljs-keyword">else</span> \<span class="hljs-constructor">__build_read_lock_ptr(<span class="hljs-params">rw</span>, <span class="hljs-params">helper</span>)</span>; \&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)</code></pre></li><li><p><strong><strong>build_read_lock_const()与</strong>build_read_lock_ptr()源代码</strong></p><pre><code class="hljs livescript"><span class="hljs-comment">#define __build_read_lock_ptr(rw, helper)   \</span><span class="hljs-regexp">//锁总线，将rw减1，判断结果的符号位是否为1，若符号位为0则获取读锁成功并返回</span><span class="hljs-regexp">asm volatile(LOCK "subl $1,(%0)\n\t" \ </span><span class="hljs-regexp">     "js 2f\n" \</span><span class="hljs-regexp">     "1:\n" \</span><span class="hljs-regexp">     ".section .text.lock,\"ax\"\n" \</span><span class="hljs-regexp">     //</span>若符号位为<span class="hljs-number">1</span>则获取读锁失败，调用失败处理函数helper     <span class="hljs-string">"2:\tcall "</span> helper <span class="hljs-string">"\n\t"</span> <span class="hljs-string">\</span>     <span class="hljs-string">"jmp 1b\n"</span> <span class="hljs-string">\</span>     <span class="hljs-string">".previous"</span> <span class="hljs-string">\</span>     ::<span class="hljs-string">"a"</span> (rw) : <span class="hljs-string">"memory"</span>)<span class="hljs-comment">#define __build_read_lock_const(rw, helper)   \</span>asm volatile(LOCK <span class="hljs-string">"subl $1,%0\n\t"</span> <span class="hljs-string">\</span>     <span class="hljs-string">"js 2f\n"</span> <span class="hljs-string">\</span>     <span class="hljs-string">"1:\n"</span> <span class="hljs-string">\</span>     <span class="hljs-string">".section .text.lock,\"ax\"\n"</span> <span class="hljs-string">\</span>     <span class="hljs-string">"2:\tpushl %%eax\n\t"</span> <span class="hljs-string">\</span>     <span class="hljs-string">"leal %0,%%eax\n\t"</span> <span class="hljs-string">\</span>     <span class="hljs-string">"call "</span> helper <span class="hljs-string">"\n\t"</span> <span class="hljs-string">\</span>     <span class="hljs-string">"popl %%eax\n\t"</span> <span class="hljs-string">\</span>     <span class="hljs-string">"jmp 1b\n"</span> <span class="hljs-string">\</span>     <span class="hljs-string">".previous"</span> <span class="hljs-string">\</span>     :<span class="hljs-string">"=m"</span> (*(volatile int *)rw) : : <span class="hljs-string">"memory"</span>)</code></pre></li><li><p><strong>__read_lock_failed()源代码</strong></p><pre><code class="hljs less"><span class="hljs-selector-id">#if</span> <span class="hljs-selector-tag">defined</span>(CONFIG_SMP)<span class="hljs-selector-tag">asm</span>(".align<span class="hljs-number">4</span>.globl__read_lock_failed<span class="hljs-attribute">__read_lock_failed</span>:lock ; incl(%eax) <span class="hljs-comment">//锁总线，将rw加1</span><span class="hljs-number">1</span>:cmpl$<span class="hljs-number">1</span>,(%eax) <span class="hljs-comment">//判断结果是否小于1</span>js<span class="hljs-number">1</span>b <span class="hljs-comment">//若符号位为1，则继续循环测试rw的值</span>lock ; decl(%eax) <span class="hljs-comment">//若结果大于等于1，锁总线，将rw减1</span>js__read_lock_failed<span class="hljs-comment">//判断结果的符号位是否为0，若为1，继续循环测试rw的值</span>ret<span class="hljs-comment">//否则返回</span>");<span class="hljs-selector-id">#endif</span></code></pre></li></ul></li><li><p><strong>内核中的read_unlock()</strong></p><ul><li><p><strong>read_unlock()源代码</strong></p><pre><code class="hljs less"><span class="hljs-comment">//锁总线，将读写锁的计数加1</span><span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">read_unlock</span>(rw)<span class="hljs-selector-tag">asm</span> <span class="hljs-selector-tag">volatile</span>(<span class="hljs-string">"lock ; incl %0"</span> :<span class="hljs-string">"=m"</span> ((rw)-&gt;lock) : : <span class="hljs-string">"memory"</span>)</code></pre></li></ul></li><li><p><strong>内核中的write_lock()</strong></p><ul><li><p><strong>write_lock()源代码</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write_lock</span><span class="hljs-params">(<span class="hljs-keyword">rwlock_t</span> *rw)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SPINLOCK_DEBUG</span><span class="hljs-keyword">if</span> (rw-&gt;magic != RWLOCK_MAGIC)BUG();<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>__build_write_lock(rw, <span class="hljs-string">"__write_lock_failed"</span>);<span class="hljs-comment">//第一个参数为写锁，第二参数为获取写锁失败时的处理函数的函数指针</span>&#125;</code></pre></li><li><p><strong>__build_write_lock()源代码</strong></p><pre><code class="hljs reasonml"><span class="hljs-comment">//格式同__build_read_lock()</span>#define <span class="hljs-constructor">__build_write_lock(<span class="hljs-params">rw</span>, <span class="hljs-params">helper</span>)</span><span class="hljs-keyword">do</span> &#123; \<span class="hljs-keyword">if</span> (<span class="hljs-constructor">__builtin_constant_p(<span class="hljs-params">rw</span>)</span>) \<span class="hljs-constructor">__build_write_lock_const(<span class="hljs-params">rw</span>, <span class="hljs-params">helper</span>)</span>; \<span class="hljs-keyword">else</span> \<span class="hljs-constructor">__build_write_lock_ptr(<span class="hljs-params">rw</span>, <span class="hljs-params">helper</span>)</span>; \&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)</code></pre></li></ul></li></ol><ul><li><p><strong><strong>build_write_lock_const()和</strong>build_write_lock_ptr()源代码</strong></p>  <pre><code class="hljs livescript"><span class="hljs-comment">#define __build_write_lock_ptr(rw, helper) \</span><span class="hljs-regexp">//锁总线，将rw减RW_LOCK_BIAS_STR，即rw减0x01000000，判断结果是否为0，若为0则获取写锁成功并返回</span><span class="hljs-regexp">asm volatile(LOCK "subl $" RW_LOCK_BIAS_STR ",(%0)\n\t" \</span><span class="hljs-regexp">     "jnz 2f\n" \</span><span class="hljs-regexp">     "1:\n" \</span><span class="hljs-regexp">     ".section .text.lock,\"ax\"\n" \</span><span class="hljs-regexp">     //</span>若结果不为<span class="hljs-number">0</span>则获取写锁失败，调用失败处理函数helper     <span class="hljs-string">"2:\tcall "</span> helper <span class="hljs-string">"\n\t"</span> <span class="hljs-string">\</span>     <span class="hljs-string">"jmp 1b\n"</span> <span class="hljs-string">\</span>     <span class="hljs-string">".previous"</span> <span class="hljs-string">\</span>     ::<span class="hljs-string">"a"</span> (rw) : <span class="hljs-string">"memory"</span>)<span class="hljs-comment">#define __build_write_lock_const(rw, helper) \</span>asm volatile(LOCK <span class="hljs-string">"subl $"</span> RW_LOCK_BIAS_STR <span class="hljs-string">",(%0)\n\t"</span> <span class="hljs-string">\</span>     <span class="hljs-string">"jnz 2f\n"</span> <span class="hljs-string">\</span>     <span class="hljs-string">"1:\n"</span> <span class="hljs-string">\</span>     <span class="hljs-string">".section .text.lock,\"ax\"\n"</span> <span class="hljs-string">\</span>     <span class="hljs-string">"2:\tpushl %%eax\n\t"</span> <span class="hljs-string">\</span>     <span class="hljs-string">"leal %0,%%eax\n\t"</span> <span class="hljs-string">\</span>     <span class="hljs-string">"call "</span> helper <span class="hljs-string">"\n\t"</span> <span class="hljs-string">\</span>     <span class="hljs-string">"popl %%eax\n\t"</span> <span class="hljs-string">\</span>     <span class="hljs-string">"jmp 1b\n"</span> <span class="hljs-string">\</span>     <span class="hljs-string">".previous"</span> <span class="hljs-string">\</span>     :<span class="hljs-string">"=m"</span> (*(volatile int *)rw) : : <span class="hljs-string">"memory"</span>)</code></pre><ul><li><p><strong>__write_lock_failed源代码</strong></p><pre><code class="hljs 1c"><span class="hljs-meta">#if defined(CONFIG_SMP)</span>asm(<span class="hljs-string">"</span>.align<span class="hljs-number">4</span>.globl__write_lock_failed__write_lock_failed:<span class="hljs-string">" LOCK "</span>addl$<span class="hljs-string">" RW_LOCK_BIAS_STR "</span>,(%eax) <span class="hljs-comment">//锁总线，将rw加RW_LOCK_BIAS_STR，即rw加0x01000000</span><span class="hljs-number">1</span>:cmpl$<span class="hljs-string">" RW_LOCK_BIAS_STR "</span>,(%eax) <span class="hljs-comment">//判断结果是否小于RW_LOCK_BIAS_STR </span>jne<span class="hljs-number">1</span>b <span class="hljs-comment">//若结果不等于RW_LOCK_BIAS_STR ，则继续循环测试rw的值</span><span class="hljs-string">" LOCK "</span>subl$<span class="hljs-string">" RW_LOCK_BIAS_STR "</span>,(%eax) <span class="hljs-comment">//若结果等于RW_LOCK_BIAS_STR，锁总线，将rw减RW_LOCK_BIAS_STR </span>jnz__write_lock_failed <span class="hljs-comment">//判断结果是否等于0，若不等于0，则继续循环测试rw的值</span>ret <span class="hljs-comment">//否则返回</span><span class="hljs-meta">#endif</span></code></pre></li></ul></li></ul><ol start="5"><li><p><strong>内核中的write_unlock()</strong></p><ul><li><p><strong>write_unlock()源代码</strong></p><pre><code class="hljs less"><span class="hljs-comment">//锁总线，将读写锁的计数加RW_LOCK_BIAS_STR</span><span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">write_unlock</span>(rw)<span class="hljs-selector-tag">asm</span> <span class="hljs-selector-tag">volatile</span>(<span class="hljs-string">"lock ; addl $"</span> RW_LOCK_BIAS_STR <span class="hljs-string">",%0"</span>:<span class="hljs-string">"=m"</span> ((rw)-&gt;lock) : : <span class="hljs-string">"memory"</span>)</code></pre></li></ul></li><li><p><strong>内核中的读写锁具体应用的类型</strong></p><p> <strong>不同类型的异同见自旋锁中的分析——传送门请戳：</strong><a href="http://blog.csdn.net/kongkongkkk/article/details/76609933" target="_blank" rel="noopener"><strong>自旋锁</strong></a></p><ul><li><p><strong>获取读写锁的操作</strong></p><pre><code class="hljs reasonml">#define read<span class="hljs-constructor">_lock_irqsave(<span class="hljs-params">lock</span>, <span class="hljs-params">flags</span>)</span><span class="hljs-keyword">do</span> &#123; local<span class="hljs-constructor">_irq_save(<span class="hljs-params">flags</span>)</span>;       read<span class="hljs-constructor">_lock(<span class="hljs-params">lock</span>)</span>; &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)#define read<span class="hljs-constructor">_lock_irq(<span class="hljs-params">lock</span>)</span><span class="hljs-keyword">do</span> &#123; local<span class="hljs-constructor">_irq_disable()</span>;         read<span class="hljs-constructor">_lock(<span class="hljs-params">lock</span>)</span>; &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)#define read<span class="hljs-constructor">_lock_bh(<span class="hljs-params">lock</span>)</span><span class="hljs-keyword">do</span> &#123; local<span class="hljs-constructor">_bh_disable()</span>;          read<span class="hljs-constructor">_lock(<span class="hljs-params">lock</span>)</span>; &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)#define write<span class="hljs-constructor">_lock_irqsave(<span class="hljs-params">lock</span>, <span class="hljs-params">flags</span>)</span><span class="hljs-keyword">do</span> &#123; local<span class="hljs-constructor">_irq_save(<span class="hljs-params">flags</span>)</span>;      write<span class="hljs-constructor">_lock(<span class="hljs-params">lock</span>)</span>; &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)#define write<span class="hljs-constructor">_lock_irq(<span class="hljs-params">lock</span>)</span><span class="hljs-keyword">do</span> &#123; local<span class="hljs-constructor">_irq_disable()</span>;        write<span class="hljs-constructor">_lock(<span class="hljs-params">lock</span>)</span>; &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)#define write<span class="hljs-constructor">_lock_bh(<span class="hljs-params">lock</span>)</span><span class="hljs-keyword">do</span> &#123; local<span class="hljs-constructor">_bh_disable()</span>;         write<span class="hljs-constructor">_lock(<span class="hljs-params">lock</span>)</span>; &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)</code></pre></li><li><p><strong>释放读写锁的操作</strong></p><pre><code class="hljs reasonml">#define read<span class="hljs-constructor">_unlock_irqrestore(<span class="hljs-params">lock</span>, <span class="hljs-params">flags</span>)</span><span class="hljs-keyword">do</span> &#123; read<span class="hljs-constructor">_unlock(<span class="hljs-params">lock</span>)</span>;  local<span class="hljs-constructor">_irq_restore(<span class="hljs-params">flags</span>)</span>; &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)#define read<span class="hljs-constructor">_unlock_irq(<span class="hljs-params">lock</span>)</span><span class="hljs-keyword">do</span> &#123; read<span class="hljs-constructor">_unlock(<span class="hljs-params">lock</span>)</span>;  local<span class="hljs-constructor">_irq_enable()</span>;       &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)#define read<span class="hljs-constructor">_unlock_bh(<span class="hljs-params">lock</span>)</span><span class="hljs-keyword">do</span> &#123; read<span class="hljs-constructor">_unlock(<span class="hljs-params">lock</span>)</span>;  local<span class="hljs-constructor">_bh_enable()</span>;        &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)#define write<span class="hljs-constructor">_unlock_irqrestore(<span class="hljs-params">lock</span>, <span class="hljs-params">flags</span>)</span><span class="hljs-keyword">do</span> &#123; write<span class="hljs-constructor">_unlock(<span class="hljs-params">lock</span>)</span>; local<span class="hljs-constructor">_irq_restore(<span class="hljs-params">flags</span>)</span>; &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)#define write<span class="hljs-constructor">_unlock_irq(<span class="hljs-params">lock</span>)</span><span class="hljs-keyword">do</span> &#123; write<span class="hljs-constructor">_unlock(<span class="hljs-params">lock</span>)</span>; local<span class="hljs-constructor">_irq_enable()</span>;       &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)#define write<span class="hljs-constructor">_unlock_bh(<span class="hljs-params">lock</span>)</span><span class="hljs-keyword">do</span> &#123; write<span class="hljs-constructor">_unlock(<span class="hljs-params">lock</span>)</span>; local<span class="hljs-constructor">_bh_enable()</span>;        &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)</code></pre></li></ul></li><li><p><strong>总结</strong></p><ul><li><p><strong>读写锁本质上就是一个计数器，初始化值为0x01000000，表示最多可以有0x01000000个读者同时获取读锁</strong></p></li><li><p><strong>获取读锁时，rw计数减1，判断结果的符号位是否为1。若结果符号位为0时，获取读锁成功</strong></p></li><li><p><strong>获取读锁时，rw计数减1，判断结果的符号位是否为1。若结果符号位为1时，获取读锁失败，表示此时读写锁被写者占有，此时调用__read_lock_failed失败处理函数，循环测试rw+1的值，直到结果的值大于等于1</strong></p></li><li><p><strong>获取写锁时，rw计数减RW_LOCK_BIAS_STR，即rw-0x01000000，判断结果是否为0。若结果为0时，获取写锁成功</strong></p></li><li><p><strong>获取写锁时，rw计数减RW_LOCK_BIAS_STR，即rw-0x01000000，判断结果是否为0。若结果不为0时，获取写锁失败，表示此时有读者占有读写锁或有写着占有读写锁，此时调用__write_lock_failed失败处理函数，循环测试rw+0x01000000，直到结果的值等于0x01000000</strong></p></li><li><p><strong>通过对读写锁的源代码分析，可以看出读写锁其实是带计数的特殊自旋锁，能同时被多个读者占有或一个写者占有，但不能同时被读者和写者占有</strong></p></li><li><p><strong>操作系统为了避免一直有读者占有读写锁而导致写者饥饿的情况，让写者等待时排在读者前面，使写者的优先级更高</strong></p></li></ul></li></ol><p><strong>* <em>一个下午就这样过去了。。。→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核中的互斥操作（2）——自旋锁</title>
    <link href="/2020/07/01/spin-lock/"/>
    <url>/2020/07/01/spin-lock/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>本篇来看看多次在内核中出现的spin_lock——自旋锁，到底是个什么东西。。。→_→</em> *</strong></p><ol><li><p><strong>内核中的spin_lock()</strong></p><ul><li><p><strong>spin_lock()源代码</strong></p><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">static</span> inline <span class="hljs-keyword">void</span> <span class="hljs-title">spin_lock</span>(<span class="hljs-params">spinlock_t *<span class="hljs-keyword">lock</span></span>)<span class="hljs-comment">//自旋锁的类型定义见下方</span></span><span class="hljs-function"></span>&#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SPINLOCK_DEBUG</span>__label__ here;here:<span class="hljs-keyword">if</span> (<span class="hljs-keyword">lock</span>-&gt;magic != SPINLOCK_MAGIC) &#123;printk(<span class="hljs-string">"eip: %p\n"</span>, &amp;&amp;here);BUG();&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>__asm__ __volatile__(spin_lock_string<span class="hljs-comment">//进入宏函数spin_lock_string，传参数lock-&gt;lock</span>:<span class="hljs-string">"=m"</span> (<span class="hljs-keyword">lock</span>-&gt;<span class="hljs-keyword">lock</span>) : : <span class="hljs-string">"memory"</span>);&#125;</code></pre></li></ul></li></ol><ul><li><p><strong>自旋锁的类型定义</strong></p>  <pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> lock;<span class="hljs-comment">//不考虑调试时，自旋锁就是一个无符号整形，volatile保证编译器不进行过度优化</span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SPINLOCK_DEBUG</span><span class="hljs-keyword">unsigned</span> magic;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>&#125; <span class="hljs-keyword">spinlock_t</span>;</code></pre><ul><li><p><strong>spin_lock_string宏函数</strong></p><pre><code class="hljs lsl">#define spin_lock_string \<span class="hljs-string">"<span class="hljs-subst">\n</span>1:<span class="hljs-subst">\t</span>"</span> \<span class="hljs-string">"lock ; decb %0<span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>"</span> \ <span class="hljs-comment">//decb指令涉及读-改-写操作，所以lock总线保证该条指令的原子性，%0就是传入的参数lock-&gt;lock，decb指令将lock-&gt;lock减1，结果非负表示加锁成功，直接返回</span><span class="hljs-string">"js 2f<span class="hljs-subst">\n</span>"</span> \ <span class="hljs-string">".section .text.lock,<span class="hljs-subst">\"</span>ax<span class="hljs-subst">\"</span><span class="hljs-subst">\n</span>"</span> \<span class="hljs-string">"2:<span class="hljs-subst">\t</span>"</span> \ <span class="hljs-comment">//结果为负，循环测试lock-&gt;lock的值</span><span class="hljs-string">"cmpb $0,%0<span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>"</span> \ <span class="hljs-comment">//将lock-&gt;lock的值与0比较</span><span class="hljs-string">"rep;nop<span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>"</span> \<span class="hljs-string">"jle 2b<span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>"</span> \ <span class="hljs-comment">//当lock-&gt;lock小于等于0时，继续循环测试</span><span class="hljs-string">"jmp 1b<span class="hljs-subst">\n</span>"</span> \ <span class="hljs-comment">//当lock-&gt;lock大于0时，跳转到标号1，获取自旋锁</span><span class="hljs-string">".previous"</span></code></pre></li></ul><p>  <strong>从代码中得知，如果lock-&gt;lock小于等于0，那么就一直循环测试其值，直到lock-&gt;lock大于0。这就相当于让CPU一直空转，做无用功，因此自旋锁应用的地方不能加锁时间太长，否则就会浪费资源。</strong></p></li></ul><ol start="2"><li><p><strong>内核中的spin_unlock()</strong></p><ul><li><p><strong>spin_unlock()源代码</strong></p><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">static</span> inline <span class="hljs-keyword">void</span> <span class="hljs-title">spin_unlock</span>(<span class="hljs-params">spinlock_t *<span class="hljs-keyword">lock</span></span>)</span><span class="hljs-function"></span>&#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SPINLOCK_DEBUG</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">lock</span>-&gt;magic != SPINLOCK_MAGIC)BUG();<span class="hljs-keyword">if</span> (!spin_is_locked(<span class="hljs-keyword">lock</span>))BUG();<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>__asm__ __volatile__(spin_unlock_string<span class="hljs-comment">//调用spin_unlock_string宏函数，传参数lock-&gt;lock</span>:<span class="hljs-string">"=m"</span> (<span class="hljs-keyword">lock</span>-&gt;<span class="hljs-keyword">lock</span>) : : <span class="hljs-string">"memory"</span>);&#125;</code></pre></li><li><p><strong>spin_unlock_string宏函数</strong></p><pre><code class="hljs pgsql"><span class="hljs-meta">#define spin_unlock_string \</span>"movb $1,%0" //%<span class="hljs-number">0</span>就是传入的参数<span class="hljs-keyword">lock</span>-&gt;<span class="hljs-keyword">lock</span>，movb指令将<span class="hljs-keyword">lock</span>-&gt;<span class="hljs-keyword">lock</span>置为<span class="hljs-number">1</span>，movb指令本身就是原子操作，所以不需要<span class="hljs-keyword">lock</span>总线</code></pre></li></ul></li><li><p><strong>内核中的自旋锁具体应用的类型</strong></p><ul><li><p><strong>加锁操作</strong></p><pre><code class="hljs reasonml">#define spin<span class="hljs-constructor">_lock_irqsave(<span class="hljs-params">lock</span>, <span class="hljs-params">flags</span>)</span><span class="hljs-keyword">do</span> &#123; local<span class="hljs-constructor">_irq_save(<span class="hljs-params">flags</span>)</span>;       spin<span class="hljs-constructor">_lock(<span class="hljs-params">lock</span>)</span>; &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)#define spin<span class="hljs-constructor">_lock_irq(<span class="hljs-params">lock</span>)</span><span class="hljs-keyword">do</span> &#123; local<span class="hljs-constructor">_irq_disable()</span>;         spin<span class="hljs-constructor">_lock(<span class="hljs-params">lock</span>)</span>; &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)#define spin<span class="hljs-constructor">_lock_bh(<span class="hljs-params">lock</span>)</span><span class="hljs-keyword">do</span> &#123; local<span class="hljs-constructor">_bh_disable()</span>;          spin<span class="hljs-constructor">_lock(<span class="hljs-params">lock</span>)</span>; &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)</code></pre></li><li><p><strong>去锁操作</strong></p><pre><code class="hljs reasonml">#define spin<span class="hljs-constructor">_unlock_irqrestore(<span class="hljs-params">lock</span>, <span class="hljs-params">flags</span>)</span><span class="hljs-keyword">do</span> &#123; spin<span class="hljs-constructor">_unlock(<span class="hljs-params">lock</span>)</span>;  local<span class="hljs-constructor">_irq_restore(<span class="hljs-params">flags</span>)</span>; &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)#define spin<span class="hljs-constructor">_unlock_irq(<span class="hljs-params">lock</span>)</span><span class="hljs-keyword">do</span> &#123; spin<span class="hljs-constructor">_unlock(<span class="hljs-params">lock</span>)</span>;  local<span class="hljs-constructor">_irq_enable()</span>;       &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)#define spin<span class="hljs-constructor">_unlock_bh(<span class="hljs-params">lock</span>)</span><span class="hljs-keyword">do</span> &#123; spin<span class="hljs-constructor">_unlock(<span class="hljs-params">lock</span>)</span>;  local<span class="hljs-constructor">_bh_enable()</span>;        &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)</code></pre><ul><li><strong>不同操作之间的异同</strong></li></ul></li></ul><p> <strong>同：加锁和去锁操作中都是分为两部分，即先执行local_操作——关闭或开启本处理器上的中断响应，再执行_lock操作——防止来自其他处理器的干扰。</strong></p><p> <strong>异：主要区别就在于如何关闭本处理器上的中断响应</strong></p> <pre><code class="hljs less"><span class="hljs-comment">/* For spinlocks etc */</span><span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">local_irq_save</span>(x)<span class="hljs-selector-tag">__asm__</span> <span class="hljs-selector-tag">__volatile__</span>(<span class="hljs-string">"pushfl ; popl %0 ; cli"</span>:<span class="hljs-string">"=g"</span> (x): <span class="hljs-comment">/* no input */</span> :<span class="hljs-string">"memory"</span>) <span class="hljs-comment">//通过cli指令关闭中断，且将本处理器的状态标识寄存器通过push和pop操作，保存到参数x中，以便去锁时恢复。状态标志寄存器中的IF标志位反映当前中断的开关状态</span><span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">local_irq_restore</span>(x)<span class="hljs-selector-tag">__restore_flags</span>(x) <span class="hljs-comment">//去锁时恢复标识寄存器</span><span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">local_irq_disable</span>()<span class="hljs-selector-tag">__cli</span>() <span class="hljs-comment">//直接将标识寄存器的IF标志位清0</span><span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">local_irq_enable</span>()<span class="hljs-selector-tag">__sti</span>()</code></pre></li></ol><p><strong>* <em>码完吃饭。。。下午继续最后的read_lock和write_lock。。。→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核中的互斥操作（1）——信号量</title>
    <link href="/2020/07/01/signal/"/>
    <url>/2020/07/01/signal/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>看了一段时间Linux内核源代码了，经常会在代码中看到down()、up()、spin_lock()、spin_unlock()、read_lock()、write_lock()、read_unlock()、write_unlock()等函数。本篇就先来看down()、up()是干什么的。。。它们的底层都是如何实现的。。。→_→</em> *</strong></p><ol><li><p><strong>down()（P操作）</strong></p><p> <strong>内核中通过信号量（semaphore）来实现进程间对共享资源的互斥访问，提供了down()函数（P操作）和up()函数（V操作）</strong>。</p><ul><li><p><strong>内核中信号量的数据结构</strong></p><pre><code class="hljs cpp"><span class="hljs-comment">//linux-2.4.0\include\asm-i386\Semaphore.h</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> &#123;</span><span class="hljs-keyword">atomic_t</span> count;<span class="hljs-comment">//计数器，表示可用资源的数量</span><span class="hljs-keyword">int</span> sleepers;<span class="hljs-comment">//等待进程的数量（其实只代表有没有进程等待）</span><span class="hljs-keyword">wait_queue_head_t</span> wait;<span class="hljs-comment">//进程的等待队列</span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> WAITQUEUE_DEBUG</span><span class="hljs-keyword">long</span> __magic;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>&#125;;</code></pre></li><li><p><strong>初始化信号量</strong></p><pre><code class="hljs reasonml">#<span class="hljs-keyword">if</span> WAITQUEUE_DEBUG# define <span class="hljs-constructor">__SEM_DEBUG_INIT(<span class="hljs-params">name</span>)</span> \, (<span class="hljs-built_in">int</span>)&amp;(name).__magic#<span class="hljs-keyword">else</span># define <span class="hljs-constructor">__SEM_DEBUG_INIT(<span class="hljs-params">name</span>)</span>#endif<span class="hljs-comment">//初始化count与等待队列</span>#define <span class="hljs-constructor">__SEMAPHORE_INITIALIZER(<span class="hljs-params">name</span>,<span class="hljs-params">count</span>)</span> \&#123; <span class="hljs-constructor">ATOMIC_INIT(<span class="hljs-params">count</span>)</span>, <span class="hljs-number">0</span>, <span class="hljs-constructor">__WAIT_QUEUE_HEAD_INITIALIZER((<span class="hljs-params">name</span>)</span>.wait) \<span class="hljs-constructor">__SEM_DEBUG_INIT(<span class="hljs-params">name</span>)</span> &#125;<span class="hljs-comment">//初始化信号量</span>#define <span class="hljs-constructor">__MUTEX_INITIALIZER(<span class="hljs-params">name</span>)</span> \<span class="hljs-constructor">__SEMAPHORE_INITIALIZER(<span class="hljs-params">name</span>,1)</span>#define <span class="hljs-constructor">__DECLARE_SEMAPHORE_GENERIC(<span class="hljs-params">name</span>,<span class="hljs-params">count</span>)</span> \<span class="hljs-keyword">struct</span> semaphore name = <span class="hljs-constructor">__SEMAPHORE_INITIALIZER(<span class="hljs-params">name</span>,<span class="hljs-params">count</span>)</span><span class="hljs-comment">//声明初始值为1的信号量</span>#define <span class="hljs-constructor">DECLARE_MUTEX(<span class="hljs-params">name</span>)</span> <span class="hljs-constructor">__DECLARE_SEMAPHORE_GENERIC(<span class="hljs-params">name</span>,1)</span><span class="hljs-comment">//声明初始值为0的信号量</span>#define <span class="hljs-constructor">DECLARE_MUTEX_LOCKED(<span class="hljs-params">name</span>)</span> <span class="hljs-constructor">__DECLARE_SEMAPHORE_GENERIC(<span class="hljs-params">name</span>,0)</span></code></pre></li><li><p><strong>down()</strong></p><pre><code class="hljs sqf">static inline void down(struct semaphore * sem)&#123;<span class="hljs-meta">#if WAITQUEUE_DEBUG</span>CHECK_MAGIC(sem-&gt;<span class="hljs-variable">__magic</span>);<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-variable">__asm__</span> <span class="hljs-variable">__volatile__</span>(<span class="hljs-string">"# atomic down operation\n\t"</span><span class="hljs-comment">//锁总线，对count减1</span><span class="hljs-built_in">LOCK</span> <span class="hljs-string">"decl %0\n\t"</span>     <span class="hljs-comment">/* --sem-&gt;count */</span><span class="hljs-string">"js 2f\n"</span><span class="hljs-string">"1:\n"</span><span class="hljs-comment">//此时count大于等于0，返回down()，进入临界区</span><span class="hljs-string">".section .text.lock,\"</span>ax\<span class="hljs-string">"\n"</span><span class="hljs-string">"2:\tcall __down_failed\n\t"</span><span class="hljs-comment">//此时count小于0，调用__down_failed</span><span class="hljs-string">"jmp 1b\n"</span><span class="hljs-string">".previous"</span>:<span class="hljs-string">"=m"</span> (sem-&gt;<span class="hljs-built_in">count</span>):<span class="hljs-string">"c"</span> (sem):<span class="hljs-string">"memory"</span>);&#125;</code></pre></li><li><p><strong><strong>down_failed()中调用了</strong>down()</strong></p><pre><code class="hljs reasonml">void <span class="hljs-constructor">__down(<span class="hljs-params">struct</span> <span class="hljs-params">semaphore</span> <span class="hljs-operator">*</span> <span class="hljs-params">sem</span>)</span>&#123;<span class="hljs-keyword">struct</span> task_struct *tsk = current;<span class="hljs-constructor">DECLARE_WAITQUEUE(<span class="hljs-params">wait</span>, <span class="hljs-params">tsk</span>)</span>;tsk-&gt;state = TASK_UNINTERRUPTIBLE;<span class="hljs-comment">//将当前进程的等待队列元素wait，链入队列头sem-&gt;wait的等待队列的尾部</span>add<span class="hljs-constructor">_wait_queue_exclusive(&amp;<span class="hljs-params">sem</span>-&gt;<span class="hljs-params">wait</span>, &amp;<span class="hljs-params">wait</span>)</span>;spin<span class="hljs-constructor">_lock_irq(&amp;<span class="hljs-params">semaphore_lock</span>)</span>;sem-&gt;sleepers++;<span class="hljs-comment">//将等待进入临界区的进程数加1</span>for (;;) &#123;<span class="hljs-built_in">int</span> sleepers = sem-&gt;sleepers;<span class="hljs-comment">/*</span><span class="hljs-comment"> * Add "everybody else" into it. They aren't</span><span class="hljs-comment"> * playing, because we own the spinlock.</span><span class="hljs-comment"> */</span> <span class="hljs-comment">//执行__down()函数的进程是因为没有进入临界区，但此时可能有进程已经执行了up()，所以有必要再一次检查count，避免无谓的等待进入睡眠而浪费资源</span> <span class="hljs-comment">//atomic_add_negative()函数中执行sleepers-1加sem-&gt;count</span> <span class="hljs-comment">//若结果为负数，返回非零，表示进程需要继续等待</span> <span class="hljs-comment">//若结果不为负数，返回零，表示不需要等待，可以进入临界区</span><span class="hljs-keyword">if</span> (!atomic<span class="hljs-constructor">_add_negative(<span class="hljs-params">sleepers</span> - 1, &amp;<span class="hljs-params">sem</span>-&gt;<span class="hljs-params">count</span>)</span>) &#123;sem-&gt;sleepers = <span class="hljs-number">0</span>;<span class="hljs-comment">//设置等待进程数为0</span>break;<span class="hljs-comment">//跳出循环</span>&#125;sem-&gt;sleepers = <span class="hljs-number">1</span>;<span class="hljs-comment">/* us - see -1 above */</span><span class="hljs-comment">//设置等待进程数为1，它在这里只表示有无进程需要等待，而不表示有多少进程需要等待</span>spin<span class="hljs-constructor">_unlock_irq(&amp;<span class="hljs-params">semaphore_lock</span>)</span>;schedule<span class="hljs-literal">()</span>;<span class="hljs-comment">//准备将此进程调度为深度睡眠，即不会因为信号而唤醒</span>tsk-&gt;state = TASK_UNINTERRUPTIBLE;spin<span class="hljs-constructor">_lock_irq(&amp;<span class="hljs-params">semaphore_lock</span>)</span>;&#125;spin<span class="hljs-constructor">_unlock_irq(&amp;<span class="hljs-params">semaphore_lock</span>)</span>;remove<span class="hljs-constructor">_wait_queue(&amp;<span class="hljs-params">sem</span>-&gt;<span class="hljs-params">wait</span>, &amp;<span class="hljs-params">wait</span>)</span>;<span class="hljs-comment">//将此进程移出等待队列</span>tsk-&gt;state = TASK_RUNNING;<span class="hljs-comment">//设置此进程为运行状态</span>wake<span class="hljs-constructor">_up(&amp;<span class="hljs-params">sem</span>-&gt;<span class="hljs-params">wait</span>)</span>;<span class="hljs-comment">//返回之前唤醒等待队列中的其他进程</span>&#125;</code></pre></li></ul></li><li><p><strong>up()（V操作）</strong></p><ul><li><p><strong>up()</strong></p><pre><code class="hljs sqf">static inline void up(struct semaphore * sem)&#123;<span class="hljs-meta">#if WAITQUEUE_DEBUG</span>CHECK_MAGIC(sem-&gt;<span class="hljs-variable">__magic</span>);<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-variable">__asm__</span> <span class="hljs-variable">__volatile__</span>(<span class="hljs-string">"# atomic up operation\n\t"</span><span class="hljs-comment">//锁总线，对count加1，这和前面的atomic_add_negative()函数的作用又对起来了</span><span class="hljs-built_in">LOCK</span> <span class="hljs-string">"incl %0\n\t"</span>     <span class="hljs-comment">/* ++sem-&gt;count */</span><span class="hljs-string">"jle 2f\n"</span><span class="hljs-string">"1:\n"</span><span class="hljs-string">".section .text.lock,\"</span>ax\<span class="hljs-string">"\n"</span><span class="hljs-string">"2:\tcall __up_wakeup\n\t"</span><span class="hljs-comment">//当count小于等于0时，调用__up_wakeup()</span><span class="hljs-string">"jmp 1b\n"</span><span class="hljs-string">".previous"</span>:<span class="hljs-string">"=m"</span> (sem-&gt;<span class="hljs-built_in">count</span>):<span class="hljs-string">"c"</span> (sem):<span class="hljs-string">"memory"</span>);&#125;</code></pre></li><li><p><strong><strong>up_wakeup()中调用了</strong>up()，__up()中调用了wake_up()</strong></p><pre><code class="hljs reasonml"><span class="hljs-comment">//wake_up()是宏函数，其中调用了__wake_up()函数</span>#define wake<span class="hljs-constructor">_up(<span class="hljs-params">x</span>)</span><span class="hljs-constructor">__wake_up((<span class="hljs-params">x</span>)</span>,TASK_UNINTERRUPTIBLE <span class="hljs-pattern-match">| <span class="hljs-constructor">TASK_INTERRUPTIBLE</span>,<span class="hljs-constructor">WQ_FLAG_EXCLUSIVE</span>)</span></code></pre></li><li><p><strong>__wake_up()</strong></p><pre><code class="hljs reasonml"><span class="hljs-comment">//其中调用了__wake_up_common()，注意最后一个参数传的是0</span>void <span class="hljs-constructor">__wake_up(<span class="hljs-params">wait_queue_head_t</span> <span class="hljs-operator">*</span><span class="hljs-params">q</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">mode</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">wq_mode</span>)</span>&#123;<span class="hljs-constructor">__wake_up_common(<span class="hljs-params">q</span>, <span class="hljs-params">mode</span>, <span class="hljs-params">wq_mode</span>, 0)</span>;&#125;</code></pre></li><li><p><strong>__wake_up_common()</strong></p><pre><code class="hljs reasonml">static inline void __wake_up_common (wait_queue_head_t *q, unsigned <span class="hljs-built_in">int</span> mode,     unsigned <span class="hljs-built_in">int</span> wq_mode, const <span class="hljs-built_in">int</span> sync)&#123;<span class="hljs-keyword">struct</span> list_head *tmp, *head;<span class="hljs-keyword">struct</span> task_struct *p, *best_exclusive;unsigned long flags;<span class="hljs-built_in">int</span> best_cpu, irq;<span class="hljs-keyword">if</span> (!q)goto out;best_cpu = smp<span class="hljs-constructor">_processor_id()</span>;irq = <span class="hljs-keyword">in</span><span class="hljs-constructor">_interrupt()</span>;best_exclusive = NULL;wq<span class="hljs-constructor">_write_lock_irqsave(&amp;<span class="hljs-params">q</span>-&gt;<span class="hljs-params">lock</span>, <span class="hljs-params">flags</span>)</span>;head = &amp;q-&gt;task_list;tmp = head-&gt;next;<span class="hljs-keyword">while</span> (tmp != head) &#123;unsigned <span class="hljs-built_in">int</span> state;                wait_queue_t *curr = <span class="hljs-built_in">list</span><span class="hljs-constructor">_entry(<span class="hljs-params">tmp</span>, <span class="hljs-params">wait_queue_t</span>, <span class="hljs-params">task_list</span>)</span>;tmp = tmp-&gt;next;p = curr-&gt;task;state = p-&gt;state;<span class="hljs-keyword">if</span> (state &amp; mode) &#123;<span class="hljs-comment">/*</span><span class="hljs-comment"> * If waking up from an interrupt context then</span><span class="hljs-comment"> * prefer processes which are affine to this</span><span class="hljs-comment"> * CPU.</span><span class="hljs-comment"> */</span> <span class="hljs-comment">//此函数的作用就是遍历等待队列，依次唤醒符合条件的进程，如果唤醒的进程TASK_EXCLUSIVE为1，就停止唤醒其余进程，被唤醒的进程在__down()中继续执行</span><span class="hljs-keyword">if</span> (irq<span class="hljs-operator"> &amp;&amp; </span>(curr-&gt;flags &amp; wq_mode &amp; WQ_FLAG_EXCLUSIVE)) &#123;<span class="hljs-keyword">if</span> (!best_exclusive)best_exclusive = p;<span class="hljs-keyword">if</span> (p-&gt;processor<span class="hljs-operator"> == </span>best_cpu) &#123;best_exclusive = p;break;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (sync)wake<span class="hljs-constructor">_up_process_synchronous(<span class="hljs-params">p</span>)</span>;<span class="hljs-keyword">else</span>wake<span class="hljs-constructor">_up_process(<span class="hljs-params">p</span>)</span>;<span class="hljs-keyword">if</span> (curr-&gt;flags &amp; wq_mode &amp; WQ_FLAG_EXCLUSIVE)break;&#125;&#125;&#125;<span class="hljs-keyword">if</span> (best_exclusive) &#123;<span class="hljs-keyword">if</span> (sync)wake<span class="hljs-constructor">_up_process_synchronous(<span class="hljs-params">best_exclusive</span>)</span>;<span class="hljs-keyword">else</span>wake<span class="hljs-constructor">_up_process(<span class="hljs-params">best_exclusive</span>)</span>;&#125;wq<span class="hljs-constructor">_write_unlock_irqrestore(&amp;<span class="hljs-params">q</span>-&gt;<span class="hljs-params">lock</span>, <span class="hljs-params">flags</span>)</span>;out:return;&#125;</code></pre></li></ul></li></ol><p><strong>* <em>先去吃个饭。。一会来继续写spin_lock()、spin_unlock()。。→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（44）翻转单词顺序列</title>
    <link href="/2020/07/01/flip-word-order-column/"/>
    <url>/2020/07/01/flip-word-order-column/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs axapta"><span class="hljs-comment">//这道题一开始理解错了。。。→_→</span><span class="hljs-comment">//以为是"student. a am I"转"I am a student."，应该是刚好相反的。。。</span><span class="hljs-comment">//先将字符串整体反转</span><span class="hljs-comment">//.tneduts a ma I</span><span class="hljs-comment">//再按照空格将字符串分割成不同的部分，依次反转</span><span class="hljs-comment">//student. a am I</span><span class="hljs-comment">//注意：</span><span class="hljs-comment">//1.判断输入字符串是否有效</span><span class="hljs-comment">//2.有可能输入的字符串中没有空格</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-keyword">void</span> Reserve(string &amp;<span class="hljs-keyword">str</span>, <span class="hljs-keyword">int</span> beginIndex, <span class="hljs-keyword">int</span> endIndex)&#123;<span class="hljs-keyword">char</span> tmp;<span class="hljs-keyword">for</span> (; beginIndex &lt; endIndex; ++beginIndex, --endIndex)&#123;tmp = <span class="hljs-keyword">str</span>[beginIndex];<span class="hljs-keyword">str</span>[beginIndex] = <span class="hljs-keyword">str</span>[endIndex];<span class="hljs-keyword">str</span>[endIndex] = tmp;&#125;&#125;string ReverseSentence(string <span class="hljs-keyword">str</span>)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">str</span>.empty())/防御性动作，判断<span class="hljs-keyword">str</span>是否有效<span class="hljs-keyword">return</span> <span class="hljs-keyword">str</span>;Reserve(<span class="hljs-keyword">str</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">str</span>.size() - <span class="hljs-number">1</span>);<span class="hljs-comment">//先将整个字符串反转</span><span class="hljs-keyword">int</span> beginIndex = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录需要反转部分的起始下标</span><span class="hljs-keyword">int</span> endIndex = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录需要反转部分的终止下标</span><span class="hljs-keyword">while</span> (<span class="hljs-keyword">str</span>[beginIndex] != <span class="hljs-string">'\0'</span>)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">str</span>[beginIndex] == <span class="hljs-string">' '</span>)<span class="hljs-comment">//有可能是连续的空格，直接略过</span>&#123;++beginIndex;<span class="hljs-comment">//起始和终止下标一起后移</span>++endIndex;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">str</span>[endIndex] == <span class="hljs-string">' '</span> || <span class="hljs-keyword">str</span>[endIndex] == <span class="hljs-string">'\0'</span>)<span class="hljs-comment">//当终止下标所对应的元素为空格或'\0'时</span>&#123;Reserve(<span class="hljs-keyword">str</span>,beginIndex, --endIndex);<span class="hljs-comment">//反转这个部分</span>beginIndex = ++endIndex;<span class="hljs-comment">//反转之后，起始和终止下标统一</span>&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//否则继续后移终止下标，继续寻找直到空格或'\0'</span>++endIndex;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">str</span>;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（43）左旋转字符串</title>
    <link href="/2020/07/01/left-rotate-string/"/>
    <url>/2020/07/01/left-rotate-string/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs reasonml"><span class="hljs-comment">//寻找规律</span><span class="hljs-comment">//将字符序列按向左移动的K位，划分为两部分</span><span class="hljs-comment">//将这两个部分分别进行反转</span><span class="hljs-comment">//cba fedZYX</span><span class="hljs-comment">//在将整个字符串反转</span><span class="hljs-comment">//XYZdefabc</span><span class="hljs-comment">//就能得到循环左移K位后的序列</span><span class="hljs-comment">//代码实现很简单，但要注意：</span><span class="hljs-comment">//1.判断输入的str是否有效</span><span class="hljs-comment">//2.循环左移的位数是否合法</span><span class="hljs-comment">//3.特别注意下标的定义，不要越界访问！</span><span class="hljs-keyword">class</span> Solution&#123;public:void <span class="hljs-constructor">Reserve(<span class="hljs-params">string</span> &amp;<span class="hljs-params">str</span>, <span class="hljs-params">string</span>::<span class="hljs-params">iterator</span> <span class="hljs-params">itBegin</span>, <span class="hljs-params">string</span>::<span class="hljs-params">iterator</span> <span class="hljs-params">itEnd</span>)</span>&#123;<span class="hljs-built_in">char</span> tmp;<span class="hljs-comment">//空瓶子，真没啥说的了。。。</span>for (; itBegin &lt; itEnd; ++itBegin, --itEnd)&#123;tmp = *itBegin;*itBegin = *itEnd;*itEnd = tmp;&#125;&#125;<span class="hljs-built_in">string</span> <span class="hljs-constructor">LeftRotateString(<span class="hljs-params">string</span> <span class="hljs-params">str</span>, <span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span>&#123;<span class="hljs-comment">//防御性动作，判断str是否有效，判断n是否合法</span><span class="hljs-keyword">if</span> (str.empty<span class="hljs-literal">()</span><span class="hljs-operator"> || </span>n &lt; <span class="hljs-number">0</span><span class="hljs-operator"> || </span>n &gt; str.size<span class="hljs-literal">()</span>)return str;<span class="hljs-built_in">string</span>::iterator itFstBegin = str.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>;<span class="hljs-comment">//第一部分的头</span><span class="hljs-built_in">string</span>::iterator itFstEnd = itFstBegin + n - <span class="hljs-number">1</span>;<span class="hljs-comment">//第一部分的尾</span><span class="hljs-built_in">string</span>::iterator itSedBegin = itFstEnd + <span class="hljs-number">1</span>;<span class="hljs-comment">//第二部分的头</span><span class="hljs-built_in">string</span>::iterator itSedEnd = str.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;<span class="hljs-comment">//第二部分的尾，在这踩了坑。。str.end()指向的就是'\0'</span><span class="hljs-constructor">Reserve(<span class="hljs-params">str</span>, <span class="hljs-params">itFstBegin</span>, <span class="hljs-params">itFstEnd</span>)</span>;<span class="hljs-comment">//第一部分反转</span><span class="hljs-constructor">Reserve(<span class="hljs-params">str</span>, <span class="hljs-params">itSedBegin</span>, <span class="hljs-params">itSedEnd</span>)</span>;<span class="hljs-comment">//第二部分反转</span><span class="hljs-constructor">Reserve(<span class="hljs-params">str</span>, <span class="hljs-params">str</span>.<span class="hljs-params">begin</span>()</span>, str.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span> - <span class="hljs-number">1</span>);<span class="hljs-comment">//整体反转</span>return str;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（42）和为S的连续正数序列</title>
    <link href="/2020/07/01/a-sequence-of-consecutive-positive-numbers-whose-sum-is-S/"/>
    <url>/2020/07/01/a-sequence-of-consecutive-positive-numbers-whose-sum-is-S/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列?Good Luck!</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs fortran">//初始little数值为<span class="hljs-number">1</span>，big数值为<span class="hljs-number">2</span>//当<span class="hljs-built_in">count</span>等于<span class="hljs-built_in">sum</span>时，添加序列//否则判断//当<span class="hljs-built_in">count</span>大于<span class="hljs-built_in">sum</span>时，后移little，big不动，使<span class="hljs-built_in">count</span>减小，过程中<span class="hljs-built_in">count</span>等于<span class="hljs-built_in">sum</span>时，添加序列，直到little等于big//当<span class="hljs-built_in">count</span>小于<span class="hljs-built_in">sum</span>时，后移big，使<span class="hljs-built_in">count</span>增大//直到little等于middle//注意判断<span class="hljs-built_in">sum</span>的值是否合法<span class="hljs-keyword">class</span> Solution &#123;<span class="hljs-keyword">public</span>:vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; FindContinuousSequence(<span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span>) &#123;vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; vec;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> &lt; <span class="hljs-number">3</span>)//防御性动作<span class="hljs-keyword">return</span> vec;<span class="hljs-built_in">int</span> little = <span class="hljs-number">1</span>;//左边界，即最小值<span class="hljs-built_in">int</span> big = <span class="hljs-number">2</span>;//右边界，即最大值<span class="hljs-built_in">int</span> middle = (<span class="hljs-built_in">sum</span> + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;//中间值<span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span> = little + big;//记录序列之和<span class="hljs-keyword">while</span> (little &lt; middle)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">count</span> == <span class="hljs-built_in">sum</span>)//当<span class="hljs-built_in">count</span>等于<span class="hljs-built_in">sum</span>使，添加序列&#123;vector&lt;<span class="hljs-built_in">int</span>&gt; tmp;for (<span class="hljs-built_in">int</span> i = little; i &lt;= big; ++i)tmp.push_back(i);vec.push_back(tmp);&#125;<span class="hljs-keyword">while</span> (<span class="hljs-built_in">count</span> &gt; <span class="hljs-built_in">sum</span> &amp;&amp; little &lt; middle)//此时<span class="hljs-built_in">count</span>大于<span class="hljs-built_in">sum</span>&#123;<span class="hljs-built_in">count</span> -= little;//减小<span class="hljs-built_in">count</span>++little;//后移最小值<span class="hljs-keyword">if</span> (<span class="hljs-built_in">count</span> == <span class="hljs-built_in">sum</span>)//<span class="hljs-built_in">count</span>等于<span class="hljs-built_in">sum</span>时，添加序列&#123;vector&lt;<span class="hljs-built_in">int</span>&gt; tmp;for (<span class="hljs-built_in">int</span> i = little; i &lt;= big; ++i)tmp.push_back(i);vec.push_back(tmp);&#125;&#125;++big;//此时，<span class="hljs-built_in">count</span>小于<span class="hljs-built_in">sum</span>，后移最大值，使<span class="hljs-built_in">count</span>增大<span class="hljs-built_in">count</span> += big;&#125;<span class="hljs-keyword">return</span> vec;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（41）和为S的两个数字</title>
    <link href="/2020/07/01/snd-two-numbers-for-s/"/>
    <url>/2020/07/01/snd-two-numbers-for-s/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得它们的和正好是S。如果有多对数字的和等于S，输出任意一对即可</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs arduino"><span class="hljs-comment">//使用两个指针，分别指向排序数组的第一个元素和最后一个元素，它们是最小值和最大值</span><span class="hljs-comment">//将指针指向的值相加的和与S进行比较</span><span class="hljs-comment">//如果和比S小，则后移前指针</span><span class="hljs-comment">//如果和比S大，则前移后指针</span><span class="hljs-comment">//注意</span><span class="hljs-comment">//1.有可能不存在和为S的两个数，所有路径都有返回值</span><span class="hljs-comment">//2.题目规定乘机最小，其实就是之和最小，也就是第一次相等时的两个元素。。</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">FindNumbersWithSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">array</span>, <span class="hljs-keyword">int</span> sum)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tmp;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>)<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">return</span> tmp;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator itBegin = <span class="hljs-built_in">array</span>.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//前迭代器</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator itEnd = --<span class="hljs-built_in">array</span>.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//后迭代器</span><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录两个数之和</span><span class="hljs-keyword">while</span> (itBegin &lt; itEnd)<span class="hljs-comment">//判断有可能不存在和为S的两个数字</span>&#123;count = *itBegin + *itEnd;<span class="hljs-keyword">if</span> (count &lt; sum)<span class="hljs-comment">//和比S小，后移前指针</span>++itBegin;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count &gt; sum)<span class="hljs-comment">//和比S大，前移后指针</span>--itEnd;<span class="hljs-keyword">else</span><span class="hljs-comment">//当和相等时，将元素压入序列</span>&#123;tmp.push_back(*itBegin);tmp.push_back(*itEnd);<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">return</span> tmp;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（40）数组中只出现一次的数字</title>
    <link href="/2020/07/01/numbers-that-appear-only-once-in-the-array/"/>
    <url>/2020/07/01/numbers-that-appear-only-once-in-the-array/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">//关键点是使用异或位运算符</span><span class="hljs-comment">//相同的数字异或结果为零</span><span class="hljs-comment">//如果数组中只有一个数字出现一次，那么异或的遍历这个数组，最后的结果就是那个数字</span><span class="hljs-comment">//如果此时变成有两个数字都出现了一次，那还按照之前的办法，最后的结果就是这两个数字的异或值</span><span class="hljs-comment">//解决方法：</span><span class="hljs-comment">//将数组异或的遍历，求其结果的第一个为1的位数</span><span class="hljs-comment">//因为这一位是两个数字之间不同的位，即一个中位，另一个中为0</span><span class="hljs-comment">//再一次遍历数组，判断所有的元素这一位是否为1，并按此分为两组</span><span class="hljs-comment">//组内再将所有的元素异或，最终的值即为只出现一次的数字</span><span class="hljs-comment">//因为出现两次的数字，都会被分到同一组，所以异或时就抵消了</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:unsigned <span class="hljs-built_in">int</span> xorIndexResult(<span class="hljs-built_in">int</span> xorResult)&#123;unsigned <span class="hljs-built_in">int</span> index = <span class="hljs-number">0</span>;<span class="hljs-comment">//当位数小于32为且此为不为1时，继续计算</span><span class="hljs-keyword">while</span> (index &lt; <span class="hljs-number">8</span> * sizeof(xorResult) &amp;&amp; ((xorResult &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>))&#123;xorResult = xorResult &gt;&gt; <span class="hljs-number">1</span>;++index;&#125;<span class="hljs-keyword">return</span> index;&#125;<span class="hljs-built_in">void</span> FindNumsAppearOnce(vector&lt;<span class="hljs-built_in">int</span>&gt; data, <span class="hljs-built_in">int</span>* num1, <span class="hljs-built_in">int</span> *num2) &#123;<span class="hljs-keyword">if</span> (data.size() &lt; <span class="hljs-number">2</span>)<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">return</span>;<span class="hljs-built_in">int</span> xorResult = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录整个数组的异或结果</span><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; data.size(); ++i)xorResult ^= data[i];<span class="hljs-comment">//计算异或结果中，第一个值为1的位数</span>unsigned <span class="hljs-built_in">int</span> xorIndex = xorIndexResult(xorResult);<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; data.size(); ++j)&#123;<span class="hljs-built_in">int</span> tmp = data[j];tmp = tmp &gt;&gt; xorIndex;<span class="hljs-comment">//计算所有元素此位的值，并进行分组</span><span class="hljs-keyword">if</span> (tmp &amp; <span class="hljs-number">1</span>)*num1 ^= data[j];<span class="hljs-comment">//组内再进行异或计算</span><span class="hljs-keyword">else</span>*num2 ^= data[j];&#125;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（39）平衡二叉树</title>
    <link href="/2020/07/01/balanced-binary-tree/"/>
    <url>/2020/07/01/balanced-binary-tree/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs reasonml"><span class="hljs-comment">//如果二叉树中的任意结点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树</span><span class="hljs-comment">//利用对二叉树的后序遍历，自底向上的判断是否为平衡二叉树</span><span class="hljs-comment">//若某一结点不满足条件，则此树不是平衡二叉树</span><span class="hljs-comment">//若某一结点满足条件，就要计算此结点的深度，为后面的计算做准备</span><span class="hljs-keyword">class</span> Solution &#123;public:<span class="hljs-built_in">bool</span> <span class="hljs-constructor">IsBalanced(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">pRoot</span>, <span class="hljs-params">int</span> &amp;<span class="hljs-params">depth</span>)</span>&#123;<span class="hljs-keyword">if</span> (pRoot<span class="hljs-operator"> == </span>NULL)&#123;depth = <span class="hljs-number">0</span>;return <span class="hljs-literal">true</span>;&#125;<span class="hljs-built_in">int</span> leftChildDepth = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录当前结点的左子树深度</span><span class="hljs-built_in">int</span> rightChildDepth = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录当前结点的右子树深度</span><span class="hljs-comment">//如果当前结点的左右子树都满足平衡时</span><span class="hljs-keyword">if</span> (<span class="hljs-constructor">IsBalanced(<span class="hljs-params">pRoot</span>-&gt;<span class="hljs-params">left</span>, <span class="hljs-params">leftChildDepth</span>)</span><span class="hljs-operator"> &amp;&amp; </span><span class="hljs-constructor">IsBalanced(<span class="hljs-params">pRoot</span>-&gt;<span class="hljs-params">right</span>, <span class="hljs-params">rightChildDepth</span>)</span>)&#123;<span class="hljs-built_in">int</span> high = leftChildDepth - rightChildDepth;<span class="hljs-comment">//计算当前结点的左右高度差</span><span class="hljs-keyword">if</span> (high &gt;= -<span class="hljs-number">1</span><span class="hljs-operator"> &amp;&amp; </span>high &lt;= <span class="hljs-number">1</span>)<span class="hljs-comment">//如果依旧平衡</span>&#123;depth = <span class="hljs-number">1</span> + (leftChildDepth &gt;= rightChildDepth ? leftChildDepth : rightChildDepth);<span class="hljs-comment">//计算此结点的深度</span>return <span class="hljs-literal">true</span>;&#125;&#125;return <span class="hljs-literal">false</span>;<span class="hljs-comment">//此时此结点不满足平衡条件</span>&#125;<span class="hljs-built_in">bool</span> <span class="hljs-constructor">IsBalanced_Solution(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">pRoot</span>)</span> &#123;<span class="hljs-built_in">int</span> depth = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录每一个结点的深度</span>return <span class="hljs-constructor">IsBalanced(<span class="hljs-params">pRoot</span>, <span class="hljs-params">depth</span>)</span>;<span class="hljs-comment">//开始递归，进行后序遍历</span>&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（38）二叉树的深度</title>
    <link href="/2020/07/01/the-depth-of-the-binary-tree/"/>
    <url>/2020/07/01/the-depth-of-the-binary-tree/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">//这代码真没有什么要说的。。。</span><span class="hljs-comment">//本题就是树的遍历的应用</span><span class="hljs-comment">//最长路径的长度为树的深度，所以当节点的左子树深度和右子树深度中的最大值求得后，加1即就是此节点的深度</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">int</span> TreeDepth(TreeNode* pRoot)&#123;<span class="hljs-keyword">if</span> (pRoot == NULL) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//防御性动作</span><span class="hljs-built_in">int</span> leftChildDepth = TreeDepth(pRoot-&gt;left);<span class="hljs-comment">//求左子树深度</span><span class="hljs-built_in">int</span> rightChildDepth = TreeDepth(pRoot-&gt;right);<span class="hljs-comment">//求右子树深度</span><span class="hljs-comment">//求当前节点的深度</span><span class="hljs-keyword">return</span> (leftChildDepth &gt; rightChildDepth) ? (leftChildDepth + <span class="hljs-number">1</span>) : (rightChildDepth + <span class="hljs-number">1</span>);&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——抽象工厂模式</title>
    <link href="/2020/07/01/abstract-factory-pattern/"/>
    <url>/2020/07/01/abstract-factory-pattern/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>工厂模式解决了一部分问题，但还有一些缺点，所以这时抽象工厂模式应运而生。。。→_→</em> *</strong></p><p><strong>在阅读本文之前，需要了解一些知识点。。。请戳传送门——<a href="http://blog.csdn.net/kongkongkkk/article/details/75899570" target="_blank" rel="noopener">工厂模式</a></strong></p><ol><li><p><strong>工厂模式与抽象工厂模式的区别</strong></p><ul><li>工厂模式中，在工厂子类中无论多么辛苦的制造产品子类，其实它们都同属一个父类</li><li>而在现实生活中，工厂不可能只制造一种产品。所以一个工厂子类有可能制造多种产品子类，而它们来源于不同的父类</li></ul></li><li><p><strong>抽象工厂模式的作用</strong></p><ul><li>将一组来自于不同父类的子类对象的创建封装到一个类中， 维护这样一个创建类总比维护n个相关对象的创建过程要简单的多</li></ul></li><li><p><strong>抽象工厂模式结构示意图</strong></p><ul><li><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI0MTAwODA4MTgw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="抽象工厂模式"></li></ul></li><li><p>代码实现</p></li></ol><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vld.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//产品A父类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractProductA</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">virtual</span> ~AbstractProductA() &#123;&#125;<span class="hljs-keyword">protected</span>:AbstractProductA() &#123;&#125;&#125;;<span class="hljs-comment">//产品B父类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractProductB</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">virtual</span> ~AbstractProductB() &#123;&#125;<span class="hljs-keyword">protected</span>:AbstractProductB() &#123;&#125;&#125;;<span class="hljs-comment">//产品A的子类A1</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductA1</span> :</span> <span class="hljs-keyword">public</span> AbstractProductA&#123;<span class="hljs-keyword">public</span>:ProductA1()&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ProductA1..."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;~ProductA1() &#123;&#125;&#125;;<span class="hljs-comment">//产品A的子类A2</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductA2</span> :</span> <span class="hljs-keyword">public</span> AbstractProductA&#123;<span class="hljs-keyword">public</span>:ProductA2()&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ProductA2..."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;~ProductA2() &#123;&#125;&#125;;<span class="hljs-comment">//产品B的子类B1</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductB1</span> :</span> <span class="hljs-keyword">public</span> AbstractProductB&#123;<span class="hljs-keyword">public</span>:ProductB1()&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ProductB1..."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;~ProductB1() &#123;&#125;&#125;;<span class="hljs-comment">//产品B的子类B2</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductB2</span> :</span> <span class="hljs-keyword">public</span> AbstractProductB&#123;<span class="hljs-keyword">public</span>:ProductB2()&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ProductB2..."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;~ProductB2() &#123;&#125;&#125;;<span class="hljs-comment">//抽象工厂父类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactory</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">virtual</span> ~AbstractFactory() &#123;&#125;<span class="hljs-comment">//工厂中生产有可能生产多种类型的产品，所以对应不同的调用接口</span><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractProductA* <span class="hljs-title">CreateProductA</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractProductB* <span class="hljs-title">CreateProductB</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-keyword">protected</span>:AbstractFactory() &#123;&#125;&#125;;<span class="hljs-comment">//抽象工厂子类CF1</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactory1</span> :</span> <span class="hljs-keyword">public</span> AbstractFactory&#123;<span class="hljs-keyword">public</span>:ConcreteFactory1() &#123;&#125;~ConcreteFactory1() &#123;&#125;<span class="hljs-comment">//工厂CF1针对A产品的初始化调用接口实现</span><span class="hljs-function">AbstractProductA* <span class="hljs-title">CreateProductA</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductA1();&#125;<span class="hljs-comment">//工厂CF1针对B产品的初始化调用接口实现</span><span class="hljs-function">AbstractProductB* <span class="hljs-title">CreateProductB</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductB1();&#125;&#125;;<span class="hljs-comment">//抽象工厂子类CF2</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactory2</span> :</span> <span class="hljs-keyword">public</span> AbstractFactory&#123;<span class="hljs-keyword">public</span>:ConcreteFactory2() &#123;&#125;~ConcreteFactory2() &#123;&#125;<span class="hljs-comment">//工厂CF2针对A产品的初始化调用接口实现</span><span class="hljs-function">AbstractProductA* <span class="hljs-title">CreateProductA</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductA2();&#125;<span class="hljs-comment">//工厂CF2针对B产品的初始化调用接口实现</span><span class="hljs-function">AbstractProductB* <span class="hljs-title">CreateProductB</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductB2();&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;AbstractFactory* cf1 = <span class="hljs-keyword">new</span> ConcreteFactory1();<span class="hljs-comment">//创建抽象工厂子类CF1</span>AbstractProductA* pA1 = cf1-&gt;CreateProductA();<span class="hljs-comment">//在CF1中生产产品A的子类A1</span>AbstractProductB* pB1 = cf1-&gt;CreateProductB();<span class="hljs-comment">//在CF1中生产产品B的子类B1</span>AbstractFactory* cf2 = <span class="hljs-keyword">new</span> ConcreteFactory2();<span class="hljs-comment">//创建抽象工厂子类CF2</span>AbstractProductA* pA2 = cf2-&gt;CreateProductA();<span class="hljs-comment">//在CF2中生产产品A的子类A2</span>AbstractProductB* pB2 = cf2-&gt;CreateProductB();<span class="hljs-comment">//在CF2中生产产品B的子类B2</span><span class="hljs-keyword">delete</span> cf1;<span class="hljs-keyword">delete</span> pA1;<span class="hljs-keyword">delete</span> pB1;<span class="hljs-keyword">delete</span> cf2;<span class="hljs-keyword">delete</span> pA2;<span class="hljs-keyword">delete</span> pB2;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>运行结果</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI0MTA0MzE2MjM3?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="抽象工厂模式运行结果"></p><p><strong>* <em>码完。。。收工。。。→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——工厂模式</title>
    <link href="/2020/07/01/factory-mode/"/>
    <url>/2020/07/01/factory-mode/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>除了单例模式和观察者监听者模式，本篇再介绍一下工厂模式。。。→_→</em> *</strong></p><ol><li><p><strong>面向对象编程中出现的问题</strong></p><ul><li><p>在面向对象编程中，可能会会由一种父类派生出许许多多的子类。而当我们在<strong>使用new实例化一个子类对象之前，也可能需要进行很多提前操作</strong>，比如调用其他的方法、获取相应的参数列表的值、在数据库中查询相关信息等</p></li><li><p>当类型越来越多、名字越来越复杂的时候，每次去实例化一个子类对象时，都要进行很多提前操作，这就<strong>导致了出现了大量的可能产生问题的代码</strong>。使得可<strong>维护性下降</strong>，发生错误的时候查询错误、更正错误就会变得非常困难</p></li></ul></li><li><p><strong>工厂模式的作用</strong></p><ul><li><p>工厂模式的应用<strong>实现了代码的高内聚低耦合，其中定义了创建子类对象的接口，封装了子类对象的创建过程，这样我们就不用每次都辛苦的写一堆实例化子类对象的提前操作</strong></p></li><li><p><strong>工厂模式的应用也使实例化子类对象的操作延迟到了子类中，因为只有在子类中可以决定到底实例化哪一个类</strong></p></li></ul></li><li><p>工厂模式结构示意图</p><ul><li><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzIzMTkwMzIyNzY0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="工厂模式"></li></ul></li><li><p>代码实现</p></li></ol><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vld.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//产品父类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">virtual</span> ~Product() = <span class="hljs-number">0</span>;<span class="hljs-keyword">protected</span>:Product() &#123;&#125;;&#125;;Product::~Product() &#123;&#125;<span class="hljs-comment">//产品子类A</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProductA</span> :</span> <span class="hljs-keyword">public</span> Product&#123; <span class="hljs-keyword">public</span>:~ConcreteProductA() &#123;&#125;ConcreteProductA() &#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ConcreteProductA..."</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;&#125;;<span class="hljs-comment">//产品子类B</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProductB</span> :</span> <span class="hljs-keyword">public</span> Product&#123;<span class="hljs-keyword">public</span>:~ConcreteProductB() &#123;&#125;ConcreteProductB()&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ConcreteProductB..."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;<span class="hljs-comment">//产品子类C</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProductC</span> :</span> <span class="hljs-keyword">public</span> Product&#123;<span class="hljs-keyword">public</span>:~ConcreteProductC() &#123;&#125;ConcreteProductC()&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ConcreteProductC..."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;;<span class="hljs-comment">//工厂父类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">virtual</span> ~Factory() = <span class="hljs-number">0</span>;<span class="hljs-comment">//工厂父类中提供实例化不同产品子类的调用接口，即纯虚函数</span><span class="hljs-comment">//在工厂子类中重写调用接口，多个调用接口的重载以实现实例化不同的产品子类</span><span class="hljs-comment">//这样就将实例化产品子类对象的操作延迟到了工厂子类中</span><span class="hljs-function"><span class="hljs-keyword">virtual</span> Product* <span class="hljs-title">CreateProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-keyword">protected</span>:Factory() &#123;&#125;&#125;;Factory::~Factory() &#123;&#125;<span class="hljs-comment">//工厂子类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactory</span> :</span> <span class="hljs-keyword">public</span> Factory&#123;<span class="hljs-keyword">public</span>:~ConcreteFactory() &#123;&#125;ConcreteFactory()&#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ConcreteFactory..."</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;<span class="hljs-comment">//工厂子类中提供了实例化产品子类的调用接口</span><span class="hljs-comment">//很好地将提前操作封装起来，实现代码的高内聚低耦合，提高了代码的可维护性和可扩展性</span><span class="hljs-comment">//可以通过参数switch不同的产品子类的实例化调用接口</span><span class="hljs-function">Product* <span class="hljs-title">CreateProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">switch</span> (num)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProductA();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProductB();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProductC();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:<span class="hljs-keyword">break</span>;&#125;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;Factory* fac = <span class="hljs-keyword">new</span> ConcreteFactory();<span class="hljs-comment">//创建工厂子类</span><span class="hljs-comment">//利用工厂子类提供的调用接口实例化某一种产品对象</span>Product* pA = fac-&gt;CreateProduct(<span class="hljs-number">0</span>);Product* pB = fac-&gt;CreateProduct(<span class="hljs-number">1</span>);Product* pC = fac-&gt;CreateProduct(<span class="hljs-number">2</span>);<span class="hljs-keyword">delete</span> pA;<span class="hljs-keyword">delete</span> pB;<span class="hljs-keyword">delete</span> pC;<span class="hljs-keyword">delete</span> fac;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>运行结果</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzIzMTk0NDQ2Mzkw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="工厂模式运行结果"></p><p><strong>* <em>码完。。。收工。。。→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（37）数字在排序数组中出现的次数</title>
    <link href="/2020/07/01/number-of-times-the-number-appears-in-the-sorted-array/"/>
    <url>/2020/07/01/number-of-times-the-number-appears-in-the-sorted-array/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>统计一个数字在排序数组中出现的次数。</strong></p></blockquote><p><strong>实现如下：</strong></p><p>方法一</p><pre><code class="hljs arduino"><span class="hljs-comment">//利用count计数，时间复杂度O(n)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetNumberOfK</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; data, <span class="hljs-keyword">int</span> k)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> count(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>(), k);&#125;&#125;;</code></pre><p>方法二</p><pre><code class="hljs fortran">//从头开始遍历，时间复杂度O(n)<span class="hljs-keyword">class</span> Solution &#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">int</span> GetNumberOfK(vector&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">data</span>, <span class="hljs-built_in">int</span> k) &#123;<span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>;for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">data</span>.<span class="hljs-built_in">size</span>(); ++i)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">data</span>[i] == k)++<span class="hljs-built_in">count</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span>;&#125;&#125;;</code></pre><p>方法三</p><pre><code class="hljs angelscript"><span class="hljs-comment">//因为是在排序数组中寻找，所以可以利用二分查找算法</span><span class="hljs-comment">//通过查找第一个k值元素的下标和最后一个k值元素的下标，求出个数</span><span class="hljs-comment">//时间复杂度O(logn)</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-comment">//寻找第一个k值元素的下标</span><span class="hljs-built_in">int</span> FirstKIndex(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; data, <span class="hljs-built_in">int</span> k, <span class="hljs-built_in">int</span> left, <span class="hljs-built_in">int</span> right)&#123;<span class="hljs-keyword">if</span> (left &gt; right)<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-built_in">int</span> middleIndex = (right - left) / <span class="hljs-number">2</span> + left;<span class="hljs-comment">//防止值溢出</span><span class="hljs-built_in">int</span> middleValue = data[middleIndex];<span class="hljs-comment">//获取中位数的值</span><span class="hljs-keyword">if</span> (middleValue == k)<span class="hljs-comment">//如果中位数与k相等，则将中位数的前一个数与k比较</span>&#123;<span class="hljs-comment">//如果中位数的前一个数不等于k或中位数就是下标0元素，此时中位数的下标就是第一个k值元素的下标</span><span class="hljs-keyword">if</span> ((middleIndex &gt; <span class="hljs-number">0</span> &amp;&amp; data[middleIndex - <span class="hljs-number">1</span>] != k) || middleIndex == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> middleIndex;<span class="hljs-keyword">else</span><span class="hljs-comment">//若相等，就继续寻找</span>right = middleIndex - <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (middleValue &gt; k)<span class="hljs-comment">//如果中位数大于k，则说明第一个k值元素在中位数的前面</span>right = middleIndex - <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span><span class="hljs-comment">//如果中位数小于k，则说明第一个k值元素在中位数的后面</span>left = middleIndex + <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> FirstKIndex(data, k, left, right);<span class="hljs-comment">//递归继续寻找</span>&#125;<span class="hljs-comment">//寻找最后一个k值元素的下标</span><span class="hljs-built_in">int</span> LastKIndex(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; data, <span class="hljs-built_in">int</span> k, <span class="hljs-built_in">int</span> left, <span class="hljs-built_in">int</span> right)&#123;<span class="hljs-keyword">if</span> (left &gt; right)<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-built_in">int</span> middleIndex = (right - left) / <span class="hljs-number">2</span> + left;<span class="hljs-built_in">int</span> middleValue = data[middleIndex];<span class="hljs-keyword">if</span> (middleValue == k)<span class="hljs-comment">//如果中位数与k相等，则将中位数的后一个数与k比较</span>&#123;<span class="hljs-comment">//如果中位数的后一个数不等于k或中位数就是数组中的最后一个元素，此时中位数的下标就是最后一个k值元素的下标</span><span class="hljs-keyword">if</span> ((middleIndex &lt; data.size() - <span class="hljs-number">1</span> &amp;&amp; data[middleIndex + <span class="hljs-number">1</span>] != k) || middleIndex == data.size() - <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> middleIndex;<span class="hljs-keyword">else</span><span class="hljs-comment">//若相等，就继续寻找</span>left = middleIndex + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (middleValue &gt; k)<span class="hljs-comment">//如果中位数大于k，则说明最后一个k值元素在中位数的前面</span>right = middleIndex - <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span><span class="hljs-comment">//如果中位数小于k，则说明最后一个k值元素在中位数的后面</span>left = middleIndex + <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> LastKIndex(data, k, left, right);<span class="hljs-comment">//递归继续寻找</span>&#125;<span class="hljs-built_in">int</span> GetNumberOfK(vector&lt;<span class="hljs-built_in">int</span>&gt; data, <span class="hljs-built_in">int</span> k)&#123;<span class="hljs-built_in">int</span> num = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (data.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> first = FirstKIndex(data, k, <span class="hljs-number">0</span>, data.size() - <span class="hljs-number">1</span>);<span class="hljs-comment">//获取第一个k值元素的下标</span><span class="hljs-built_in">int</span> last = LastKIndex(data, k, <span class="hljs-number">0</span>, data.size() - <span class="hljs-number">1</span>);<span class="hljs-comment">//获取最后一个k值元素的下标</span><span class="hljs-keyword">if</span> (first &gt; <span class="hljs-number">-1</span> &amp;&amp; last &gt; <span class="hljs-number">-1</span>)num = last - first + <span class="hljs-number">1</span>;计算k值元素个数<span class="hljs-keyword">return</span> num;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（36）两个链表的第一个公共结点</title>
    <link href="/2020/07/01/the-first-common-node-of-two-linked-lists/"/>
    <url>/2020/07/01/the-first-common-node-of-two-linked-lists/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入两个链表，找出它们的第一个公共结点。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs reasonml"><span class="hljs-comment">//节点结构体定义</span><span class="hljs-keyword">struct</span> ListNode &#123;<span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<span class="hljs-keyword">struct</span> ListNode *next;<span class="hljs-constructor">ListNode(<span class="hljs-params">int</span> <span class="hljs-params">x</span>)</span> : <span class="hljs-keyword">val</span>(x), next(NULL) &#123;&#125;&#125;;</code></pre><p>方法一</p><pre><code class="hljs cpp"><span class="hljs-comment">//利用两个栈，从头开始遍历两个链表，将其节点的地址分别存入两个栈中</span><span class="hljs-comment">//最终链表尾在栈顶</span><span class="hljs-comment">//依次出栈，记录公共节点的地址，最后的值就是两个链表的第一个公共节点</span><span class="hljs-comment">//注意</span><span class="hljs-comment">//1.判断链表是否存在</span><span class="hljs-comment">//2.有可能不存在公共节点</span><span class="hljs-comment">//3.两个链表有可能不一样长</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function">ListNode* <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">(ListNode* pHead1, ListNode* pHead2)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//防御性动作，判断链表是否存在</span><span class="hljs-keyword">if</span> (pHead1 == <span class="hljs-literal">NULL</span> || pHead2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-built_in">stack</span>&lt;ListNode*&gt; p1Stk;<span class="hljs-built_in">stack</span>&lt;ListNode*&gt; p2Stk;<span class="hljs-keyword">while</span> (pHead1 != <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//遍历pHead1链表，记录节点地址并入栈</span>&#123;p1Stk.push(pHead1);pHead1 = pHead1-&gt;next;&#125;<span class="hljs-keyword">while</span> (pHead2 != <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//遍历pHead2链表，记录节点地址并入栈</span>&#123;p2Stk.push(pHead2);pHead2 = pHead2-&gt;next;&#125;ListNode* tmp = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//记录公共节点的地址</span><span class="hljs-keyword">while</span> (!p1Stk.empty() &amp;&amp; !p2Stk.empty())<span class="hljs-comment">//有可能出现不存在公共节点的情况</span>&#123;<span class="hljs-keyword">if</span> (p1Stk.top() == p2Stk.top())<span class="hljs-comment">//栈顶元素值相等</span>&#123;tmp = p1Stk.top();<span class="hljs-comment">//记录值</span>p1Stk.pop();<span class="hljs-comment">//出栈顶元素</span>p2Stk.pop();<span class="hljs-comment">//出栈顶元素</span><span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//如果栈顶元素不相等，则终止循环，return公共节点</span><span class="hljs-keyword">return</span> tmp;&#125;<span class="hljs-keyword">return</span> tmp;<span class="hljs-comment">//有可能出现不存在公共节点的情况</span>&#125;&#125;;</code></pre><p>方法二</p><pre><code class="hljs zephir"><span class="hljs-comment">//方法一中使用了辅助内存空间，使得空间复杂度为O(m+n)</span><span class="hljs-comment">//方法二中保证遍历链表的指针从相同个数的节点开始遍历，即让两个链表的长度变得一样</span><span class="hljs-comment">//第一次遍历计算出两个链表的长的</span><span class="hljs-comment">//第二次遍历，让长的链表先移动差值个节点，然后两个链表在一同开始遍历</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">public</span>:ListNode* FindFirstCommonNode(ListNode* pHead1, ListNode* pHead2)&#123;<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">if</span> (pHead1 == <span class="hljs-keyword">NULL</span> || pHead2 == <span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">NULL</span>;<span class="hljs-keyword">int</span> node1Num = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录pHead1的长度</span><span class="hljs-keyword">int</span> node2Num = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录pHead2的长度</span>ListNode* p1 = pHead1;ListNode* p2 = pHead2;<span class="hljs-keyword">while</span> (p1 != <span class="hljs-keyword">NULL</span>)<span class="hljs-comment">//第一次遍历</span>&#123;++node1Num;p1 = p1-&gt;next;&#125;<span class="hljs-keyword">while</span> (p2 != <span class="hljs-keyword">NULL</span>)<span class="hljs-comment">//第二次遍历</span>&#123;++node2Num;p2 = p2-&gt;next;&#125;p1 = pHead1;p2 = pHead2;<span class="hljs-keyword">int</span> tmp = node1Num - node2Num;<span class="hljs-comment">//计算两个链表的长度差</span><span class="hljs-keyword">while</span> (tmp &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//pHead1长时，先移动</span>&#123;p1 = p1-&gt;next;--tmp;&#125;<span class="hljs-keyword">while</span> (tmp &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">//pHead2长时，先移动</span>&#123;p2 = p2-&gt;next;++tmp;&#125;<span class="hljs-keyword">while</span> (p1 != p2)<span class="hljs-comment">//之后开始一同移动</span>&#123;p1 = p1-&gt;next;p2 = p2-&gt;next;&#125;<span class="hljs-keyword">return</span> p1;<span class="hljs-comment">//有可能不存在公共节点</span>&#125;&#125;;</code></pre><p>方法三</p><pre><code class="hljs php"><span class="hljs-comment">//大神做法！！！</span><span class="hljs-comment">//代码如此简单。。但想法如此巧妙！！！</span><span class="hljs-comment">//不再利用第一次遍历，来记录两个链表的长度</span><span class="hljs-comment">//而是利用类似判断链表是否有环的思路（不知道这样理解对不对）</span><span class="hljs-comment">//当没有公共节点时，依旧返回NULL                                                                                                                                            </span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">public</span>:ListNode* FindFirstCommonNode(ListNode *pHead1, ListNode *pHead2) &#123;ListNode *p1 = pHead1;ListNode *p2 = pHead2;<span class="hljs-keyword">while</span> (p1 != p2) &#123;p1 = (p1 == <span class="hljs-keyword">NULL</span> ? pHead2 : p1-&gt;next);p2 = (p2 == <span class="hljs-keyword">NULL</span> ? pHead1 : p2-&gt;next);&#125;<span class="hljs-keyword">return</span> p1;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（35）数组中的逆序对</title>
    <link href="/2020/07/01/reverse-pair-in-array/"/>
    <url>/2020/07/01/reverse-pair-in-array/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。即输出P%1000000007</strong></p></blockquote><p><strong>输入描述：</strong></p><blockquote><p><strong>题目保证输入的数组中没有的相同的数字</strong></p></blockquote><p><strong>数据范围：</strong></p><blockquote><p><strong>对于%50的数据,size&lt;=10^4</strong><br><strong>对于%75的数据,size&lt;=10^5</strong><br><strong>对于%100的数据,size&lt;=2*10^5</strong></p></blockquote><p><strong>示例：</strong></p><blockquote><p><strong>输入</strong><br><strong>1,2,3,4,5,6,7,0</strong><br><strong>输出</strong><br><strong>7</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs arduino"><span class="hljs-comment">//利用归并排序的思想，将数据分割成小数组，将小数组的逆序对求出，再依次合并小数组，求出更大范围数组中的逆序对</span><span class="hljs-comment">//保证每一个分割的数组都是有序的，合并时继续保证有序</span><span class="hljs-comment">//具体过程见注释</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">InversePairsCore</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;data, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;copy, <span class="hljs-keyword">long</span> start, <span class="hljs-keyword">long</span> <span class="hljs-built_in">end</span>)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (start == <span class="hljs-built_in">end</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//判断起始下标和终止下标是否重合，重合时即为无法再分割，结束递归</span><span class="hljs-keyword">long</span> length = (<span class="hljs-built_in">end</span> - start)<span class="hljs-comment">//计算当前分割的数组中的元素个数</span><span class="hljs-comment">//左右范围继续递归</span><span class="hljs-keyword">long</span> left = InversePairsCore(copy, data, start, start + length);<span class="hljs-keyword">long</span> right = InversePairsCore(copy, data, start + length + <span class="hljs-number">1</span>, <span class="hljs-built_in">end</span>);<span class="hljs-keyword">long</span> crossCount = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录当前小数组内的逆序对个数       </span><span class="hljs-keyword">long</span> i = start + length;<span class="hljs-comment">//合并时，左数组的最后一个元素的下标</span><span class="hljs-keyword">long</span> j = <span class="hljs-built_in">end</span>;<span class="hljs-comment">//合并时，右数组的最后一个元素的下标</span><span class="hljs-keyword">long</span> temp = <span class="hljs-built_in">end</span>; <span class="hljs-comment">//记录合并后的元素放置下标</span><span class="hljs-comment">//开始合并，判断左数组的i下标元素是否大于右数组的j下标元素</span><span class="hljs-keyword">while</span> (i &gt;= start &amp;&amp; j &gt;= start + length + <span class="hljs-number">1</span>)&#123;   <span class="hljs-keyword">if</span> (data[i] &gt; data[j]) <span class="hljs-comment">//若大于，将i下标元素下放到辅助数组中</span>&#123;copy[temp--] = data[i--];<span class="hljs-comment">//i前移</span>crossCount += j - start - length;<span class="hljs-comment">//计算逆序对，因为左右数组内都是有序的，所以i下标元素大于在右数组内j下标元素之前的所有元素</span>&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//否则，将j下标元素下放到辅助数组中</span>copy[temp--] = data[j--];&#125;<span class="hljs-comment">//将剩余的元素下放到辅助数组内</span><span class="hljs-keyword">while</span> (i &gt;= start)copy[temp--] = data[i--];<span class="hljs-keyword">while</span> (j &gt;= start + length + <span class="hljs-number">1</span>)copy[temp--] = data[j--];<span class="hljs-keyword">return</span> (left + right + crossCount) % <span class="hljs-number">1000000007</span>;<span class="hljs-comment">//返回左右数组内部的逆序对个数与当前合并时数组中的逆序对个数之和，按照提述取模</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InversePairs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;data)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//当没有数据时，返回0个</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//当只有一个数据时，返回1个</span><span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; copy(data);<span class="hljs-comment">//借用辅助数组空间，用来保存合并后的数据</span><span class="hljs-keyword">return</span> InversePairsCore(copy, data, <span class="hljs-number">0</span>, data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);&#125;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（34）第一个只出现一次的字符位置</title>
    <link href="/2020/07/01/the-first-character-position-that-appears-only-once/"/>
    <url>/2020/07/01/the-first-character-position-that-appears-only-once/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs arduino"><span class="hljs-comment">//在线测试用例非常的坑。。。→_→</span><span class="hljs-comment">//1.需要返回的是下标</span><span class="hljs-comment">//2.测试用例中区分大小写</span><span class="hljs-comment">//将所有的字符元素存放到&lt;key, value&gt;中，字符元素值为key，自定义结构体indexAndTime为value</span><span class="hljs-comment">//indexAndTime中保存此字符第一次出现的下标和一共出现的次数</span><span class="hljs-comment">//最后遍历str，在map中寻找字符元素，判断每一个元素的iAT中的time是否为1，若为1，return firstIndex</span><span class="hljs-comment">//注意</span><span class="hljs-comment">//有可能字符中没有只出现一次的字符，所以最后要有return -1！</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">indexAndTime</span>//自定义结构体，记录字符元素第一次出现的下标和次数</span><span class="hljs-class">&#123;</span><span class="hljs-keyword">int</span> firstIndex;<span class="hljs-keyword">int</span> time;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FirstNotRepeatingChar</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (str.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//防御性动作</span><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>, indexAndTime&gt; m;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); ++i)&#123;<span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">find</span>(str[i]) != m.<span class="hljs-built_in">end</span>())<span class="hljs-comment">//若在map中找到，就直接++time</span>++(m[str[i]].time);<span class="hljs-keyword">else</span><span class="hljs-comment">//若未找到，就添加新的&lt;key, value&gt;</span>&#123;indexAndTime iAT = &#123; i, <span class="hljs-number">1</span> &#125;;m.insert(make_pair(str[i], iAT));&#125;&#125;<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>, indexAndTime&gt;::iterator itMap;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; str.<span class="hljs-built_in">size</span>(); ++j)<span class="hljs-comment">//寻找第一个只出现一次的字符的下标</span>&#123;itMap = m.<span class="hljs-built_in">find</span>(str[j]);<span class="hljs-keyword">if</span> (itMap-&gt;second.time == <span class="hljs-number">1</span>)<span class="hljs-comment">//找到返回下标</span><span class="hljs-keyword">return</span> itMap-&gt;second.firstIndex;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//特殊情况，有可能没有出现一次的情况！</span>&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一次技术面试</title>
    <link href="/2020/06/30/the-first-technical-interview/"/>
    <url>/2020/06/30/the-first-technical-interview/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>一上来没有自我介绍。。直接就开始了。。套路不对啊。。→_→</em> *</strong></p><ol><li><p>问会哪些语言，JAVA、python、脚本语言会不会？（尴尬。。都只是了解）</p></li><li><p>说一下TCP的三次握手和四次挥手？（就开始说每一步的流程和状态变化，顺便再说几句三次握手和四次挥手的原因）</p></li><li><p>简单说一下TCP和UDP的区别和特点（可能是我第一个问题说的时间太长了。。。还特别强调了“简单”。。，）</p></li><li><p>说一下指针和引用的区别（自己也带入const加以解释，但感觉自己这块说的不是很好。。应该再回答的有条理一些）</p></li><li><p>指针和++元素符结合时的问题（带入了具体例子，这块说了好几个例子，类型转化、解引用什么的。。最后一个没听清题也就回答了，然后面试官问你确定吗？我就让面试官重复了一遍问题。。。重新回答）</p></li><li><p>进程和线程的区别（直接就从内核源码切进去，之后才解释一般的那种回答。面试官在这说“看来内核源码看的挺多的”。嘿嘿。。）</p></li><li><p>说一下重载和覆盖的区别（从编译器的角度切入，其他的就正常回答）</p></li><li><p>union共用体在小端存储的例子的打印值（说了union的作用和小端存储。这块儿真是尴尬。。到最后还是没有说出正确答案。。说实话这会儿确实有点蒙。。没有一开始思路清晰）</p></li><li><p>C++如何实现接口和抽象类（喵喵喵？这不是JAVA的概念吗？？？想了一会类比成C++，就开始从虚函数说，然后把自己知道的JAVA接口的作用和设计意图说了说）</p></li><li><p>BST树的查询时间复杂度（然后就没了。。。）</p></li><li><p>知不知道dynamic_cast和static_cast（没听懂。。就问面试官是不是static？然后就说是静态、动态的类型转换。。这个是真不知道。。。就说记得是C++11的，只了解过，没实际用过。。）</p></li><li><p>知不知道数据库算法？（喵喵喵？？？只能说自己简单的使用过常用的查询、添加、删除。。。）</p></li><li><p>知不知道MVC模式（抽象成观察者监听者模式解释。。。）</p></li><li><p>知不知道单例模式（一步步的进行版本升级。。最后说了说线程安全）</p></li><li><p>最后就问有没有团队开发经验，有没有用过git</p></li><li><p>自己今后想往哪方面发展（我也问了面试官公司的后台发展）</p></li><li><p>对薪资待遇的期望</p></li><li><p>最后有没有想问的</p></li></ol><p><strong>面试官很亲近，整个面试大约30min，我有说的不对的地方也都会给我说，总体感觉很不错！</strong></p><p>第一次技术面试。。今后继续加油！</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（33）丑数</title>
    <link href="/2020/06/30/ugly-number/"/>
    <url>/2020/06/30/ugly-number/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs arduino"><span class="hljs-comment">//不用每一个数字都进行判断</span><span class="hljs-comment">//而将丑数进行有序的排列，存储到set中</span><span class="hljs-comment">//根据定义，丑数乘以2或3或5后，还是丑数</span><span class="hljs-comment">//所以初始化第一个丑数1</span><span class="hljs-comment">//由三种倍数关系计算出第一个大于当前最大丑数的丑数</span><span class="hljs-comment">//将此丑数插入</span><span class="hljs-comment">//这三个因数由三个迭代器表示，为第一个乘以倍数后大于当前最大丑数的丑数</span><span class="hljs-comment">//这样可以减少重复计算比较小的丑数</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2, <span class="hljs-keyword">int</span> num3)</span><span class="hljs-comment">//判断哪一个丑数最小</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> <span class="hljs-built_in">min</span> = num1 &lt; num2 ? num1 : num2;<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span> &lt; num3 ? <span class="hljs-built_in">min</span> : num3;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetUglyNumber_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (index &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//防御性动作</span><span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; se;se.insert(<span class="hljs-number">1</span>);<span class="hljs-comment">//初始化第一个丑数1</span><span class="hljs-comment">//三个迭代器表示不同倍数关系的</span><span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it2 = se.<span class="hljs-built_in">begin</span>();<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it3 = se.<span class="hljs-built_in">begin</span>();<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it5 = se.<span class="hljs-built_in">begin</span>();<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator itTmp;<span class="hljs-keyword">while</span> (index &gt; se.<span class="hljs-built_in">size</span>())<span class="hljs-comment">//判断是否为第index个丑数</span>&#123;<span class="hljs-comment">//计算出当前最大丑数的下一个丑数</span><span class="hljs-keyword">int</span> <span class="hljs-built_in">min</span> = minNumber(*it2 * <span class="hljs-number">2</span>, *it3 * <span class="hljs-number">3</span>, *it5 * <span class="hljs-number">5</span>);se.insert(<span class="hljs-built_in">min</span>);<span class="hljs-comment">//插入min</span>itTmp = --se.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//将三个迭代器更新到相应位置</span><span class="hljs-keyword">while</span> (*it2 * <span class="hljs-number">2</span> &lt;= *itTmp)++it2;<span class="hljs-keyword">while</span> (*it3 * <span class="hljs-number">3</span> &lt;= *itTmp)++it3;<span class="hljs-keyword">while</span> (*it5 * <span class="hljs-number">5</span> &lt;= *itTmp)++it5;&#125;<span class="hljs-keyword">return</span> *(--se.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//返回第index个丑数的值</span>&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转】What really happens when you navigate to a URL</title>
    <link href="/2020/06/30/what-really-happens-when-you-navigate-to-a-URL/"/>
    <url>/2020/06/30/what-really-happens-when-you-navigate-to-a-URL/</url>
    
    <content type="html"><![CDATA[<p><strong><strong>本文将深入理解当你输入一个网址的时候，后台到底发生了什么事。。。→_→</strong></strong></p><p><strong>原文传送门</strong>：<a href="http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/" target="_blank" rel="noopener">What really happens when you navigate to a URL</a></p><ol><li><p>首先，<strong>在浏览器中输入网址</strong>:</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE3MTA0OTEzMzk2?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="在浏览器中输入网址"></p></li><li><p><strong>浏览器查找域名的IP地址</strong></p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE3MTA1MzU2NDk5?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="浏览器查找域名的IP地址"></p><p> DNS查找过程如下：</p><ul><li><strong>浏览器缓存</strong> – 浏览器会缓存DNS记录一段时间。 有趣的是，操作系统没有告诉浏览器储存DNS记录的时间，这样不同浏览器会储存个自固定的一个时间（2分钟到30分钟不等）。</li></ul></li></ol><ul><li><p><strong>系统缓存</strong> – 如果在浏览器缓存里没有找到需要的记录，浏览器会做一个系统调用（windows里是gethostbyname）。这样便可获得系统缓存中的记录。</p></li><li><p><strong>路由器缓存</strong> – 接着，前面的查询请求发向路由器，它一般会有自己的DNS缓存。</p></li><li><p><strong>ISP DNS 缓存</strong> – 接下来要check的就是ISP缓存DNS的服务器。在这一般都能找到相应的缓存记录。</p></li><li><p><strong>递归搜索</strong> – <strong>你的ISP的DNS服务器从跟域名服务器开始进行递归搜索</strong>。一般DNS服务器的缓存中会有.com域名服务器中的域名，所以到顶级服务器的匹配过程不是那么必要了。</p><p>  DNS递归查找如下图所示：</p><p>  <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE3MTA1NTAzODc3?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="浏览器给web服务器发送一个HTTP请求"></p><p>  DNS有一点令人担忧，这就是像wikipedia.org 或者 facebook.com这样的整个域名看上去只是对应一个单独的IP地址。还好，有几种方法可以消除这个瓶颈：</p><p>  负载平衡器 是以一个特定IP地址进行侦听并将网络请求转发到集群服务器上的硬件设备。 一些大型的站点一般都会使用这种昂贵的高性能负载平衡器。</p><p>  地理 DNS 根据用户所处的地理位置，通过把域名映射到多个不同的IP地址提高可扩展性。这样不同的服务器不能够更新同步状态，但映射静态内容的话非常好。</p><p>  Anycast 是一个IP地址映射多个物理主机的路由技术。 美中不足，Anycast与TCP协议适应的不是很好，所以很少应用在那些方案中。</p><p>  大多数DNS服务器使用Anycast来获得高效低延迟的DNS查找。</p></li></ul><ol start="3"><li><p><strong>浏览器给web服务器发送一个HTTP请求</strong></p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE3MTExMjM3NDc2?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="浏览器给Web服务器发送一个HTTP请求"></p><p> <strong>因为像Facebook主页这样的动态页面，打开后在浏览器缓存中很快甚至马上就会过期，毫无疑问他们不能从缓存中读取。</strong></p><p> 所以，浏览器将把请求发送到Facebook所在的服务器：</p> <pre><code class="hljs yaml"><span class="hljs-string">GET</span> <span class="hljs-string">http://facebook.com/</span> <span class="hljs-string">HTTP/1.1</span> <span class="hljs-attr">Accept:</span> <span class="hljs-string">application/x-ms-application,</span> <span class="hljs-string">image/jpeg,</span> <span class="hljs-string">application/xaml+xml,</span> <span class="hljs-string">[...]</span> <span class="hljs-attr">User-Agent:</span> <span class="hljs-string">Mozilla/4.0</span> <span class="hljs-string">(compatible;</span> <span class="hljs-string">MSIE</span> <span class="hljs-number">8.0</span><span class="hljs-string">;</span> <span class="hljs-string">Windows</span> <span class="hljs-string">NT</span> <span class="hljs-number">6.1</span><span class="hljs-string">;</span> <span class="hljs-string">WOW64;</span> <span class="hljs-string">[...]</span> <span class="hljs-attr">Accept-Encoding:</span> <span class="hljs-string">gzip,</span> <span class="hljs-string">deflate</span> <span class="hljs-attr">Connection:</span> <span class="hljs-string">Keep-Alive</span> <span class="hljs-attr">Host:</span> <span class="hljs-string">facebook.com</span> <span class="hljs-attr">Cookie:</span> <span class="hljs-string">datr=1265876274-[...];</span> <span class="hljs-string">locale=en_US;</span> <span class="hljs-string">lsd=WW[...];</span> <span class="hljs-string">c_user=2101[...]</span></code></pre><ul><li><p><strong>GET 这个请求定义了要读取的URL</strong>：“<a href="http://facebook.com/“" target="_blank" rel="noopener">http://facebook.com/“</a></p></li><li><p><strong>浏览器自身定义 (User-Agent 头)，和它希望接受什么类型的相应 (Accept and Accept-Encoding 头)。</strong></p></li><li><p><strong>Connection 头要求服务器为了后边的请求不要关闭TCP连接</strong></p></li><li><p><strong>请求中也包含浏览器存储的该域名的cookies</strong> 。在不同页面请求当中，<strong>cookies是与跟踪一个网站状态相匹配的键值</strong>。这样cookies会存储登录用户名，服务器分配的密码和一些用户设置等。<strong>Cookies会以文本文档形式存储在客户机里，每次请求时发送给服务器。</strong></p></li></ul></li><li><p><strong>服务器的永久重定向响应</strong><br> <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE3MTEyMTQ2NDY3?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="服务器的永久重定位响应"></p><p> 为什么服务器一定要重定向而不是直接发会用户想看的网页内容呢？</p><ul><li><p><strong>搜索引擎排名有关</strong>。如果一个页面有两个地址，就像<a href="http://www.igoro.com/" target="_blank" rel="noopener">http://www.igoro.com/</a> 和<a href="http://igoro.com/，搜索引擎会认为它们是两个网站,结果造成每一个的搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是" target="_blank" rel="noopener">http://igoro.com/，搜索引擎会认为它们是两个网站,结果造成每一个的搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是</a> 什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下</p></li><li><p><strong>用不同的地址会造成缓存友好性变差</strong>。当一个页面有好几个名字时，它可能会在缓存里出现好几次。</p></li></ul></li><li><p><strong>浏览器跟踪重定向地址</strong></p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE3MTEyMjM4MDc2?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="浏览器跟踪重定向地址"></p><p> 现在，浏览器知道了“<a href="http://www.facebook.com/”才是要访问的正确地址，所以它会发送另一个获取请求：" target="_blank" rel="noopener">http://www.facebook.com/”才是要访问的正确地址，所以它会发送另一个获取请求：</a></p></li><li><p><strong>服务器“处理”请求</strong></p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE3MTEyMzE5NTIx?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="服务器处理请求"></p><p> <strong>服务器接收到获取请求，然后处理并返回一个响应。</strong></p><p> <strong>请求处理阅读请求及它的参数和cookies。它会读取也可能更新一些数据，并讲数据存储在服务器上。然后，需求处理会生成一个HTML响应。</strong></p></li><li><p><strong>服务器发回一个HTML响应</strong></p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE3MTEyNDA1NDU1?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="服务器发回HTML响应"></p></li><li><p><strong>浏览器开始显示HTML</strong></p><p> <strong>在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了</strong></p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE3MTEyNDU4Mzk0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="浏览器显示HTML"></p></li><li><p><strong>浏览器发送获取嵌入在HTML中的对象</strong></p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE3MTEyNTE5MTc0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="浏览器发送获取嵌入在HTML中的对象"></p><p> <strong>在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签</strong>。这时，<strong>浏览器会发送一个获取请求来重新获得这些文件</strong>。这些都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等…</p><p> <strong>但不像动态页面那样，静态文件会允许浏览器对其进行缓存。有的文件可能会不需要与服务器通讯，而从缓存中直接读取。服务器的响应中包含了静态文件保存的期限信息，所以浏览器知道要把它们缓存多长时间。还有，每个响应都可能包含像版本号一样工作的ETag头（被请求变量的实体值），如果浏览器观察到文件的版本 ETag信息已经存在，就马上停止这个文件的传输。</strong></p></li><li><p><strong>浏览器发送异步（AJAX）请求</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE3MTEyNjA3MTE1?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="浏览器发送异步（AJAX）请求"></p><p>在Web 2.0伟大精神的指引下，页面显示完成后客户端仍与服务器端保持着联系。</p><p>“AJAX”–“异步JavaScript 和 XML”，把数据从服务器端推送到客户端。因为<strong>HTTP是一个请求-响应协议，所以服务器不能把新消息发给客户，取而代之的是客户端不得不隔几秒就轮询下服务器端看自己有没有新消息。如果当被轮询时服务器没有新消息，它就不理这个客户端。而当尚未超时的情况下收到了该客户的新消息，服务器就会找到未完成的请求，把新消息做为响应返回给客户端。</strong></p></li></ol><p><strong><strong>这篇总结真的很好，学习了。。。</strong></strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——观察者监听者模式</title>
    <link href="/2020/06/30/observer-listener-mode/"/>
    <url>/2020/06/30/observer-listener-mode/</url>
    
    <content type="html"><![CDATA[<p><em>** *本篇总结一下基于多线程的线程安全的观察者监听者模式。。。→_→</em> **</p><p>在阅读本文之前，需要先了解相关知识。。请戳传送门——<a href="http://blog.csdn.net/kongkongkkk/article/details/75135327" target="_blank" rel="noopener">智能指针的交叉引用问题及解决方法</a></p><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> weak_ptr&lt;T&gt; &amp;left, <span class="hljs-keyword">const</span> weak_ptr&lt;T&gt; &amp;right)&#123;<span class="hljs-keyword">return</span> left.lock() == right.lock();&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Listener</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:Listener(<span class="hljs-built_in">string</span> name) :_name(name) &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> msgid)</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-built_in">string</span> _name;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Listener1</span> :</span> <span class="hljs-keyword">public</span> Listener&#123;<span class="hljs-keyword">public</span>:Listener1(<span class="hljs-built_in">string</span> name) :Listener(name) &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> msgid)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; _name &lt;&lt; <span class="hljs-string">" "</span>;<span class="hljs-keyword">switch</span> (msgid)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" recv 0 msg!"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" recv 1 msg!"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" recv 2 msg!"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Listener2</span> :</span> <span class="hljs-keyword">public</span> Listener&#123;<span class="hljs-keyword">public</span>:Listener2(<span class="hljs-built_in">string</span> name) :Listener(name) &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> msgid)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; _name &lt;&lt; <span class="hljs-string">" "</span>;<span class="hljs-keyword">switch</span> (msgid)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" recv 0 msg!"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" recv 2 msg!"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Listener3</span> :</span> <span class="hljs-keyword">public</span> Listener&#123;<span class="hljs-keyword">public</span>:Listener3(<span class="hljs-built_in">string</span> name) :Listener(name) &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> msgid)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; _name &lt;&lt; <span class="hljs-string">" "</span>;<span class="hljs-keyword">switch</span> (msgid)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" recv 1 msg!"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" recv 2 msg!"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerListener</span><span class="hljs-params">(weak_ptr&lt;Listener&gt; lp, <span class="hljs-keyword">int</span> msgid)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;weak_ptr&lt;Listener&gt;&gt;&gt;::iterator it = _ObserMap.<span class="hljs-built_in">find</span>(msgid);<span class="hljs-keyword">if</span> (it == _ObserMap.<span class="hljs-built_in">end</span>())&#123;<span class="hljs-built_in">vector</span>&lt;weak_ptr&lt;Listener&gt;&gt; vec;vec.push_back(lp);_ObserMap.insert(make_pair(msgid, vec));&#125;<span class="hljs-keyword">else</span>&#123;it-&gt;second.push_back(lp);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteListener</span><span class="hljs-params">(weak_ptr&lt;Listener&gt; lp, <span class="hljs-keyword">int</span> msgid)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;weak_ptr&lt;Listener&gt;&gt;&gt;::iterator it = _ObserMap.<span class="hljs-built_in">find</span>(msgid);<span class="hljs-keyword">if</span> (it != _ObserMap.<span class="hljs-built_in">end</span>())&#123;<span class="hljs-built_in">vector</span>&lt;weak_ptr&lt;Listener&gt;&gt;::iterator vecIt = <span class="hljs-built_in">find</span>(it-&gt;second.<span class="hljs-built_in">begin</span>(), it-&gt;second.<span class="hljs-built_in">end</span>(), lp);<span class="hljs-keyword">if</span> (vecIt != it-&gt;second.<span class="hljs-built_in">end</span>())it-&gt;second.erase(vecIt);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispatchMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> msgid)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;weak_ptr&lt;Listener&gt;&gt;&gt;::iterator it = _ObserMap.<span class="hljs-built_in">find</span>(msgid);<span class="hljs-keyword">if</span> (it != _ObserMap.<span class="hljs-built_in">end</span>())&#123;<span class="hljs-built_in">vector</span>&lt;weak_ptr&lt;Listener&gt;&gt;::iterator vecIt = it-&gt;second.<span class="hljs-built_in">begin</span>();<span class="hljs-keyword">for</span> (; vecIt != it-&gt;second.<span class="hljs-built_in">end</span>(); ++vecIt)&#123;<span class="hljs-built_in">shared_ptr</span>&lt;Listener&gt; lp = (*vecIt).lock();<span class="hljs-keyword">if</span> (lp != <span class="hljs-literal">NULL</span>) lp-&gt;handleMessage(msgid);&#125;&#125;&#125;<span class="hljs-keyword">private</span>:<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;weak_ptr&lt;Listener&gt;&gt;&gt; _ObserMap;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;Listener&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Listener1(<span class="hljs-string">"Listener1"</span>))</span></span>;<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;Listener&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Listener1(<span class="hljs-string">"Listener2"</span>))</span></span>;<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;Listener&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Listener1(<span class="hljs-string">"Listener3"</span>))</span></span>;Observer obser;obser.registerListener(p1, <span class="hljs-number">0</span>);obser.registerListener(p1, <span class="hljs-number">1</span>);obser.registerListener(p1, <span class="hljs-number">2</span>);obser.registerListener(p2, <span class="hljs-number">0</span>);obser.registerListener(p2, <span class="hljs-number">2</span>);obser.registerListener(p3, <span class="hljs-number">1</span>);obser.registerListener(p3, <span class="hljs-number">2</span>);<span class="hljs-comment">//obser.deleteListener(p1, 2);</span><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<span class="hljs-keyword">int</span> msgid;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"msgid:"</span>;<span class="hljs-built_in">cin</span> &gt;&gt; msgid;obser.dispatchMessage(msgid);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>写代码时候的坑：<a href="https://stackoverflow.com/questions/44903132/why-overloaded-operator-for-stdweak-ptr-instantiated-with-type-defined-in-na" target="_blank" rel="noopener">代码坑</a></p>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智能指针的交叉引用问题及解决方法</title>
    <link href="/2020/06/30/smart-pointer/"/>
    <url>/2020/06/30/smart-pointer/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>本篇讨论一下因为智能指针的交叉引用造成的内存泄漏问题和解决方法。。。→_→</em> *</strong></p><p>讨论这个问题之前，先来看一段简单的代码</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">shared_ptr</span>&lt;B&gt; _bptr;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">shared_ptr</span>&lt;A&gt; _aptr;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;A&gt; <span class="hljs-title">aptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;B&gt; <span class="hljs-title">bptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;aptr-&gt;_bptr = bptr;bptr-&gt;_aptr = aptr;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li><p>类A中有一个指向类B的shared_ ptr强类型智能指针，类B中有一个指向类A的shared_ ptr强类型智能指针</p></li><li><p>经过执行，<strong>有两个强智能指针指向了对象A，对象A的引用计数为2。也有两个强智能指针指向了对象B，对象B的引用计数为2</strong>。此时对象A与对象B的关系如图所示</p><p>  <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE0MjAxOTUwMjE3?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="交叉引用"></p></li><li><p><strong>当主函数return返回后，对象A的引用计数减一变为1，对象B的引用计数减一变为1，此时因为引用计数不为，所以不能析构对象释放内存，程序结束造成内存泄漏</strong></p><p>  <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE0MjIzODI2Nzk3?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="交叉引用造成的内存泄漏"></p><p>  <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE0MjIzODU3NjA4?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="内存泄漏"></p></li></ul><p>解决方法</p><ul><li><p><strong>将类A和类B中的shared_ptr强智能指针都换成weak_ptr弱智能指针</strong></p>  <pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">A</span>&#123;<span class="hljs-keyword">public</span>:    weak_ptr&lt;B&gt; _bptr;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-symbol">B</span>&#123;<span class="hljs-keyword">public</span>:weak_ptr&lt;A&gt; _aptr;&#125;;</code></pre></li><li><p><strong>weak_ptr弱智能指针，虽然有引用计数，但实际上它并不增加计数，而是只观察对象的引用计数</strong>。所以此时对象A的引用计数只为1，对象B的引用计数也只为1。此时对象A与对象B的关系如图所示</p><p>  <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE0MjI0NTA0MDQw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="解决交叉引用的方法"></p></li><li><p>当主函数return返回后，<strong>对象A的引用计数减一变为0，所以正常析构对象A；对象B的引用计数减一变为0，所以正常析构对象B</strong>，此时不会造成内存泄漏</p><p>  <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzE0MjI0NjAxMTYw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="解决后的结果"></p></li></ul><blockquote><p><strong>结论：创建对象时使用shared_ptr强智能指针指向，其余情况都使用weak_ptr弱智能指针指向</strong></p></blockquote><p><strong>* <em>那下一篇就顺理成章的是多线程的线程安全的观察者监听者设计模式了。。。→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八大排序算法总结</title>
    <link href="/2020/06/30/sorting-algorithm/"/>
    <url>/2020/06/30/sorting-algorithm/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>好久都没看排序算法了。。。今天把以前的代码贴上来。。。方便今后随时复习→_→</em> *</strong></p><ol><li><p>交换排序</p> <pre><code class="hljs angelscript"><span class="hljs-built_in">void</span> swap_sort(<span class="hljs-built_in">int</span> *arr, <span class="hljs-built_in">int</span> len)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i)<span class="hljs-comment">//最后一个不用再向后比较</span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; ++j)&#123;<span class="hljs-keyword">if</span> (arr[i] &gt; arr[j])<span class="hljs-comment">//不相邻交换，较大值向后移动，较小值向前移动</span>&#123;<span class="hljs-built_in">int</span> tmp = arr[i];arr[i] = arr[j];arr[j] = tmp;&#125;&#125;&#125;&#125;</code></pre></li><li><p>冒泡排序</p> <pre><code class="hljs angelscript"><span class="hljs-built_in">void</span> bubble_sort(<span class="hljs-built_in">int</span> *arr, <span class="hljs-built_in">int</span> len)&#123;<span class="hljs-built_in">bool</span> flag = <span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span> &amp;&amp; flag; ++i)<span class="hljs-comment">//最后一个不用再向后比较</span>&#123;flag = <span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; ++j)<span class="hljs-comment">//排除最后已经排序好的</span>&#123;<span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])<span class="hljs-comment">//相邻交换</span>&#123;flag = <span class="hljs-literal">true</span>;<span class="hljs-built_in">int</span> tmp = arr[j];arr[j] = arr[j + <span class="hljs-number">1</span>];arr[j + <span class="hljs-number">1</span>] = tmp;&#125;&#125;&#125;&#125;</code></pre></li><li><p>选择排序</p> <pre><code class="hljs angelscript"><span class="hljs-built_in">void</span> select_sort(<span class="hljs-built_in">int</span> *arr, <span class="hljs-built_in">int</span> len)&#123;<span class="hljs-built_in">int</span> min = arr[<span class="hljs-number">0</span>];<span class="hljs-built_in">int</span> min_index = <span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i)&#123;min = arr[i];min_index = i;<span class="hljs-keyword">for</span> (j = i + <span class="hljs-number">1</span>; j &lt; len; ++j)<span class="hljs-comment">//一次循环找出最小数的数值和下标且和arr[i]交换</span>&#123;<span class="hljs-keyword">if</span> (min &gt; arr[j])&#123;min = arr[j];min_index = j;&#125;&#125;<span class="hljs-keyword">if</span> (i != min_index)&#123;<span class="hljs-built_in">int</span> tmp = arr[i];arr[i] = arr[min_index];arr[min_index] = tmp;&#125;&#125;&#125;</code></pre></li><li><p>插入排序</p> <pre><code class="hljs angelscript"><span class="hljs-built_in">void</span> insert_sort(<span class="hljs-built_in">int</span> *arr, <span class="hljs-built_in">int</span> len)&#123;<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> tmp = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; len; ++i)&#123;tmp = arr[i];<span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j)<span class="hljs-comment">//arr[i]从arr[i-1]开始逆向比较</span>&#123;<span class="hljs-keyword">if</span> (arr[j] &lt; tmp)<span class="hljs-comment">//遇到比自己小的为止</span>&#123;<span class="hljs-keyword">break</span>;&#125;arr[j + <span class="hljs-number">1</span>] = arr[j];<span class="hljs-comment">//比自己大的值后移</span>&#125;arr[j + <span class="hljs-number">1</span>] = tmp;<span class="hljs-comment">//插入合适位置</span>&#125;&#125;</code></pre></li><li><p>希尔排序</p> <pre><code class="hljs angelscript">static <span class="hljs-built_in">void</span> shell(<span class="hljs-built_in">int</span> *arr, <span class="hljs-built_in">int</span> len, <span class="hljs-built_in">int</span> gap)<span class="hljs-comment">//insert_sort()的变形，insert_sort()一数一组</span>&#123;<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> tmp = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = gap; i &lt; len; ++i)<span class="hljs-comment">//gap个为一组</span>&#123;tmp = arr[i];<span class="hljs-keyword">for</span> (j = i - gap; j &gt;= <span class="hljs-number">0</span>; j-=gap)&#123;<span class="hljs-keyword">if</span> (arr[j] &lt; tmp)&#123;<span class="hljs-keyword">break</span>;&#125;arr[j + gap] = arr[j];&#125;arr[j + gap] = tmp;&#125;&#125;<span class="hljs-built_in">void</span> shell_sort(<span class="hljs-built_in">int</span> *arr, <span class="hljs-built_in">int</span> len)&#123;shell(arr, len, <span class="hljs-number">3</span>);<span class="hljs-comment">//多次分组。提高效率，使得数逐渐基本有序</span>shell(arr, len, <span class="hljs-number">1</span>);&#125;</code></pre></li><li><p>快速排序</p> <pre><code class="hljs excel">static <span class="hljs-built_in">int</span> partition(<span class="hljs-built_in">int</span> *arr ,<span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>)&#123;<span class="hljs-built_in">int</span> tmp = arr[<span class="hljs-built_in">left</span>];while (<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>)//直到<span class="hljs-built_in">left</span>和<span class="hljs-built_in">right</span>重合，此时合适位置找到&#123;while (arr[<span class="hljs-built_in">right</span>] &gt; tmp &amp;&amp; <span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>)&#123;<span class="hljs-built_in">right</span>--;&#125;arr[<span class="hljs-built_in">left</span>] = arr[<span class="hljs-built_in">right</span>];while (arr[<span class="hljs-built_in">left</span>] &lt; tmp &amp;&amp; <span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>)&#123;<span class="hljs-built_in">left</span>++;&#125;arr[<span class="hljs-built_in">right</span>] = arr[<span class="hljs-built_in">left</span>];&#125;arr[<span class="hljs-built_in">left</span>] = tmp;//合适位置赋值return <span class="hljs-built_in">left</span>;&#125;static void quick(<span class="hljs-built_in">int</span> *arr, <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>)&#123;<span class="hljs-built_in">if</span> (<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>)&#123;//将arr[<span class="hljs-built_in">left</span>]放到合适位置，将枢轴返回出来,pivot左侧的都小于arr[<span class="hljs-built_in">left</span>],右侧的都大于<span class="hljs-built_in">int</span> pivot = partition(arr, <span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>);quick(arr, <span class="hljs-built_in">left</span>, pivot - <span class="hljs-number">1</span>);//枢轴两侧开始递归quick(arr, pivot + <span class="hljs-number">1</span>, <span class="hljs-built_in">right</span>);&#125;&#125;void quick_sort(<span class="hljs-built_in">int</span> *arr, <span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span>)//递归快速排序&#123;quick(arr, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span> - <span class="hljs-number">1</span>);&#125;void quick_sort_loop(<span class="hljs-built_in">int</span> *arr, <span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span>)//非递归快速排序&#123;DSEQ_STACK *stack = init_seqstack();assert(stack != NULL);<span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = <span class="hljs-built_in">len</span> - <span class="hljs-number">1</span>;<span class="hljs-built_in">int</span> pivot = <span class="hljs-number">0</span>;push(stack, &amp;<span class="hljs-built_in">left</span>);push(stack, &amp;<span class="hljs-built_in">right</span>);while (!is_empty(stack))//模拟递归，栈为空时，递归结束&#123;pop(stack, &amp;<span class="hljs-built_in">right</span>);pop(stack, &amp;<span class="hljs-built_in">left</span>);pivot = partition(arr, <span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>);//返回第一次的枢轴<span class="hljs-built_in">if</span> (<span class="hljs-built_in">left</span> &lt; pivot - <span class="hljs-number">1</span>)//左侧还有数&#123;<span class="hljs-built_in">int</span> <span class="hljs-built_in">base</span> = pivot - <span class="hljs-number">1</span>;push(stack, &amp;<span class="hljs-built_in">left</span>);push(stack, &amp;<span class="hljs-built_in">base</span>);&#125;<span class="hljs-built_in">if</span> (<span class="hljs-built_in">right</span> &gt; pivot + <span class="hljs-number">1</span>)//右侧还有数&#123;<span class="hljs-built_in">int</span> <span class="hljs-built_in">base</span> = pivot + <span class="hljs-number">1</span>;push(stack, &amp;<span class="hljs-built_in">base</span>);push(stack, &amp;<span class="hljs-built_in">right</span>);&#125;&#125;destory_seqstack(stack);&#125;</code></pre></li><li><p>堆排序</p> <pre><code class="hljs angelscript">static <span class="hljs-built_in">void</span> hell(<span class="hljs-built_in">int</span> *arr, <span class="hljs-built_in">int</span> len)<span class="hljs-comment">//初始排序为大根堆</span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> start = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; start &gt;= <span class="hljs-number">0</span>; start--)<span class="hljs-comment">//每个大根堆的根</span>&#123;<span class="hljs-built_in">int</span> tmp = arr[start];<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span> * start + <span class="hljs-number">1</span>; i &lt; len; i = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>)<span class="hljs-comment">//其根与其孩子的关系</span>&#123;<span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; len&amp;&amp;arr[i] &lt; arr[i + <span class="hljs-number">1</span>])<span class="hljs-comment">//判断是否有右孩子，若有i停在数值大的孩子上</span>&#123;i++;&#125;<span class="hljs-keyword">if</span> (arr[i] &lt; tmp)<span class="hljs-comment">//孩子都小于tmp</span>&#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &gt; tmp)<span class="hljs-comment">//大的数值换到根上</span>&#123;arr[start] = arr[i];&#125;<span class="hljs-keyword">else</span>&#123;;&#125;start = i;<span class="hljs-comment">//start移动到i处</span>&#125;arr[start] = tmp;<span class="hljs-comment">//循环结束将tmp放到合适的根上</span>&#125;&#125;static <span class="hljs-built_in">void</span> hell_adjust(<span class="hljs-built_in">int</span> *arr, <span class="hljs-built_in">int</span> len)&#123;hell(arr, len);&#125;<span class="hljs-built_in">void</span> hell_sort(<span class="hljs-built_in">int</span> *arr, <span class="hljs-built_in">int</span> len)&#123;<span class="hljs-built_in">int</span> tmp = <span class="hljs-number">0</span>;hell(arr, len);<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = len<span class="hljs-number">-1</span>; i&gt;<span class="hljs-number">0</span>; --i)<span class="hljs-comment">//最大值下放到arr[i]</span>&#123;tmp = arr[i];arr[i] = arr[<span class="hljs-number">0</span>];arr[<span class="hljs-number">0</span>] = tmp;hell_adjust(arr, i<span class="hljs-number">-1</span>);<span class="hljs-comment">//调整大根堆</span>&#125;&#125;</code></pre></li><li><p>归并排序</p> <pre><code class="hljs angelscript">static <span class="hljs-built_in">void</span> meger(<span class="hljs-built_in">int</span> *arr, <span class="hljs-built_in">int</span> len, <span class="hljs-built_in">int</span> gap)&#123;<span class="hljs-built_in">int</span> *buff = (<span class="hljs-built_in">int</span> *)malloc(sizeof(<span class="hljs-built_in">int</span>)*len);<span class="hljs-comment">//开辟存放分组后的成员序列</span>assert(buff != NULL);<span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> low1 = <span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> high1 = low1 + gap - <span class="hljs-number">1</span>;<span class="hljs-built_in">int</span> low2 = high1 + <span class="hljs-number">1</span>;<span class="hljs-built_in">int</span> high2 = low2 + gap - <span class="hljs-number">1</span> &lt; len ? low2 + gap - <span class="hljs-number">1</span> : len - <span class="hljs-number">1</span>;<span class="hljs-comment">//防止归并段2第一次就越界</span><span class="hljs-keyword">while</span> (low2 &lt; len)<span class="hljs-comment">//归并段2有数据时</span>&#123;<span class="hljs-keyword">while</span> (low1 &lt;= high1 &amp;&amp; low2 &lt;= high2)<span class="hljs-comment">//谁小谁下</span>&#123;<span class="hljs-keyword">if</span> (arr[low1] &lt;= arr[low2])&#123;buff[k++] = arr[low1++];&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[low1] &gt; arr[low2])&#123;buff[k++] = arr[low2++];&#125;&#125;<span class="hljs-keyword">while</span> (low1 &lt;= high1)<span class="hljs-comment">//未完的补齐</span>&#123;buff[k++] = arr[low1++];&#125;<span class="hljs-keyword">while</span> (low2 &lt;= high2)&#123;buff[k++] = arr[low2++];&#125;low1 = high2 + <span class="hljs-number">1</span>;high1 = low1 + gap - <span class="hljs-number">1</span>;low2 = high1 + <span class="hljs-number">1</span>;high2 = low2 + gap - <span class="hljs-number">1</span> &lt; len ? low2 + gap - <span class="hljs-number">1</span> : len - <span class="hljs-number">1</span>;<span class="hljs-comment">//归并段2中有数据时，防止越界</span>&#125;<span class="hljs-keyword">while</span> (low1 &lt; len)<span class="hljs-comment">//只有归并段1中有数据</span>&#123;buff[k++] = arr[low1++];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)<span class="hljs-comment">//复制到buff中</span>&#123;arr[i] = buff[i];&#125;free(buff);&#125;<span class="hljs-built_in">void</span> meger_sort(<span class="hljs-built_in">int</span> *arr, <span class="hljs-built_in">int</span> len)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> gap = <span class="hljs-number">1</span>; gap &lt; len; gap *= <span class="hljs-number">2</span>)<span class="hljs-comment">//22--44--88--...分组</span>&#123;meger(arr, len, gap);&#125;&#125;</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++全局构造与析构底层实现</title>
    <link href="/2020/06/30/construction-and-destruction/"/>
    <url>/2020/06/30/construction-and-destruction/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>前一阵儿，被施老师问到C++全局变量是如何构造和析构的。。。？之前看书的时候好像忽略了这个点。。现在补上。。。→_→</em> *</strong></p><p>理解这个点之前，需要把<strong>main函数的前世今生</strong>搞清楚。。<a href="http://blog.csdn.net/kongkongkkk/article/details/72861149" target="_blank" rel="noopener">请戳传送门</a></p><ul><li><p><strong>Glibc中的文件类型</strong></p><ul><li><p>在Glibc中主要分为<strong>头文件和库文件</strong></p><ul><li><p><strong>头文件位于/usr/include</strong></p></li><li><p>库文件包含<strong>动态库和静态库</strong></p><ul><li><p><strong>动态库位于/lib/libc.so.6</strong></p></li><li><p><strong>静态库位于/usr/lib/libc.a</strong></p></li></ul></li></ul></li><li><p>除了C标准库外，Glibc中还有几个<strong>辅助的“运行库”</strong></p><ul><li><p><strong>/usr/lib/crt1.o 中包含程序的入口函数_start，由它负责调用__libc_start_main完成初始化，并调用main函数</strong></p></li><li><p><strong>/usr/lib/ctri.o</strong></p></li><li><p><strong>/usr/lib/ctrn.o</strong></p></li></ul></li></ul></li><li><p><strong>Glibc中的crti.o和crtn.o的内容和作用</strong></p><ul><li><p>因为全局变量必须在main函数之前构造、必须在main函数之后析构，所以<strong>运行库在每个目标文件中引入了两个初始化相关的段.init和.finit</strong></p></li><li><p><strong>链接器在进行链接时，会把所有输入的目标文件中的.init和.finit段按顺序收集合并成最终输出文件中的.init和.finit，这两个段实际上分别包含_init() 和 _finit()函数</strong></p></li><li><p><strong>crti.o和crtn.o中的代码实际上是_ init() 和_ finit()函数的开始和结尾部分，它们辅助.init 和 .finit中的指令实现初始化函数</strong>。crti.o和crtn.o与其他目标文件按顺序链接后，形成完整的_ init() 和_ finit()函数</p></li><li><p><strong>必须保证在链接时，crti.o在目标文件和系统库之前，crtn.o在目标文件和系统调用之后</strong>。因此链接器的输入文件顺序如下（<strong>ctr1.o不包含.init和.finit段，所以不会影响生成段的顺序</strong>）</p>  <pre><code class="hljs css"><span class="hljs-selector-tag">ld</span> <span class="hljs-selector-tag">ctr1</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">ctri</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-attr">[user_object]</span>_<span class="hljs-selector-attr">[system_libraries]</span> <span class="hljs-selector-tag">ctrn</span><span class="hljs-selector-class">.o</span></code></pre></li></ul></li><li><p><strong>GCC中的crtbegin.o和crtend.o的内容和作用</strong></p><ul><li><p>C++语言的实现和编译器密切相关，所以<strong>GCC才是C++全局构造和析构的真正实现者，crtbegin.o和crtend.o配合Glibc实现C++全局构造和析构</strong></p></li><li><p><strong>crti.o和crtn.o中的.init和.finit提供一个在main函数之前和之后的代码运行机制，真正的全局构造和析构由crtbegin.o和crtend.o实现</strong></p></li><li><p><strong>对于每个编译单元，GCC编译器会遍历其所有的全局对象，生成一个特殊的函数，这个特殊的函数负责初始化本单元中的所有全局对象</strong></p></li><li><p>目标文件中有了这个函数，<strong>编译器就会在这个目标文件中产生.ctors段，.ctors段中放置一个指向特殊函数的指针</strong></p></li><li><p>链接时，链接器将每个目标文件的.ctors段合并成一个.ctors段，<strong>因此合并后的.ctors段就成为了一个函数指针数组，每个元素都指向一个目标文件的特殊函数</strong></p></li><li><p>链接时，<strong>各个目标文件的前后还要链接crtbegin.o和crtend.o</strong>，这两个目标文件具有的.ctors段也会被合并到可执行文件中</p></li><li><p><strong>crtbegin.o作为.ctors的开头部分，其.ctors段中存储了一个4字节的0xFFFFFFFF（-1），链接器负责将这个数字改成所有目标文件中的特殊函数的总数量，还将这个段的起始地址定义成符号 _ _ CTOR_ LIST _ _ ，即_ _ CTOR_LIST _ _就代表合并后的.ctors的起始地址</strong></p></li><li><p><strong>crtend.o中的内容只有一个0，定义了一个_ _ CTOR_ END_ _符号，指向.ctor段的末尾</strong></p></li><li><p>实际链接的目标文件顺序如下</p><pre><code class="hljs stylus">ld  ctr1<span class="hljs-selector-class">.o</span> ctri<span class="hljs-selector-class">.o</span> ctrbegin<span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.o</span> ctrend<span class="hljs-selector-class">.o</span> ctrn.o</code></pre><p>  过程如图所示</p><p>  <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzExMTg1NTI3NTY4?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=".ctor段的形成"></p></li></ul></li><li><p><strong>全局变量构造源码剖析</strong></p><ul><li><p><strong>入口函数_start中调用了_libc_start_main函数，_libc_start_main函数传入参数_libc_csu_init函数指针</strong></p>  <pre><code class="hljs arduino"><span class="hljs-comment">//glibc-2.6.1/csu/Elf-init.c</span><span class="hljs-keyword">void</span>__libc_csu_init (<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">char</span> **envp)&#123;......_init ();<span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span> = __init_array_end - __init_array_start;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span>; i++)(*__init_array_start [i]) (argc, argv, envp);&#125;</code></pre></li><li><p><strong>_ _ libc_ csu_ init函数中调用了.init段中的_ init函数，_ init函数中又调用了_ _ do_ global_ ctors_ aux函数，这个_ _ do_ global_ ctors_aux函数来自GCC中的目标文件crtbegin.o</strong></p><pre><code><pre><code class="hljs less"><span class="hljs-comment">//Crtstuff.c</span><span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">__attribute__</span>((used))<span class="hljs-selector-tag">__do_global_ctors_aux</span> (void)&#123;  <span class="hljs-selector-tag">func_ptr</span> *<span class="hljs-selector-tag">p</span>;  <span class="hljs-selector-tag">for</span> (p = __CTOR_END__ - <span class="hljs-number">1</span>; *p != (func_ptr) -<span class="hljs-number">1</span>; p--)    (*p) ();&#125;</code></pre></code></pre></li><li><p><strong>_ _ do_ global_ ctors_aux函数将合并的.ctors段中存储的各个目标文件的特殊函数依次调用，即完成了全局变量的构造。</strong></p></li></ul></li><li><p><strong>全局变量析构源码剖析</strong></p><ul><li><p>一直说的特殊函数是什么？特殊函数除了完成对象构造，还干了些什么？</p>  <pre><code class="hljs cpp"><span class="hljs-comment">//特殊函数的伪代码</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GLOBAL_I_A</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span><span class="hljs-function"></span>&#123;A::A();<span class="hljs-comment">//调用构造函数</span>__cxa_exit(_tcf_1);<span class="hljs-comment">//_tcf_1函数被注册到main函数结束后调用</span>&#125;</code></pre></li><li><p>__tcf_1函数中有什么东西？</p>  <pre><code class="hljs aspectj"><span class="hljs-comment">//此函数名由编译器生成</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __tcf_1(<span class="hljs-keyword">void</span>)&#123;A.~A();<span class="hljs-comment">//调用析构函数</span>&#125;</code></pre></li><li><p><strong>由此可见在特殊函数中不仅调用了构造函数，而且还一道注册了析构函数。注册的析构函数与调用构造函数的顺序刚好相反，符合先构造后析构的原理</strong></p></li></ul></li></ul><p><strong>* <em>今天真热。。。41℃。。。→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——单例模式</title>
    <link href="/2020/06/30/singleton-pattern/"/>
    <url>/2020/06/30/singleton-pattern/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>这篇开始总结几个比较常用的设计模式。。。不会设计模式。。怎么敢称熟悉OOP思想。。。→_→</em> *</strong></p><blockquote><p><strong>单例模式的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例，即一个类只有一个对象实例</strong></p></blockquote><p>版本一：<strong>使用懒加载（快加载），只有在使用时才实例化</strong></p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">static</span> Singleton* <span class="hljs-title">getIntance</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (pobject == <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//懒加载，只有在使用时才生成</span>&#123;pobject = <span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-keyword">return</span> pobject;&#125;<span class="hljs-keyword">private</span>:Singleton()&#123;&#125;<span class="hljs-keyword">static</span> Singleton *pobject;&#125;;Singleton* Singleton::pobject = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//懒加载，只有在使用时才生成</span></code></pre><p>版本二：<strong>考虑多线程安全问题，使用互斥锁</strong></p><ul><li><strong>判断是否是线程安全的——是否存在竞态条件</strong></li><li><strong>判断是否存在竞态条件——随着线程调度顺序的不同，代码执行的结果也会不同。</strong></li><li><strong>存在竞态条件的代码称为临界区，临界区代码需要是原子操作，实现原子操作需要使用互斥锁，if语句不是原子操作</strong><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">static</span> Singleton* <span class="hljs-title">getIntance</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;pthread_mutex_lock(&amp;mutex);<span class="hljs-comment">//多线程线程安全问题</span><span class="hljs-keyword">if</span> (pobject == <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//懒加载，只有在使用时才生成</span>&#123;pobject = <span class="hljs-keyword">new</span> Singleton();&#125;pthread_mutex_lock(&amp;mutex);<span class="hljs-keyword">return</span> pobject;&#125;<span class="hljs-keyword">private</span>:Singleton()&#123;&#125;<span class="hljs-keyword">static</span> Singleton *pobject;&#125;;Singleton* Singleton::pobject = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//快加载 懒加载</span></code></pre></li></ul><p>版本三：<strong>由于可能存在单线程或多线程共存的使用场景，降低单线程获取释放锁的效率，使用双重if判断</strong></p><ul><li><strong>单线程时，只需要执行一次获取释放互斥锁操作，之后第一个if语句都为false</strong></li><li><strong>多线程时，依旧考虑线程安全与竞态条件问题</strong></li></ul><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">static</span> Singleton* <span class="hljs-title">getIntance</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (pobject == <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//懒加载，只有在使用时才生成</span>&#123;pthread_mutex_lock(&amp;mutex);<span class="hljs-comment">//多线程线程安全问题</span><span class="hljs-keyword">if</span> (pobject == <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//单线程时效率问题</span>&#123;pobject = <span class="hljs-keyword">new</span> Singleton();&#125;pthread_mutex_lock(&amp;mutex);&#125;<span class="hljs-keyword">return</span> pobject;&#125;<span class="hljs-keyword">private</span>:Singleton()&#123;&#125;<span class="hljs-keyword">static</span> Singleton *pobject;&#125;;Singleton* Singleton::pobject = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//快加载 懒加载</span></code></pre><p>版本四：<strong>考虑编译器的指令优化和CPU的动态指令优化</strong></p><ul><li><strong>volatile关键字阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回内存</strong></li><li><strong>volatile关键字阻止编译器调整操作volatile变量的指令操作</strong></li><li><strong>barrier指令会阻止CPU对指令进行动态换序优化</strong></li></ul><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton* <span class="hljs-title">getIntance</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (pobject == <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//懒加载，只有在使用时才生成</span>&#123;pthread_mutex_lock(&amp;mutex);<span class="hljs-comment">//多线程线程安全问题</span><span class="hljs-keyword">if</span> (pobject == <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//单线程时的效率问题</span>&#123;Singleton* temp = <span class="hljs-keyword">new</span> Singleton;barrier();<span class="hljs-comment">//防止CPU对指令进行动态换序优，使对象的构造一定在barrier完成，因此赋值给pobject的对象是完好的</span>pobject = temp;&#125;pthread_mutex_lock(&amp;mutex);&#125;<span class="hljs-keyword">return</span> pobject;&#125;<span class="hljs-keyword">private</span>:Singleton()&#123;&#125;<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton *pobject;&#125;;<span class="hljs-keyword">volatile</span> Singleton* Singleton::pobject = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//快加载 懒加载</span></code></pre><p><strong>* <em>码完。。。睡觉！→_→。。。</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Design Patterns</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下如何在进程中获取虚拟地址对应的物理地址</title>
    <link href="/2020/06/30/address-translation/"/>
    <url>/2020/06/30/address-translation/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>如果让你编写一个程序，来获取虚拟地址对应的物理地址。。你会试着操作MMU吗。。→_→</em> *</strong></p><ol><li><p><strong>Linux文件目录中的/proc记录着当前进程的信息，称其为虚拟文件系统</strong>。在/proc下有一个<strong>链接目录名为self</strong>，这意味着<strong>哪一个进程打开了它，self中存储的信息就是所链接进程的</strong>。self中有一个名为<strong>pagemap</strong>的文件，专门用来<strong>记录所链接进程的物理页号信息</strong>。这样通过/proc/pid/pagemap文件，允许一个用户态的进程查看到每个虚拟页映射到的物理页</p></li><li><p><strong>/proc/pid/pagemap中的每一项都包含了一个64位的值</strong>，这个值内容如下所示。<strong>每一项的映射方式不同于真正的虚拟地址映射，其文件中遵循独立的对应关系，即虚拟地址相对于0x0经过的页面数是对应项在文件中的偏移量</strong></p> <pre><code class="hljs tcl">* /<span class="hljs-keyword">proc</span>/pid/pagemap.<span class="hljs-title">  This</span> file<span class="hljs-title"> lets</span> a<span class="hljs-title"> userspace</span> process<span class="hljs-title"> find</span> out<span class="hljs-title"> which</span><span class="hljs-title"></span> <span class="hljs-title">  physical</span> frame<span class="hljs-title"> each</span> virtual<span class="hljs-title"> page</span> is<span class="hljs-title"> mapped</span> to.<span class="hljs-title">  It</span> contains<span class="hljs-title"> one</span> 64-bit<span class="hljs-title">   value</span> for<span class="hljs-title"> each</span> virtual<span class="hljs-title"> page,</span> containing<span class="hljs-title"> the</span> following<span class="hljs-title"> data</span> (from<span class="hljs-title">   fs/proc/task_mmu.c,</span> above<span class="hljs-title"> pagemap_read):</span><span class="hljs-title"></span><span class="hljs-title"></span>    *<span class="hljs-title"> Bits</span> 0-54<span class="hljs-title">  page</span> frame<span class="hljs-title"> number</span> (PFN)<span class="hljs-title"> if</span> present//present为1时，bit0-54表示物理页号    *<span class="hljs-title"> Bits</span> 0-4<span class="hljs-title">   swap</span> type<span class="hljs-title"> if</span> swapped    *<span class="hljs-title"> Bits</span> 5-54<span class="hljs-title">  swap</span> offset<span class="hljs-title"> if</span> swapped    *<span class="hljs-title"> Bit</span>  55<span class="hljs-title">    pte</span> is<span class="hljs-title"> soft-dirty</span> (see<span class="hljs-title"> Documentation/vm/soft-dirty.txt)</span><span class="hljs-title"></span>    *<span class="hljs-title"> Bit</span>  56<span class="hljs-title">    page</span> exclusively<span class="hljs-title"> mapped</span> (since 4.2)    *<span class="hljs-title"> Bits</span> 57-60<span class="hljs-title"> zero</span><span class="hljs-title"></span>    *<span class="hljs-title"> Bit</span>  61<span class="hljs-title">    page</span> is<span class="hljs-title"> file-page</span> or<span class="hljs-title"> shared-anon</span> (since 3.5)    *<span class="hljs-title"> Bit</span>  62<span class="hljs-title">    page</span> swapped    *<span class="hljs-title"> Bit</span>  63<span class="hljs-title">    page</span> present//如果为1，表示当前物理页在内存中；为0，表示当前物理页不在内存中</code></pre></li><li><p>在计算物理地址时，只需要<strong>找到虚拟地址的对应项，再通过对应项中的bit63判断此物理页是否在内存中，若在内存中则对应项中的物理页号加上偏移地址，就能得到物理地址</strong></p></li><li><p>通过程序<strong>获取物理地址并验证写时拷贝技术</strong></p> <pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><span class="hljs-comment">//计算虚拟地址对应的地址，传入虚拟地址vaddr，通过paddr传出物理地址</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mem_addr</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> vaddr, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *paddr)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> pageSize = getpagesize();<span class="hljs-comment">//调用此函数获取系统设定的页面大小</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> v_pageIndex = vaddr / pageSize;<span class="hljs-comment">//计算此虚拟地址相对于0x0的经过的页面数</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> v_offset = v_pageIndex * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint64_t</span>);<span class="hljs-comment">//计算在/proc/pid/page_map文件中的偏移量</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> page_offset = vaddr % pageSize;<span class="hljs-comment">//计算虚拟地址在页面中的偏移量</span><span class="hljs-keyword">uint64_t</span> item = <span class="hljs-number">0</span>;<span class="hljs-comment">//存储对应项的值</span><span class="hljs-keyword">int</span> fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">"/proc/self/pagemap"</span>, O_RDONLY);。。以只读方式打开/proc/pid/page_map<span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)<span class="hljs-comment">//判断是否打开失败</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"open /proc/self/pagemap error\n"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span>(lseek(fd, v_offset, SEEK_SET) == <span class="hljs-number">-1</span>)<span class="hljs-comment">//将游标移动到相应位置，即对应项的起始地址且判断是否移动失败</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"sleek error\n"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">read</span>(fd, &amp;item, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint64_t</span>)) != <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint64_t</span>))<span class="hljs-comment">//读取对应项的值，并存入item中，且判断读取数据位数是否正确</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"read item error\n"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span>((((<span class="hljs-keyword">uint64_t</span>)<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">63</span>) &amp; item) == <span class="hljs-number">0</span>)<span class="hljs-comment">//判断present是否为0</span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"page present is 0\n"</span>);<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">uint64_t</span> phy_pageIndex = (((<span class="hljs-keyword">uint64_t</span>)<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">55</span>) - <span class="hljs-number">1</span>) &amp; item;<span class="hljs-comment">//计算物理页号，即取item的bit0-54</span>*paddr = (phy_pageIndex * pageSize) + page_offset;<span class="hljs-comment">//再加上页内偏移量就得到了物理地址</span>&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">100</span>;<span class="hljs-comment">//全局常量</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> b = <span class="hljs-number">100</span>;<span class="hljs-comment">//局部变量</span><span class="hljs-keyword">static</span> c = <span class="hljs-number">100</span>;<span class="hljs-comment">//局部静态变量</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> d = <span class="hljs-number">100</span>;<span class="hljs-comment">//局部常量</span><span class="hljs-keyword">char</span> *str = <span class="hljs-string">"Hello World!"</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> phy = <span class="hljs-number">0</span>;<span class="hljs-comment">//物理地址</span><span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<span class="hljs-comment">//动态内存</span><span class="hljs-keyword">int</span> pid = fork();<span class="hljs-comment">//创建子进程</span><span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//p[0] = '1';//子进程中修改动态内存</span>mem_addr((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)&amp;a, &amp;phy);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"pid = %d, virtual addr = %x , physical addr = %x\n"</span>, getpid(), &amp;a, phy);&#125;<span class="hljs-keyword">else</span>&#123; mem_addr((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)&amp;a, &amp;phy);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"pid = %d, virtual addr = %x , physical addr = %x\n"</span>, getpid(), &amp;a, phy);&#125;sleep(<span class="hljs-number">100</span>);<span class="hljs-built_in">free</span>(p);waitpid();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p> 测试结果如下：</p></li></ol><ul><li><p>全局常量：符合写时拷贝技术<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzA1MDEzNzMyMTQ0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="全局常量"></p></li><li><p>局部变量：不符合写时拷贝技术。原因分析，有可能是物理页上的其他数据被改动，导致拷贝出一个新物理页面<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzA1MDE0NTMzOTQx?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="局部变量"></p></li><li><p>局部静态变量：不符合写时拷贝技术。原因分析，有可能是物理页上的其他数据被改动，导致拷贝出一个新物理页面<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzA1MDE0NzQ0MzEz?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="局部静态变量"></p></li><li><p>局部常量：不符合写时拷贝技术。原因分析，有可能是物理页上的其他数据被改动，导致拷贝出一个新物理页面<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzA1MDE0OTI0NzQ0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="局部常量"></p></li><li><p>字符串：符合写时拷贝技术<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzA1MDE1MjE3MjA2?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="字符串"></p></li><li><p>动态内存：符合写时拷贝技术<br>子进程不修改动态内存<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzA1MDE1NDQ1NjIz?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="不修改"><br>子进程修改动态内存<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzA1MDE1NjU0NjMw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="修改"></p></li></ul><p><strong>* <em>其实想要知道虚拟地址对应的物理地址，通过这样的方式也可以得到物理地址而不用操作MMU。。。</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实地址模式与保护模式</title>
    <link href="/2020/06/30/real-address-mode-and-protection-mode/"/>
    <url>/2020/06/30/real-address-mode-and-protection-mode/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>为了给之后的虚拟地址映射总结作准备，本篇先来看看什么是实地址模式、什么是保护模式。。。→_→</em> *</strong></p><p>Intel的CPU发展也是经过技术不断地迭代更新，才有了今天的成就（但依旧逃不掉牙膏厂的美誉。。→_→）。所以在不同的技术时期，其CPU也采用了不同的寻址方式</p><ul><li><p><strong>实地址模式</strong></p><ul><li><p>在80286之前都采用这种寻址<strong>重点内容</strong>模式。比如在8086中虽然有20位地址总线，但CPU中的ALU的宽度却只有16位。于是为了解决寻址问题，采用了“<strong>分段</strong>”的方法。在8086 CPU中设置了<strong>四个段寄存器“CS、DS、SS、ES”</strong>，<strong>每个段寄存器都是16位的</strong>，对应于地址总线的高16位。每条指令中的逻辑地址也是16位的，所以<strong>地址要被送上地址总线之前，其高12位要与对应的段寄存器相加，而低4位不变</strong>，即</p></li><li><p><strong>实际地址 = （段寄存器的值 &lt;&lt; 4）+ 逻辑地址</strong></p></li><li><p><strong>实地址模式也称为实模式</strong>，在实模式中<strong>没有相应的地址空间保护机制</strong>，通过段寄存器可以访问从此开始的64K连续地址空间。而且<strong>更改段寄存器的指令没有“特权要求”</strong>，所以一个进程可以访问任何一个内存单元</p></li></ul></li><li><p><strong>保护模式（Protected Mode）</strong></p><ul><li><p><strong>为了解决实地址模式中的安全问题而设计的一种寻址机制</strong>。从80286开始实现了部分保护模式，80386开始完全实现了保护模式与实模式的转化。80386是32位CPU，为了与之前的系列保持一致，保留了16位的段寄存器，增加了两个段寄存器FS、GS。</p></li><li><p><strong>为了实现保护模式，设计使段寄存器从单纯的基地址变成一个数据结构指针</strong>，当一条指令访问内存地址时的步骤如下</p><ul><li><p><strong>根据指令的性质确定使用哪一个段寄存器</strong></p></li><li><p><strong>根据段寄存器的内容，找到相应的地址段描结构</strong></p></li><li><p><strong>从地址段描述结构中得到基地址</strong></p></li><li><p><strong>将指令要访问的地址作为位移，与段描述结构中规定的段长度比较，检查是否越界</strong></p></li><li><p><strong>根据指令的性质和段描述结构中的访问权限确定是否越权</strong></p></li><li><p><strong>将指令要访问的内存地址作为位移，与基地址相加得到实际的物理地址</strong></p></li></ul></li><li><p>具体实现</p><ul><li><p>在80386中增设两个寄存器：<strong>全局性段描述表寄存器GDTR（Global Descriptor Table Register ）</strong>和<strong>局部性段描述表寄存器LDTR（Local Descriptor Table Register ）</strong>。其用来<strong>指向一个存储在内存的段描述结构数组（段描述表）而且访问这两个寄存器的指令是特权指令</strong>，这样做是为了<strong>防止没有权限的进程修改段寄存器或段描述结构等非法访问操作</strong></p></li><li><p>图中解释<strong>段寄存器的字段含义</strong>，根据<strong>TI字段选择使用哪一种段描述表寄存器，段寄存器给出的下标和GDTR和LDTR中的基地址相结合，得到段描述表项的基地址</strong></p><p>   <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzA0MjMyNTI4MjE1?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="段寄存器字段分析"></p><p>   图中解释<strong>段描述符表项的字段含义，每个段描述表项为8字节</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzA0MjMyNjEwNzQ0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="段描述符表项定义"></p><p>   图中解释<strong>段描述符表项的TYPE字段含义</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzA0MjMzOTUzMTA3?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="段描述符表项TYPE字段定义"></p><p>  段描述表项的伪代码</p><pre><code><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span> <span class="hljs-keyword">unsigned</span>  <span class="hljs-keyword">int</span>  base24_31:<span class="hljs-number">8</span>;        <span class="hljs-comment">/*基地址的高8位 */</span> ​   <span class="hljs-keyword">unsigned</span>  <span class="hljs-keyword">int</span>  g:<span class="hljs-number">1</span>;                <span class="hljs-comment">/* granularity，表段的长度单位，0表示字节，1表示 4KB */</span> ​   <span class="hljs-keyword">unsigned</span>  <span class="hljs-keyword">int</span>  d_b:<span class="hljs-number">1</span>;              <span class="hljs-comment">/* default operation size ，存取方式，0表示16位，1表示32位 */</span> ​   <span class="hljs-keyword">unsigned</span>  <span class="hljs-keyword">int</span>  unused:<span class="hljs-number">1</span>;           <span class="hljs-comment">/*固定设置成0 */</span> ​   <span class="hljs-keyword">unsigned</span>  <span class="hljs-keyword">int</span>  avl:<span class="hljs-number">1</span>;              <span class="hljs-comment">/* avalaible，可供系统软件使用*/</span> ​   <span class="hljs-keyword">unsigned</span>  <span class="hljs-keyword">int</span>  seg_limit_16_19:<span class="hljs-number">4</span>;  <span class="hljs-comment">/* 段长度的高4位 */</span> ​   <span class="hljs-keyword">unsigned</span>  <span class="hljs-keyword">int</span>  p:<span class="hljs-number">1</span>;                <span class="hljs-comment">/* segment present，为0时表示该段不在内存中*/</span> ​   <span class="hljs-keyword">unsigned</span>  <span class="hljs-keyword">int</span>  dpl:<span class="hljs-number">2</span>;              <span class="hljs-comment">/* Descriptor privilege level，访问本段所需的权限 */</span> ​   <span class="hljs-keyword">unsigned</span>  <span class="hljs-keyword">int</span>  s:<span class="hljs-number">1</span>;                <span class="hljs-comment">/* 描述项类型，1表示系统，0表示代码或数据 */</span> ​   <span class="hljs-keyword">unsigned</span>  <span class="hljs-keyword">int</span>  type:<span class="hljs-number">4</span>;             <span class="hljs-comment">/* 段的类型，与S标志位一起使用*/</span> ​   <span class="hljs-keyword">unsigned</span>  <span class="hljs-keyword">int</span>  base_0_23:<span class="hljs-number">24</span>;       <span class="hljs-comment">/* 基地址的低24位 */</span> ​   <span class="hljs-keyword">unsigned</span>  <span class="hljs-keyword">int</span>  seg_limit_0_15:<span class="hljs-number">16</span>;  <span class="hljs-comment">/* 段长度的低16位 */</span> &#125;;</code></pre>- 80386中**四个特权级别，0级最高，3级最低**。每一条指令都有其适用级别，**通常用户程序都是3级，一般程序的运行级别由代码段的局部描述项DPL字段决定，这是由0级状态下的的内核设定的**。当**改变一个寄存器内容时，CPU对权限进行检查，确保该程序的执行权限和段寄存器所制定要求的权限RPL所要访问的内存的权限DPL**</code></pre></li></ul></li></ul></li></ul><p><strong>* <em>本篇的内容其实很杂，开始写的时候很纠结如何一篇就说清楚虚拟地址映射，发现比较难。。。所以就先把一些重要的点总结出来。。。→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP中的四种计时器</title>
    <link href="/2020/06/30/timer/"/>
    <url>/2020/06/30/timer/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>经过两天的总结，已经总结了大部分运输层的知识原理，那今天就再来看看TCP中的四种定时器。。。→_→</em> *</strong></p><ol><li><strong>超时重传计时器（Retransmission Timeout Timer）（与超时重传相关）</strong></li></ol><ul><li><p>A向B发送一个数据报文段，为了<strong>保证可靠传输</strong>，A<strong>会为这个数据报文段设置一个超时重传计时器（Retransmission Timeout Timer）</strong></p></li><li><p>如果在超时重传时间内，A<strong>收到了</strong>B的确认报文段，则<strong>撤销这个数据报文段的超时重传计时器</strong></p></li><li><p>如果超时重传时间到期时，A还<strong>没有收到</strong>B的确认报文段，则 <strong>A就重传这个数据报文段并重新设置超时计时器，直到收到B的确认为止</strong></p></li></ul><ol start="2"><li><strong>持续计时器（Persistent Timer）（与流量控制相关）</strong></li></ol><ul><li><p><strong>B向A发送了零窗口报文段</strong>后，B的接收缓存又有了空间。于是B向A发送非零窗口的报文段，但<strong>此报文段传送过程中丢失了</strong>。<strong>A一直等待接收B发送的非零窗口的通知，B也一直等待A发送的数据，此时陷入了死锁</strong></p></li><li><p>TCP为<strong>每一个连接设有一个持续计时器（Persistent Timer）</strong>。只要TCP<strong>连接的一方收到对方的零窗口通知，就启动持续计时器</strong>。若持续计时器设置的时间到期，<strong>就发送一个零窗口探测报文（仅携带1字节的数据），而对方就在确认这个探测报文时给出了现在的窗口值。</strong></p></li><li><p>如果<strong>窗口值仍为零，那么收到报文段的一方就重新设置持续计时器</strong></p></li><li><p><a href="http://blog.csdn.net/kongkongkkk/article/details/74007707" target="_blank" rel="noopener">传送门：TCP可靠传输——流量控制</a></p></li></ul><ol start="3"><li><strong>时间等待计时器（TIME-WAIT Timer）（与四次挥手相关）</strong></li></ol><ul><li><p><strong>当客户端进入TIME-WAIT（时间等待）状态后，必须经过时间等待计时器设置的2MSL后，才能进入到CLOSED状态</strong></p></li><li><p><a href="http://blog.csdn.net/kongkongkkk/article/details/74081163" target="_blank" rel="noopener">传送门：TCP三次握手与四次挥手的过程及原因</a></p></li></ul><ol start="4"><li><strong>保活计时器（Keepalive Timer）（与HeartBeat心跳机制相关）</strong></li></ol><ul><li><p><strong>客户端与服务器端建立了TCP连接后，客户端突然出现了故障</strong>，此时应使用保活计时器</p></li><li><p><a href="http://blog.csdn.net/kongkongkkk/article/details/74081163" target="_blank" rel="noopener">传送门：TCP三次握手与四次挥手的过程及原因</a></p></li><li><p><strong>服务器每收到一次客户端的数据，就重新设置保护计时器，时间通常是两个小时。若两个小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔75分钟发送一次。若一连发送10个探测报文段后仍无客户端响应，服务器端就认为客户端发生故障，应关闭这个连接</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP三次握手与四次挥手的过程及原因</title>
    <link href="/2020/06/30/three-handshake-and-four-waves/"/>
    <url>/2020/06/30/three-handshake-and-four-waves/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>本篇文章来彻彻底底的分析一下TCP三次握手与四次挥手的过程及原因。。。→_→</em> *</strong></p><ol><li><strong>TCP的连接建立——三次握手</strong></li></ol><ul><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzAxMjIyNTA0NzY4?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="三次握手"></p></li><li><p>最初两端的TCP进程都处于<strong>CLOSED（关闭）状态</strong>。<strong>A主动打开连接，B被动打开连接</strong></p></li><li><p>B的TCP<strong>服务器进程创建传输控制块TCB（Transmission Control Block）</strong>，然后<strong>处于LISTEN（收听）状态，准备接受客户端的连接请求</strong></p></li><li><p>A的TCP<strong>客户端进程也创建传输控制块TCB，向B发出连接请求报文段，此报文段中同步位SYN=1，且选择一个初始序号seq=x</strong>。TCP规定，<strong>SYN=1的报文段不能携带数据，但要消耗一个序号</strong>。此时A进入<strong>SYN-SENT（同步已发送）状态</strong></p></li><li><p>B收到连接请求报文后，<strong>如果同意建立连接，则向A发送确认报文段，此报文段中SYN=1，确认位ACK=1，确认号为ack=x+1，同时选择一个初始序号seq=y</strong>。此报文段也<strong>不能携带数据，但同样要消耗一个序号</strong>。此时B进入<strong>SYN-RCVD（同步收到）状态</strong></p></li><li><p>A收到B的确认报文段后，还要向B发送确认报文段。<strong>此报文段中ACK=1，ack=y+1，seq=x+1</strong>。TCP规定<strong>ACK报文段可以携带数据，但如果不携带数据则不消耗序号，所以下一个数据报文段的序号仍是seq=x+1</strong>。此时A进入<strong>ESTABLISHED（以建立连接）状态</strong></p></li><li><p>当B收到A的确认后，也进入<strong>ESTABLISHED（以建立连接）状态</strong></p></li></ul><ol start="2"><li><strong>TCP释放连接——四次挥手</strong></li></ol><ul><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzAxMjIyNTM1MTM4?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="四次挥手"></p></li><li><p>A向B发送连接释放报文段并停止发送数据。<strong>此报文段中终止控制位FIN=1，seq=u（等于前面已传送过的数据的最后一个字节加1）</strong>。此时A进入<strong>FIN-WAIT-1（终止等待1）状态</strong>。TCP规定，<strong>FIN报文段即使不携带数据也要消耗一个序号</strong></p></li><li><p>B收到连接释放报文段后就发出确认报文段。<strong>此报文段中确认号ack=u+1，seq=v（等于前面已传送过的数据的最后一个字节加1）</strong>。此时B进入<strong>CLOSE-WAIT（关闭等待）状态</strong>。TCP服务器进程通知应用进程，A到B的连接释放了，这时的<strong>TCP连接处于半关闭（half-close）状态</strong>，但B到A的连接并未关闭，此时<strong>B发数据，A仍要接收</strong></p></li><li><p>A收到B的确认后，就进入<strong>FIN-WAIT2（终止等待2）状态</strong>，等待B发出的连接释放报文段</p></li><li><p>如果B已没有要发送的数据，就发送连接释放报文段。<strong>此报文段中FIN=1，seq=w（在半关闭状态中B可能发送了数据），ack=u+1</strong>。此时B进入<strong>LAST-ACK（最后确认）状态</strong></p></li><li><p>A收到了B的连接释放报文段后就发出确认报文段。<strong>此报文段中ACK=1，ack=w+1，seq=u+1</strong>。此时A进入<strong>TIME-WAIT（时间等待）状态</strong></p></li><li><p>此时TCP连接还没有释放掉，<strong>必须经过时间等待计时器（TIME-WAIT timer）设置的2倍的最长报文段寿命MSL（Maximum Segment Lifetime）后，A才进入到CLOSED状态</strong>。MSL建议设为<strong>2分钟</strong>。<strong>当A撤销相应的传输控制块TCB后，就结束了这次TCP连接</strong></p></li><li><p><strong>B收到A的确认报文，就进入CLOSEWD状态。B撤销相应的传输控制块TCB后，就结束了这次的TCP连接</strong></p></li></ul><ol start="3"><li><strong>为什么要设置TIME-WAIT？</strong></li></ol><ul><li><p>原因一：<strong>保证A发送的最后一个ACK报文能够到达B</strong>。因为这个ACK报文有可能丢失，B收不到这个对FIN+ACK报文的确认，所以B就会超时重传这个FIN+ACK报文段，这样A就能在2MSL时间内收到重传的FIN+ACK，接着A再重传一次确认报文段，重新启动时间等待计时器</p></li><li><p>原因二：<strong>A在发送完最后一个ACK报文段后，经过2MSL后，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失</strong></p></li></ul><ol start="4"><li><strong>为什么是三次握手？</strong></li></ol><ul><li><p><strong>为了防止已失效的连接请求报文段突然有送到了B，因而产生错误</strong></p></li><li><p>假设两次握手时，<strong>A发出的第一个请求连接报文段在某一网络节点长时间滞留，以致延误到连接释放后才到达B</strong>。B收到失效的连接请求报文段后，认为是A又发出一次新的连接请求。于是向A发送确认报文段，同意建立连接，此时在假定两次握手的前提下，连接建立成功。这样会导致B的资源白白浪费</p></li><li><p>假设两次握手时，<strong>A发出一个请求报文段，但发送过后A就因为问题而导致下线</strong>。之后B收到了A发来的请求连接报文段，给A发送确认报文段，同意建立连接，此时在假定两次握手的前提下，连接建立成功。这样会导致B的资源白白浪费</p></li></ul><ol start="5"><li><strong>为什么是四次挥手？</strong></li></ol><ul><li><p><strong>TCP协议是全双工通信，这意味着客户端和服务器端都可以向彼此发送数据，所以关闭连接是双方都需要确认的共同行为</strong></p></li><li><p>假设是三次挥手时，首先释放了A到B方向的连接，此时TCP连接处于半关闭<strong>（Half-Close）状态，这时A不能向B发送数据，而B还是可以向A发送数据</strong>。如果此时A收到了B的确认报文段后，就立即发送一个确认报文段，<strong>这会导致B向A还在发送数据时连接就被关闭。这样会导致A没有完整收到B所发的报文段</strong></p></li></ul><ol start="6"><li><strong>总结</strong></li></ol><ul><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzAxMjIyNjExNDY4?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="TCP的有限状态机"></p></li><li><p>粗实线箭头表示<strong>客户端的正常变迁</strong></p></li><li><p>粗虚线箭头表示<strong>服务器的正常变迁</strong></p></li><li><p>细线箭头表示<strong>异常变迁</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP拥塞控制——快重传与快恢复</title>
    <link href="/2020/06/30/fast-retransmission-and-fast-recovery/"/>
    <url>/2020/06/30/fast-retransmission-and-fast-recovery/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>TCP可靠传输中不仅有慢开始与拥塞避免相结合，还有快重传与快恢复相结合。。。→_→</em> *</strong></p><ol><li><strong>快重传（Fast Retransmit）</strong></li></ol><ul><li><p><strong>要求接收方每收到一个失序的报文段后就立即发出重复确认而不是等待自己发送数据时才捎带确认</strong></p></li><li><p><strong>发送方只要一连收到三个重复确认就立即重传对方尚未收到的报文段，而不必等待设置的重传计时器到期</strong></p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzAxMTE1MzUyMjgx?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="快重传原理"></p></li><li><p>有的快重传实现把开始时的<strong>拥塞窗口cwnd设置为ssthresh+3*MSS</strong>的字节数值，原因是认为收到三个重复确认后，表明网络中已经有三个分组离开了，证明现在网络中并没有堆积分组，因此适当增大拥塞窗口</p></li></ul><ol start="2"><li><strong>快恢复（Fast Recovery）</strong></li></ol><ul><li><p><strong>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限ssthresh减半</strong>，为了预防网络拥塞</p></li><li><p><strong>将拥塞窗口cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法</strong></p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzAxMTE1NTA4MTYz?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="快重传与快恢复"></p></li><li><p>TCP Tahoe版本与TCP Reno版本的区别：<strong>Reno版本在快重传之后采用快恢复算法而不是采用慢开始算法</strong></p></li></ul><ol start="3"><li>总结</li></ol><ul><li><p>采用快恢复算法时，慢开始算法只是在TCP建立连接和网络出现超时时才使用</p></li><li><p>接收方根据自己的接收能力设定了接收窗口rwnd，将此窗口值写入TCP首部传送给对方。<strong>结合拥塞控制，发送方的发送窗口一定不能大于接收方给出的接收窗口且一定不能大于自己的拥塞窗口</strong></p></li><li><p><strong>发送方的发送窗口的上限值 = Min[rwnd， cwnd]</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP拥塞控制——慢开始与拥塞避免AIMD</title>
    <link href="/2020/06/30/slow-start-and-congestion-avoidance/"/>
    <url>/2020/06/30/slow-start-and-congestion-avoidance/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>之前总结了TCP拥塞控制的原理， 这次来看看具体的设计算法——慢开始与拥塞避免。。。→_→</em> *</strong></p><ol><li><strong>拥塞窗口cwnd（Congestion Window）</strong></li></ol><ul><li><p>发送方维持一个叫做拥塞窗口的状态变量，<strong>拥塞窗口的大小取决于网络的拥塞程度且动态变化</strong>。发送方让自己的<strong>发送窗口等于拥塞窗口</strong>，如果还考虑接收方的接受能力，那么<strong>发送窗口还可能小于拥塞窗口</strong></p></li><li><p>发送方控制拥塞窗口的原则：<strong>只要网络没有出现拥塞，就增大拥塞窗口</strong>，以便将更多的分组发送出去；<strong>只要网络出现拥塞（发送方没有按时收到应当到达的确认报文），就减少拥塞窗口</strong>，以减少注入到网络中的分组数</p></li></ul><ol start="2"><li><strong>慢开始（Slow Start）</strong>算法</li></ol><ul><li><p><strong>由小到大逐渐增加发送窗口，相当于由小到大逐渐增大拥塞窗口数值</strong>。通常在<strong>刚开始发送报文段时，先把拥塞窗口cwnd设置为一个最大报文段MSS的字节数</strong>，当<strong>每收到一个对新的报文的确认后，就将拥塞窗口增加至多一个MSS的字节数</strong>，以逐渐增大发送方的拥塞窗口cwnd</p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzAxMTAwMTIxOTY0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="拥塞窗口的变化"></p></li><li><p>使用慢开始算法后，<strong>每经历一个传输轮次（Transmission Round），拥塞窗口cwnd就加倍</strong></p></li><li><p><strong>传输轮次：一个传输轮次所经历的时间是往返时间RTT</strong>。这里更加强调是<strong>将拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到对发送的最后一个字节的确认</strong></p></li></ul><ol start="3"><li><strong>拥塞避免（Congestion Avoidance ）</strong></li></ol><ul><li><strong>让拥塞窗口cwnd缓慢的增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1</strong>，而不是加倍，所以拥塞窗口按线性规律缓慢增长，比慢开始算法的拥塞窗口增长更加缓慢</li></ul><ol start="4"><li><strong>慢开始门限ssthresh</strong></li></ol><ul><li><p><strong>防止拥塞窗口cwnd增长过大引起网络拥塞</strong>，还需要设置慢开始门限ssthresh状态变量</p></li><li><p>当<strong>cwnd &lt; ssthresh</strong>时，使用<strong>慢开始算法</strong></p></li><li><p>当<strong>cwnd == ssthresh</strong>时，可以<strong>使用慢开始算法，也可以使用拥塞避免算法</strong></p></li><li><p>当<strong>cwnd &gt; ssthresh</strong>时，使用<strong>拥塞避免算法</strong></p></li><li><p>无论使用哪种算法，<strong>只要发送方判断网络出现拥塞，就把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半，把拥塞窗口cwnd设置为1，执行慢开始算法</strong></p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzAxMTAwMzU2Nzk1?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="慢开始和拥塞避免算法"></p></li></ul><ol start="5"><li>总结</li></ol><ul><li><p><strong>乘法减小（Multiplicative Decrease）：不论在慢开始阶段或拥塞避免阶段，只要出现超时，就把慢开始门限值减半（当前拥塞窗口的一半）</strong></p></li><li><p><strong>加法增大（Additive Increase）：执行拥塞避免算法后，使拥塞窗口缓慢增大，以防止网络过早出现拥塞</strong></p></li><li><p>将这两种算法结合起来被称为<strong>AIMD算法</strong></p></li><li><p><strong>拥塞避免不能完全避免拥塞，只是在拥塞避免阶段将拥塞窗口控制为线性增长，使网络不容易出现拥塞</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP拥塞控制原理</title>
    <link href="/2020/06/30/congestion-control/"/>
    <url>/2020/06/30/congestion-control/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>TCP可靠传输是为了提高点对点的数据传输效率，而真实网络情况非常复杂，所以使用拥塞控制进一步提高网络利用率。这篇总结一下TCP拥塞控制的原理。。→_→</em> *</strong></p><ol><li><p>拥塞控制的定义：在某段时间，<strong>若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏</strong>，这种情况就叫做<strong>拥塞（Congestion）</strong>。<strong>拥塞控制是为了防止过多的数据注入到网络，使网络中的路由器或链路不致过载</strong></p></li><li><p><strong>拥塞控制与流量控制的关系</strong></p></li></ol><ul><li><p>拥塞控制的前提是网络能够承受现有的网络负荷。其是一个全局性的过程，涉及到所有的主机、路由器以及降低网络传输性能有关的所有因素<strong>重点内容</strong></p></li><li><p>流量控制是针对<strong>点对点通信量、端到端的控制</strong>，其所要做的就是<strong>抑制发送端发送数据的速率，一边接收端来的及接收</strong></p></li><li><p>某些拥塞控制的控制算法是<strong>向发送端发送控制报文并告诉发送端，网络已出现故障，必须放慢发送速率</strong>，这点又和流量控制相似</p></li></ul><ol start="3"><li><strong>实际网络中的拥塞情况</strong></li></ol><ul><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjMwMTY1NTA5OTMw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="拥塞控制的作用"></p></li><li><p>横坐标是提供的负载，表示<strong>单位时间内输入给网络的分组数目</strong></p></li><li><p>纵坐标是吞吐量，表示<strong>单位时间内从网络输出的分组数目</strong></p></li><li><p>实际网络情况中，<strong>随着提供的负载增大，网络吞吐量的增长速率逐渐减小</strong>。在<strong>网络吞吐量还没有饱和时，就已经有一部分分组被丢弃了</strong>。当<strong>网络的吞吐量远小于理想吞吐量时，网络就进入了轻度拥塞的状态</strong>。<strong>当提供的负载达到某一数值时，网络的吞吐量开始下降，这是网络就进入了拥塞状态</strong>。当<strong>提供的负载继续增大到某一数值时，网络的吞吐量就下降到零，此时进入死锁（DeadLock）</strong></p></li></ul><ol start="4"><li><p><strong>拥塞控制的设计方放</strong></p><ol><li><p>开环控制：在设<strong>计网络时事先将有关发生拥塞的因素考虑周到</strong>，力求网络在工作时不产生拥塞。但<strong>一旦整个系统运行起来，就不再中途进行改正</strong></p></li><li><p><strong>闭环控制是基于反馈环路</strong>的概念</p></li></ol><ul><li><p><strong>监测网络系统以便检测拥塞在何时何处发生</strong></p></li><li><p><strong>把拥塞发生的信息传送到可采取行动的地方</strong></p></li><li><p><strong>调整网络系统的运行以解决出现的问题</strong></p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP可靠传输——流量控制</title>
    <link href="/2020/06/30/flow-control/"/>
    <url>/2020/06/30/flow-control/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>TCP还使用流量控制来保证可靠传输。。→_→</em> *</strong></p><ol><li><strong>流量控制（Flow Control）</strong>的含义</li></ol><ul><li><p><strong>流量控制就是让发送方的发送速率不要太快，让接收方来得及接收</strong></p></li><li><p>利用滑动窗口实现流量控制，告诉对方下一次我能接收的最大数据长度</p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjMwMTYzNTIxMDEw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="利用滑动窗口实现流量控制"></p></li><li><p><strong>发送方的发送窗口不能超过接收方给出的接收窗口的数值</strong>。TCP的窗口单位是字节，不是报文段</p></li></ul><ol start="2"><li><p>流量控制中出现的问题</p><ol><li>B向A发送零窗口报文段后不久，B的接收缓存有了可用空间。于是B向A发送非零窗口通知，但这个报文段在传输过程中丢失了。<strong>A一直等待B的非零窗口通知，B也在一直等待A发送的数据，如果不采取措施，就会进入死锁状态</strong>。</li></ol></li></ol><ul><li><p>解决方法：<strong>TCP为每一个连接设有一个持续计时器（Persistence Timer）</strong>。<strong>只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节数据），而对方就在确认这个探测报文段时给出现在的窗口值。如果窗口值仍然是零，那么收到这个报文段的一方就重新设置持续计时器。如果窗口不是零，那么死锁被打破。</strong></p><ol start="2"><li>如何<strong>控制TCP发送报文段的时机</strong></li></ol></li><li><p>第一种机制：<strong>TCP维持一个变量，它等于最大报文段长度MSS</strong>。只要<strong>缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去</strong></p></li><li><p>第二种机制：<strong>由发送方的应用进程指明要求发送报文段</strong>，即TCP支持的<strong>推送（push）操作</strong></p></li><li><p>第三种机制：<strong>发送方的计时器到期了，这时就把当前已有的缓存数据装入报文段（但长度不能超过MSS）发送出去</strong></p><ol start="3"><li>在线路带宽不富裕时，如何有效地<strong>提高网络吞吐量</strong></li></ol></li><li><p><strong>适当的推迟发回确认报文，并尽量使用捎带确认的方法</strong></p></li><li><p>使用<strong>Nagle算法</strong>：若发送应用进程把要发送的数据<strong>逐个字节的送到TCP的发送缓存</strong>，则发送方就<strong>把第一个数据字节先发送出去</strong>，把<strong>后面到达的数据字节都缓存起来</strong>。当发送方<strong>收到对第一个数据字节的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去</strong>，同时<strong>继续对随后到达的数据进行缓存</strong>。只有在<strong>收到对前一个报文段的确认后才继续发送下一个报文段</strong>。算法还规定，当到达的<strong>数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段</strong></p><ol start="4"><li><strong>糊涂窗口综合症（Silly Window Syndrome）</strong>：TCP<strong>接收方的缓存已满，而应用进程一次只从接收缓存中读取1个字节，然后向发送方发送确认并把窗口设置为1个字节</strong>。接着，<strong>发送方又发来一个字节的数据</strong>。<strong>接收方发回确认，仍然将窗口设置为1个字节</strong>。如此下去，网络效率非常低</li></ol></li><li><p>解决方法：<strong>让接收方等待一段时间，使接收缓存已有足够空间容纳一个最长的报文段或等到接收缓存已有一半空闲的空间</strong>，此时接收方就<strong>发出确认报文</strong>，并向发送方通知当前的窗口大小。此外，<strong>发送方也不要发送太小的报文段，而是把数据积累成足够大的报文段或达到接收方缓存的空间的一半大小</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP可靠传输——滑动窗口</title>
    <link href="/2020/06/30/sliding-window/"/>
    <url>/2020/06/30/sliding-window/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>TCP协议保证可靠的数据传输。。使用哪些方法来保证呢。。？来瞧瞧滑动窗口。。→_→</em> *</strong></p><ol><li>滑动窗口的定义</li></ol><ul><li><p>TCP滑动窗口以<strong>字节为单位</strong></p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjMwMTYyNTU2Mzkx?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="根据接收方的窗口值调整发送方的发送窗口"></p><ul><li>发送窗口表示，<strong>在没有收到接收方的确认时，发送方可以把窗口内的数据都发送出去</strong>。<strong>发送过的数据在未收到确认之前都必须暂时保留，以便超时重传使用</strong></li></ul></li><li><p><strong>发送窗口的位置由窗口前沿和后沿共同决定。</strong></p><ul><li><p>后沿不动——没有收到新的确认</p></li><li><p><strong>后沿前移——收到了新的确认</strong></p></li><li><p>前沿前移——没有收到新的确认，接收方的窗口大小不变</p></li><li><p><strong>前沿不动——收到了新的确认，接收方的窗口缩小</strong></p></li></ul></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjMwMTYyNjU4MzQw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="发送窗口指针"></p><ul><li><p>P3 - P1 = <strong>A的发送窗口（通知窗口）</strong></p></li><li><p>P2 - P1 = <strong>已发送但尚未收到确认的字节数</strong></p></li><li><p>P3 - p2 = <strong>允许发送但尚未发送的字节数（可用窗口或有效窗口）</strong></p></li></ul></li></ul><ol start="2"><li>缓存和窗口的关系</li></ol><ul><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjMwMTYyNzMyMzYy?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="发送缓存和发送窗口的关系"></p><ul><li><p>发送缓存存放：<strong>应用程序传送给TCP的准备发送的数据和TCP已发送但尚未收到确认的数据</strong></p></li><li><p><strong>发送窗口只是发送缓存的一部分，发送缓存和发送窗口的后沿是重合的</strong></p></li></ul></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjMwMTYyODM1MTY5?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="接收缓存和接收窗口的关系"></p><ul><li><p>接收缓存存放：<strong>按序到达、但尚未被应用程序读取的数据和未按序到达的数据</strong></p></li><li><p><strong>如果应用程序不及时读取缓存数据，那接收缓存最终就会被填满，使接收窗口减小到零</strong></p></li><li><p>如果<strong>应用程序即使读取缓存数据，接收窗口就可以增大，但最大不超过接收缓存的大小</strong></p></li></ul><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输控制协议TCP（Transmission Control Protocol）报文格式</title>
    <link href="/2020/06/30/transmission-control-protocol/"/>
    <url>/2020/06/30/transmission-control-protocol/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>这篇总结一下TCP协议的内容和特点。。→_→</em> *</strong></p><ol><li>TCP协议的特点</li></ol><ul><li><p>TCP是<strong>面向连接</strong>的运输层协议：<strong>先建立连接，再传输数据，最后释放连接</strong></p></li><li><p>每一条TCP连接只能有两个端点，每一条TCP连接只能是<strong>点对点</strong>的</p></li><li><p>TCP提供<strong>可靠交付的服务</strong>：通过TCP传输的数据，<strong>无差错、不丢失、不重复、按序到达</strong></p></li><li><p>TCP提供<strong>全双工服务</strong>：<strong>TCP连接双方都设有发送缓存、接收缓存用来临时存放双向通信的数据。TCP在合适的时候将数据发送或应用程序在合适的时候读取数据</strong></p></li><li><p><strong>面向字节流</strong>：流入到进程或从进程流出的字节序列，<strong>TCP把应用程序交下来的数据看成一连串的无结构的字节流</strong></p></li></ul><ol start="2"><li>TCP的连接</li></ol><ul><li><p>TCP的连接的端点叫做<strong>套接字（socket）</strong>，<strong>端口号拼接到IP地址即构成了套接字</strong></p></li><li><p><strong>套接字 socket = （IP地址：端口号）</strong></p></li><li><p>同一个IP地址可以有多个不同的TCP连接，同一个端口号也可以出现在多个不同的TCP连接中</p></li></ul><ol start="3"><li>TCP报文段首部格式</li></ol><ul><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjMwMTYxNTE5NjM2?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="TCP报文段首部格式"></p></li><li><p><strong>源端口和目的端口</strong>：各占2个字节，分别写入源端口号和目的端口号</p></li><li><p><strong>序号</strong>：占4字节，序号范围[0，(2^32) - 1]。<strong>序号增加到 (2^32) - 1后，下一个序号就又回到0</strong>。在TCP连接中<strong>传送的字节流中的每一个字节都按顺序编号</strong>。整个要传送的字节流的起始序号必须在连接建立时设置。<strong>序号字段值指本报文段所发送的数据的第一个字节的序号</strong></p></li><li><p><strong>确认号</strong>：占4字节，<strong>是期望收到对方下一个报文段的第一个数据字节的序号</strong>。<strong>若确认号为N，则说明序号N-1为止的所有数据都以正确收到</strong></p></li><li><p><strong>数据偏移</strong>：占4位，指出<strong>TCP报文段的数据起始处距离TCP报文段的起始处的距离</strong>，即<strong>TCP报文段的首部长度</strong>。其单位为4字节，所以<strong>数据偏移的最大值为60字节</strong>，即TCP首部最大长度（<strong>选项长度不能超过40字节</strong>）</p></li><li><p><strong>保留</strong>：占6位，保留今后使用，<strong>目前应置为0</strong></p></li><li><p><strong>紧急URG（URGent）：仅当URG=1时紧急字段有效，表明紧急指针字段有效。告诉系统此报文段有紧急数据，应尽快传送，而不要按照原来的排列顺序来传送。发送方TCP把把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的仍为普通数据，此时与紧急指针字段（Urgent Pointer）配合使用</strong></p></li><li><p><strong>确认ACK（ACKnowledgment）：仅当ACK=1时确认号字段有效，在连接建立后所有传送的报文段都必须把ACK置1</strong></p></li><li><p><strong>推送PSH（PuSH）：仅当PSH=1时推送字段有效，发送方将PSH置1，并立即创建一个报文段发送出去，接收方收到PSH=1的报文段，就尽快交付接收应用程序，而不在等到整个缓存都填满后再向上交付，当接收方的接收窗口为零时，也可以发送</strong></p></li><li><p><strong>复位RST（ReSeT）：仅当RST=1时复位字段有效，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接</strong>。还用来拒绝非法的报文段或拒绝打开一个连接</p></li><li><p><strong>同步SYN（SYNchronization）：仅当SYN=1时同步字段有效，在连接建立时用来同步序号。当SYN=1且ACK=0时，表明这是一个连接请求报文段。当SYN=1且ACK=1时，表明这一个对方同意建立连接的响应报文段。</strong></p></li><li><p><strong>终止FIN（FINis）：仅当FIN=1时终止字段有效，用来释放一个连接，当FIN=1时表明此报文段的发送方的数据已发送完毕，并要求释放连接</strong></p></li><li><p><strong>窗口</strong>：占2字节，窗口值[0，2^(16) - 1]。指<strong>发送本报文段的一方的接收窗口大小，告诉对方现在允许对方发送的数据量</strong>，即窗口值作为接收方让发送方设置其发送窗口的依据。TCP规定即使为零窗口，也要接收零窗口探测报文、确认报文段和携带紧急数据的报文段</p></li><li><p><strong>检验和</strong>：占2字节，<strong>检验范围包括首部和数据</strong>。计算检验和时，在<strong>TCP报文段的前面加上12字节的伪首部</strong>。接收方收到此报文段后，仍要加上伪首部计算检验和</p></li><li><p><strong>紧急指针</strong>：占2字节，<strong>紧急指针仅在URG=1时才有意义，指出本报文段中的紧急数据的字节数，即紧急数据的末尾在报文段中的位置。当紧急数据处理完后，TCP就告诉应用程序恢复到正常操作。窗口值为零时也可发送紧急数据</strong></p></li><li><p><strong>选项</strong>：长度可变，最长可达40字节</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用户数据报协议UDP（User Datagram Protocol）报文格式</title>
    <link href="/2020/06/30/user-datagram-protocol/"/>
    <url>/2020/06/30/user-datagram-protocol/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>运输层两大主要协议之一。。。UDP。。这篇总结一下UDP协议的内容和特点。。→_→</em> *</strong></p><ol><li>UDP协议的特点</li></ol><ul><li><p>UDP是<strong>无连接的</strong>，即<strong>传输数据时不需要建立或释放连接</strong>，<strong>减少了开销和发送数据之前的时延</strong></p></li><li><p>UDP使用<strong>尽最大努力交付</strong>，即<strong>不保证可靠交付</strong></p></li><li><p>UDP是<strong>面向报文的</strong>。<strong>对应用程序交下来的报文在添加首部后就向下交付IP层。对应用层交下来的报文即不合并也不拆分，而是保留这些报文的边界</strong>。即<strong>UDP一次交付一个完整的报</strong></p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjMwMTYwMTM4OTk4?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="UDP是面向报文的"></p></li><li><p>UDP没有拥塞控制</p></li><li><p>UDP支持<strong>一对一、一对多、多对一和多对多的交互通信</strong></p></li><li><p>UDP的<strong>首部开销小，只有8字节</strong></p></li></ul><ol start="2"><li>UDP数据报首部格式</li></ol><ul><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjMwMTYwMzM5NTA2?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="UDP数据报首部格式"></p></li><li><p><strong>源端口</strong>：占2字节，源端口号。<strong>需要对方回信时选用，不需要时可用全0</strong></p></li><li><p><strong>目的端口</strong>：占2字节，目的端口号</p></li><li><p><strong>长度</strong>：占2字节，<strong>UDP用户数据报的长度，最小值为8（仅有首部）</strong></p></li><li><p><strong>检验和</strong>：占2字节，<strong>检验UDP用户数据报在传输中是否有错，有错就丢弃</strong></p></li><li><p><strong>计算检验和时要在UDP用户数据报之前增加12个字节的伪首部</strong></p></li><li><p><strong>伪首部不是UDP用户数据报真正的首部，只是在计算检验和时临时添加，变成临时UDP用户数据报</strong></p></li><li><p>UDP计算检验和方法和IP数据报首部检验和方法相似，但<strong>IP数据报的检验和只检验IP数据报的首部，UDP的检验和把首部和数据部分一起检验</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（32）把数组排成最小的数</title>
    <link href="/2020/06/30/arrange-the-squares-to-the-smallest-number/"/>
    <url>/2020/06/30/arrange-the-squares-to-the-smallest-number/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs arduino"><span class="hljs-comment">//要将所有元素组合成一个最小的数</span><span class="hljs-comment">//那么组合的相邻元素之间都是num1num2的形式</span><span class="hljs-comment">//所以使用库函数的sort将各个元素以strCompare的条件进行排序</span><span class="hljs-comment">//strCompare的条件为比较num1num2与num2num1之间的大小，较小的情况返回为true</span><span class="hljs-comment">//注意</span><span class="hljs-comment">//1.在进行元素组合时有可能发生数值溢出的情况，所以使用字符串进行比较和组合</span><span class="hljs-comment">//2.输入vector为空</span><span class="hljs-comment">//3.输入vector只有一个元素时，直接输出</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class">&#123;</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">strCompare</span><span class="hljs-params">(<span class="hljs-built_in">string</span> strNum1, <span class="hljs-built_in">string</span> strNum2)</span><span class="hljs-comment">//条件函数</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">string</span> strCombine1 = strNum1 + strNum2;<span class="hljs-comment">//记录num1num2</span><span class="hljs-built_in">string</span> strCombine2 = strNum2 + strNum1;<span class="hljs-comment">//记录num2num1</span><span class="hljs-keyword">return</span> strCombine1 &lt; strCombine2;<span class="hljs-comment">//较小的返回为true</span>&#125;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">PrintMinNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; numbers)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">string</span> result;<span class="hljs-comment">//记录最小的数的字符串形式</span><span class="hljs-keyword">int</span> len = numbers.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//计算元素个数</span><span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<span class="hljs-comment">//没有元素</span><span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> to_string(numbers[<span class="hljs-number">0</span>]);<span class="hljs-comment">//只有一个元素，直接返回</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; strNumVec;<span class="hljs-comment">//记录排序好的元素顺序</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len;++i)strNumVec.push_back(to_string(numbers[i]));sort(strNumVec.<span class="hljs-built_in">begin</span>(), strNumVec.<span class="hljs-built_in">end</span>(), strCompare);<span class="hljs-comment">//进行元素排序</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; ++j)<span class="hljs-comment">//</span>result = result + strNumVec[j];<span class="hljs-keyword">return</span> result;<span class="hljs-comment">//返回组合，系最小的数的字符串形式</span>&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——系统调用</title>
    <link href="/2020/06/29/system-call/"/>
    <url>/2020/06/29/system-call/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>昨天总结了main函数前世今生的问题，跟着源码一步步看。。。今天来看看系统调用是什么。。。→_→</em> *</strong></p><blockquote><p><strong>系统调用（System Call）是应用程序与操作系统与内核之间的接口</strong></p></blockquote><ol><li><p><strong>系统调用（System Call）</strong>的定义</p><ul><li><p><strong>现代操作系统将可能产生冲突的系统资源（包括文件、I/O等设备）保护起来，阻止应用程序直接访问</strong></p></li><li><p>为了让应用程序有能力访问系统资源，也为了让程序借助操作系统做一些必须由操作系统支持的行为，每个操作系统都提供一套接口，以供应用程序使用</p></li><li><p><strong>这些接口往往通过中断实现</strong>，比如<strong>Linux使用0x80号端口作为系统调用的入口</strong>，Windows采用0x2E号中断作为系统调用入口</p></li></ul></li><li><p><strong>系统调用的弊端</strong></p><ul><li><p><strong>使用不便</strong>：操作系统提供的系统调用接口过于原始，没有进行很好的包装，使用起来不方便</p></li><li><p>各个操作系统之间调用不兼容</p></li><li><p>解决方法：<strong>运行库作为系统调用与程序之间的抽象层，可以简化使用，统一形式</strong></p></li><li><p>运行时库将不同的操作系统的系统调用包装成统一固定的接口，使得同样的代码在不同的操作系统下都可以直接编译并产生一致的效果，即<strong>源代码级别上的可移植性</strong></p></li></ul></li><li><p><strong>系统调用的原理</strong></p><ul><li><p>现代操作系统中通常有两种特权级别：<strong>用户态（User Mode）和内核态（Kernel Mode）</strong>。操作系统根据不同的特权，<strong>使不同的代码运行在不同的模式上以限制其权利，提高稳定性和安全性</strong></p></li><li><p><strong>系统调用是运行在内核态的，而应用程序基本都是运行在用户态的</strong></p></li><li><p>操作系统一般通过<strong>中断（Interrupt）来从用户态切换到内核态</strong></p></li><li><p><strong>中断是一个硬件或软件发出的请求，要求CPU暂停当前的工作转手去处理更重要的事情</strong>。中断一般具有两个属性，一个称为<strong>中断号（从0开始）</strong>，一个称为<strong>中断处理程序（Interrupt Service Routine， ISR）</strong>。<strong>不同的中断具有不同的中断号，而中断处理程序又与中断号一一对应</strong>。在内核中，<strong>有一个数组称为中断向量表（Interrupt Vector Table）</strong>，<strong>这个数组的第n项包含了指向第n号中断的中断处理程序指针</strong>。</p></li><li><p><strong>当中断到来时，CPU会暂停执行当前执行的代码，根据中断的中断号，在中断向量表中找到对应的中断处理程序，并调用它。中断处理程序执行完成之后，CPU会继续执行之前的代码</strong></p><p>  <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MjIxOTE1MTY4?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="CPU中断过程"></p></li></ul></li></ol><ol start="4"><li><p><strong>Linux系统调用流程</strong></p><ul><li><p><strong>在x86下，系统调用由0x80中断完成，各个通用寄存器用于传递参数，EAX寄存器用于表示系统调用的接口号。当系统调用返回时，EAX寄存器又作为调用结果的返回值</strong></p></li><li><p><strong>每个系统调用都对应于内核源代码中的一个函数，他们都以“sys_”开头</strong>。（定义路径：linux-2.4.0\include\asm-i386\Unistd.h）</p></li><li><p>基于int的Linux经典系统调用实现</p><p>  <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI1MTEzODE1Njgz?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="Linux系统中断流程"></p></li></ul></li><li><p>Linux系统调用源码剖析</p><ul><li><p><strong>_syscall0宏函数</strong>:<strong>无参的系统调用的封装</strong>，<strong>第一个参数为系统调用的返回值类型，第二个参数是系统调用的的名称</strong>，其展开后形成一个与系统调用名称同名的函数</p>  <pre><code class="hljs fsharp"><span class="hljs-comment">//linux-2.4.0\include\asm-i386\Unistd.h </span>#define _syscall0(<span class="hljs-class"><span class="hljs-keyword">type</span>,<span class="hljs-title">name</span>) \</span><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">name</span></span>(<span class="hljs-keyword">void</span>) \&#123; \long __res; \__asm__ volatile (<span class="hljs-string">"int $0x80"</span> \<span class="hljs-comment">//volatile防止编译器对代码优化</span>: <span class="hljs-string">"=a"</span> (__res) \<span class="hljs-comment">//表示用EAX输出返回数据并存储在__res中</span>: <span class="hljs-string">"0"</span> (__NR_##name)); \<span class="hljs-comment">//表示和输出相同的寄存器EAX传递参数</span>__syscall_return(<span class="hljs-class"><span class="hljs-keyword">type</span>,<span class="hljs-title">__res</span>); \</span>&#125;</code></pre></li><li><p><strong>_syscall1宏函数</strong>：<strong>带有一个参数的系统调用的封装，通过EBX寄存器传入</strong>。x86下的Linux支持的系统调用参数至多有6个，<strong>分别使用6个寄存器来传递参数（EBX、ECX、EDX、ESI、EDI、EBP）</strong></p>  <pre><code class="hljs reasonml"><span class="hljs-comment">//linux-2.4.0\include\asm-i386\Unistd.h </span>#define <span class="hljs-constructor">_syscall1(<span class="hljs-params">type</span>,<span class="hljs-params">name</span>,<span class="hljs-params">type1</span>,<span class="hljs-params">arg1</span>)</span> \<span class="hljs-keyword">type</span> name(type1 arg1) \&#123; \long __res; \__asm__ volatile (<span class="hljs-string">"int $0x80"</span> \: <span class="hljs-string">"=a"</span> (__res) \<span class="hljs-comment">//把arg1强制转化为long，然后存放在EBX里作为输入。编译器也会生成相应的代码保护原来的EBX的值不被破坏</span>: <span class="hljs-string">"0"</span> (__NR_##name),<span class="hljs-string">"b"</span> ((long)(arg1))); \<span class="hljs-constructor">__syscall_return(<span class="hljs-params">type</span>,<span class="hljs-params">__res</span>)</span>; \&#125;</code></pre></li><li><p><strong>__syscall_return宏函数</strong>：用于<strong>检查系统调用返回值</strong>，并将其转化为C语言的errno错误码。在<strong>Linux中</strong>，<strong>系统调用使用返回值传递错误码，如果返回值为负数，表明调用失败，返回值的绝对值就是错误码</strong>。<strong>C语言中大多数函数以返回-1表示调用失败，将错误信息存储在名为errno的全局变量中</strong></p>  <pre><code class="hljs livescript"><span class="hljs-comment">#define __syscall_return(type, res)\</span><span class="hljs-keyword">do</span> &#123;<span class="hljs-string">\</span><span class="hljs-keyword">if</span> ((unsigned long)(res) &gt;= (unsigned long)(-<span class="hljs-number">125</span>)) &#123;<span class="hljs-string">\</span>errno = -(res);<span class="hljs-string">\</span>res = -<span class="hljs-number">1</span>;<span class="hljs-string">\</span>&#125;<span class="hljs-string">\</span><span class="hljs-keyword">return</span> (type) (res);<span class="hljs-string">\</span>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)</code></pre></li><li><p><strong>切换堆栈</strong>：在实际执行中断向量表中的第0x80号元素所对应的函数之前，<strong>CPU还要进行栈切换</strong>。在Linux中，<strong>用户态和内核态使用不同的栈，两者各自负责各自的函数调用</strong>。所谓<strong>当前栈即ESP所指的栈空间</strong>，<strong>寄存器SS保存当前栈所在的页</strong></p><p>  <strong>用户栈切换至内核栈</strong>步骤如下：</p><ul><li><strong>保存当前ESP、SS的值</strong></li><li><strong>将ESP、SS的值设置为内核栈的相应值</strong></li></ul><p>  <strong>内核栈切换至用户栈</strong>步骤如下：</p><ul><li><p><strong>恢复原来的ESP、SS的值</strong></p></li><li><p><strong>用户态的ESP和SS的值保存在内核栈上，由中断指令自动地由硬件完成</strong></p><p>CPU除了切入内核态之外，还自动完成：</p></li><li><p><strong>找到当前进程地内核栈（每一个进程都有自己的内核栈）</strong></p></li><li><p><strong>在内核栈中依次压入用户态的寄存去SS、ESP、EFLAGS、CS、EIP</strong></p></li></ul><p>  <strong>当内核从系统调用中返回时，需调用iret指令返回到用户态，iret指令会从内核栈中弹出寄存器SS、ESP、EFLAGS、CS、EIP的值，使栈恢复到用户态的状态</strong></p><p>  <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI1MjEyMzAyNzg3?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="中断时用户栈和内核栈切换"></p></li></ul></li></ol><ul><li><p><strong>中断处理程序</strong>：<strong>在int指令切换栈之后，程序流程就切换到了中断向量表中记录的0x80号中断处理程序</strong></p><pre><code>![Linux i386 中断服务流程](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI1MjEyNzQ0MzMz?x-oss-process=image/format,png)**初始化中断向量表**</code></pre>  <pre><code class="hljs reasonml"><span class="hljs-comment">//linux-2.4.0\arch\i386\kernel\Traps.c</span><span class="hljs-comment">//0-19号中断对应的中断处理程序包括算数异常（除零、溢出）、页缺失（page fault）、无效指令</span>void __init trap<span class="hljs-constructor">_init(<span class="hljs-params">void</span>)</span>&#123;......set<span class="hljs-constructor">_trap_gate(0,&amp;<span class="hljs-params">divide_error</span>)</span>;set<span class="hljs-constructor">_trap_gate(1,&amp;<span class="hljs-params">debug</span>)</span>;set<span class="hljs-constructor">_intr_gate(2,&amp;<span class="hljs-params">nmi</span>)</span>;set<span class="hljs-constructor">_system_gate(3,&amp;<span class="hljs-params">int3</span>)</span>;<span class="hljs-comment">/* int3-5 can be called from all */</span>set<span class="hljs-constructor">_system_gate(4,&amp;<span class="hljs-params">overflow</span>)</span>;set<span class="hljs-constructor">_system_gate(5,&amp;<span class="hljs-params">bounds</span>)</span>;set<span class="hljs-constructor">_trap_gate(6,&amp;<span class="hljs-params">invalid_op</span>)</span>;set<span class="hljs-constructor">_trap_gate(7,&amp;<span class="hljs-params">device_not_available</span>)</span>;set<span class="hljs-constructor">_trap_gate(8,&amp;<span class="hljs-params">double_fault</span>)</span>;set<span class="hljs-constructor">_trap_gate(9,&amp;<span class="hljs-params">coprocessor_segment_overrun</span>)</span>;set<span class="hljs-constructor">_trap_gate(10,&amp;<span class="hljs-params">invalid_TSS</span>)</span>;set<span class="hljs-constructor">_trap_gate(11,&amp;<span class="hljs-params">segment_not_present</span>)</span>;set<span class="hljs-constructor">_trap_gate(12,&amp;<span class="hljs-params">stack_segment</span>)</span>;set<span class="hljs-constructor">_trap_gate(13,&amp;<span class="hljs-params">general_protection</span>)</span>;set<span class="hljs-constructor">_trap_gate(14,&amp;<span class="hljs-params">page_fault</span>)</span>;set<span class="hljs-constructor">_trap_gate(15,&amp;<span class="hljs-params">spurious_interrupt_bug</span>)</span>;set<span class="hljs-constructor">_trap_gate(16,&amp;<span class="hljs-params">coprocessor_error</span>)</span>;set<span class="hljs-constructor">_trap_gate(17,&amp;<span class="hljs-params">alignment_check</span>)</span>;set<span class="hljs-constructor">_trap_gate(18,&amp;<span class="hljs-params">machine_check</span>)</span>;set<span class="hljs-constructor">_trap_gate(19,&amp;<span class="hljs-params">simd_coprocessor_error</span>)</span>;<span class="hljs-comment">//系统调用对应的中断号，在linux-2.4.0\include\asm-i386\Hw_irq.h中，SYSCALL_VECTOR定义0x80</span>set<span class="hljs-constructor">_system_gate(SYSCALL_VECTOR,&amp;<span class="hljs-params">system_call</span>)</span>;......&#125;</code></pre><pre><code>**调用int 0x80之后，最终执行system_call函数**<pre><code class="hljs lasso">ENTRY(system_call)<span class="hljs-params">...</span><span class="hljs-params">...</span>SAVE_ALL<span class="hljs-comment">//宏函数SAVE_ALL将各种寄存器压入栈中，即系统调用传入的参数</span><span class="hljs-params">...</span><span class="hljs-params">...</span>cmpl $(nr_syscalls), %eax<span class="hljs-comment">//比较EAX和nr_syscalls，nr_syscalls是比最大的调用号大1的值，如果eax（用户传入的系统调用号）大于等于nr_syscalls，则这个系统调用无效，则会跳转至syscall_badsys执行，反之执行syscall_call</span>jae syscall_badsyssyscall_call:call *sys_call_table(<span class="hljs-number">0</span>,%eax,<span class="hljs-number">4</span>)<span class="hljs-comment">//系统调用表中，每一个元素（long类型）都是一个系统调用函数的地址。因此调用的是sys_call_table上偏移量为0+%eax*4上的元素的值指向的函数</span><span class="hljs-params">...</span><span class="hljs-params">...</span>RESTORE_REGS<span class="hljs-comment">//执行结束后，使用宏函数恢复之前SAVE_ALL保存的的寄存器</span><span class="hljs-params">...</span><span class="hljs-params">...</span>iret<span class="hljs-comment">//最后通过指令iter从中断处理程序中返回</span></code></pre>![Linux系统调用流程](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI1MjMxNDEzNzIy?x-oss-process=image/format,png)</code></pre></li></ul><p>综上所述，<strong>Linux系统调用流程为：main  -&gt;  function  -&gt;  _syscall  -&gt;  int 0x80  -&gt;  __init trap_init  -&gt;  system_call  -&gt;  __syscall_return</strong></p><p><strong>* <em>so happy…so tired…→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——main函数的前世今生</title>
    <link href="/2020/06/29/the-past-and-present-of-the-main-function/"/>
    <url>/2020/06/29/the-past-and-present-of-the-main-function/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>当执行”Hello World“程序时，是从main函数开始执行的吗？答案当然是No，No，No！</em> *</strong></p><p>一个程序的运行步骤如下：</p><ul><li><p>操作系统在在创建进程后，把控制权交给了程序的入口，这个入口一般是<strong>运行库中的某个入口函数</strong></p></li><li><p>入口函数对<strong>运行库和程序运行环境进行初始化</strong>，包括堆、I/O、线程、全局变量构造等</p></li><li><p>入口函数完成初始化后，<strong>调用main函数，正式开始执行程序主体部分</strong></p></li><li><p><strong>main函数执行完毕后，返回到入口函数，入口函数进行清理工作</strong>，包括全局变量析构、堆销毁、关闭I/O等，<strong>然后进行系统调用结束进程</strong></p></li></ul><p><strong>接下来具体分析的是基于glibc 2.6.1中静态链接的、用于可执行文件的情况</strong></p><ol><li><p>第一步：glibc的程序入口为_start（这个入口是有ld链接器默认的链接脚本指定的，可以通过相关参数设定入口）</p><ul><li><p>_start由汇编实现且和平台相关</p>  <pre><code class="hljs reasonml"><span class="hljs-comment">//将汇编改写为伪代码</span>void start<span class="hljs-literal">()</span>&#123;%ebp = <span class="hljs-number">0</span>;<span class="hljs-comment">//使ebp为0，证明其是最外层函数</span><span class="hljs-built_in">int</span> argc = pop from stack;<span class="hljs-comment">//从栈中获取argc，隐含envp</span><span class="hljs-built_in">char</span> **argv = top from stack;<span class="hljs-comment">//从栈中获取argv</span><span class="hljs-comment">//调用_libc_start_main()函数</span><span class="hljs-constructor">_libc_start_main(<span class="hljs-params">main</span>, <span class="hljs-params">argc</span>, <span class="hljs-params">argv</span>, <span class="hljs-params">_libc_csu_init</span>, <span class="hljs-params">_libc_csu_fini</span>, <span class="hljs-params">edx</span>, <span class="hljs-params">top</span> <span class="hljs-params">of</span> <span class="hljs-params">stack</span>)</span>;&#125;</code></pre></li><li><p>栈分布情况<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjIxMTgxNjQ4OTA4?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="环境变量和参数数组"></p></li></ul></li><li><p>第二步：调用_libc_start_main()函数，下面对_libc_start_main()函数进行源码分析</p><ul><li>源码分析<pre><code class="hljs cpp"><span class="hljs-comment">//glibc-2.6.1\csu\Libc-start.c</span><span class="hljs-comment">//为使结构条理更加清晰，删减了部分代码</span><span class="hljs-comment">/*</span><span class="hljs-comment">_libc_start_main()参数说明</span><span class="hljs-comment">main</span><span class="hljs-comment">argc</span><span class="hljs-comment">ubp_av:包括argv和envp</span><span class="hljs-comment">函数指针init：main调用前的初始化工作</span><span class="hljs-comment">函数指针fini：main结束后的收尾工作</span><span class="hljs-comment">函数指针rtld_fini：动态加载有关的收尾工作（runtime loader）</span><span class="hljs-comment">stack_end：指明栈地址，即最高的栈地址</span><span class="hljs-comment">*/</span>STATIC <span class="hljs-keyword">int</span>LIBC_START_MAIN (<span class="hljs-keyword">int</span> (*main) (<span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span> **, <span class="hljs-keyword">char</span> ** MAIN_AUXVEC_DECL), <span class="hljs-keyword">int</span> argc,  <span class="hljs-keyword">char</span> *__unbounded *__unbounded ubp_av, __typeof (main) init, <span class="hljs-keyword">void</span> (*fini) (<span class="hljs-keyword">void</span>), <span class="hljs-keyword">void</span> (*rtld_fini) (<span class="hljs-keyword">void</span>),  <span class="hljs-keyword">void</span> *__unbounded stack_end)&#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __BOUNDED_POINTERS__</span>  <span class="hljs-keyword">char</span> **argv;<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> argv ubp_av</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>  <span class="hljs-comment">/* Result of the 'main' function.  */</span>  <span class="hljs-keyword">int</span> result;......<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SHARED</span>  <span class="hljs-keyword">char</span> *__unbounded *__unbounded ubp_ev = &amp;ubp_av[argc + <span class="hljs-number">1</span>];  INIT_ARGV_and_ENVIRON;<span class="hljs-comment">//将宏展开得到 __environ = ubp_ev，即让__environ指针指向envp</span>  <span class="hljs-comment">/* Store the lowest stack address.  This is done in ld.so if this is</span><span class="hljs-comment">     the code for the DSO.  */</span>  __libc_stack_end = stack_end;......<span class="hljs-meta"># <span class="hljs-meta-keyword">ifdef</span> DL_SYSDEP_OSCHECK</span>  <span class="hljs-keyword">if</span> (!__libc_multiple_libcs)    &#123;      <span class="hljs-comment">/* This needs to run to initiliaze _dl_osversion before TLS</span><span class="hljs-comment"> setup might check it.  */</span>      DL_SYSDEP_OSCHECK (__libc_fatal);<span class="hljs-comment">//检查操作系统版本</span>    &#125;<span class="hljs-meta"># <span class="hljs-meta-keyword">endif</span></span>......__pthread_initialize_minimal ();<span class="hljs-comment">//__cxa_atexit()为glibc内部函数，等同于atexit</span><span class="hljs-comment">//rtld_fini在main函数结束后调用</span>__cxa_atexit ((<span class="hljs-keyword">void</span> (*) (<span class="hljs-keyword">void</span> *)) rtld_fini, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);__libc_init_first (argc, argv, __environ);<span class="hljs-comment">//fini在main函数结束后调用</span>__cxa_atexit ((<span class="hljs-keyword">void</span> (*) (<span class="hljs-keyword">void</span> *)) fini, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);(*init) (argc, argv, __environ MAIN_AUXVEC_PARAM);......result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);<span class="hljs-comment">//开始执行main函数，result为退出码</span>......<span class="hljs-built_in">exit</span> (result);<span class="hljs-comment">//程序开始退出</span>&#125;</code></pre></li><li>栈分布情况<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjIxMjAyOTE4NjAw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="环境变量和参数数组(2)"></li></ul></li><li><p>第三步：调用exit()函数，下面对exit()函数进行源码分析</p> <pre><code class="hljs awk"><span class="hljs-regexp">//g</span>libc-<span class="hljs-number">2.6</span>.<span class="hljs-number">1</span>\stdlib\Exit.cvoid <span class="hljs-keyword">exit</span> (int status)&#123;<span class="hljs-regexp">//</span>__exit_funcs存储由cxa_atexit和atexit注册的函数链表<span class="hljs-regexp">//</span>遍历该链表并逐个调用注册函数<span class="hljs-keyword">while</span> (__exit_funcs != NULL)&#123;struct exit_function_list *old;......old = __exit_funcs;__exit_funcs = __exit_funcs-&gt;<span class="hljs-keyword">next</span>;<span class="hljs-regexp">//</span>依次指向节点<span class="hljs-keyword">if</span> (__exit_funcs != NULL)free (old);    &#125;......    _exit (status);&#125;</code></pre></li><li><p>第四步：调用_exit()函数，下面对_exit()函数进行源码分析</p> <pre><code class="hljs awk"><span class="hljs-regexp">//</span> glibc-<span class="hljs-number">2.6</span>.<span class="hljs-number">1</span>\sysdeps\mach\hurd\Dl-sysdep.c<span class="hljs-regexp">//</span>_exit函数调用后，进程就会直接结束<span class="hljs-regexp">//</span>程序正常结束的两种情况<span class="hljs-regexp">//</span><span class="hljs-number">1</span>.通过main函数正常返回<span class="hljs-regexp">//</span><span class="hljs-number">2</span>.程序代码中使用<span class="hljs-keyword">exit</span>void weak_function attribute_hidden _exit (int status)&#123;__proc_mark_exit (_dl_hurd_data-&gt;portarray[INIT_PORT_PROC], W_EXITCODE (status, <span class="hljs-number">0</span>), <span class="hljs-number">0</span>);<span class="hljs-keyword">while</span> (__task_terminate (__mach_task_self ()))__mach_task_self_ = (__mach_task_self) ();&#125;</code></pre></li></ol><p>经过对源代码的分析，可以肯定”Hello World“程序的确不是从main函数开始执行的！</p><blockquote><p><strong>综上所述，函数调用过程如下：</strong><br><strong><em>start -&gt;</em> libc_start_main -&gt; exit -&gt; _exit</strong></p></blockquote><p><strong>* <em>终于写完了。。。经历了源码找不到、源码看不懂之后，最后还是搞定了。。(●ˇ∀ˇ●)</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（31）整数中1出现的次数（从1到n整数中1出现的次数）</title>
    <link href="/2020/06/29/the-number-of-occurrences-of-1-in-the-integer/"/>
    <url>/2020/06/29/the-number-of-occurrences-of-1-in-the-integer/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>求出1<del>13的整数中1出现的次数,并算出100</del>1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">//方法一</span><span class="hljs-comment">//将所有的数遍历一次，对每一个数的每一位再进行是否为1的判断</span><span class="hljs-comment">//时间复杂度为O（n*logn）</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">private</span>:<span class="hljs-built_in">int</span> NumberOf1(unsigned <span class="hljs-built_in">int</span> n)&#123;        <span class="hljs-built_in">int</span> number = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(n)<span class="hljs-comment">//对此数字的每一位都进行判断</span>&#123;            <span class="hljs-keyword">if</span>(n % <span class="hljs-number">10</span> == <span class="hljs-number">1</span>)<span class="hljs-comment">//模10取余，判断是否为1</span>                number++;            n = n / <span class="hljs-number">10</span>;<span class="hljs-comment">//将最后一位舍弃</span>        &#125;        <span class="hljs-keyword">return</span> number;    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">int</span> NumberOf1Between1AndN(unsigned <span class="hljs-built_in">int</span> n)    &#123;        <span class="hljs-built_in">int</span> number = <span class="hljs-number">0</span>;<span class="hljs-comment">//计数器</span>        <span class="hljs-keyword">for</span>(unsigned <span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<span class="hljs-comment">//循环遍历所有的数</span>            number += NumberOf1(i);        <span class="hljs-keyword">return</span> number;    &#125;&#125;;</code></pre><pre><code class="hljs cpp"><span class="hljs-comment">//方法二</span><span class="hljs-comment">//时间复杂度为O(logn)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">PowerBase10</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> num)</span><span class="hljs-comment">//计算num与10次方的关系</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i)res *= <span class="hljs-number">10</span>;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//防御性动作，判断字符串是否存在、第一个数字是否合法、字符串是否为NULL</span><span class="hljs-keyword">if</span> (!str || *str &lt; <span class="hljs-string">'0'</span> || *str &gt; <span class="hljs-string">'9'</span> || *str == <span class="hljs-string">'\0'</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> first = *str - <span class="hljs-string">'0'</span>;<span class="hljs-comment">//取数字的最高位，将其转化为int</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> length = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">strlen</span>(str));<span class="hljs-comment">//计算数字的位数，将其转化为unsigned int</span><span class="hljs-keyword">if</span> (length == <span class="hljs-number">1</span> &amp;&amp; first == <span class="hljs-number">0</span>)<span class="hljs-comment">//如果是一位数且值为0，则直接返回0</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (length == <span class="hljs-number">1</span> &amp;&amp; first &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//如果是一位数且值大于0，则1只出现1次，直接返回1</span><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> numFirstDigit = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (first &gt; <span class="hljs-number">1</span>)<span class="hljs-comment">//如果第一位数大于1，则计算数字与10的次方关系</span>numFirstDigit = PowerBase10(length - <span class="hljs-number">1</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (first == <span class="hljs-number">1</span>)<span class="hljs-comment">//如果第一位数等于1，则1出现的次数为从最高位为1到最大值的差值再加一</span>numFirstDigit = atoi(str + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> numOtherDigits = first*(length - <span class="hljs-number">1</span>)*PowerBase10(length - <span class="hljs-number">2</span>);<span class="hljs-comment">//计算次高位开始的数出现1的次数</span><span class="hljs-keyword">int</span> numRecursive = NumberOf1(str + <span class="hljs-number">1</span>);<span class="hljs-comment">//递归计算从1开始到此数去掉最高位的数出现1的次数</span><span class="hljs-keyword">return</span> numFirstDigit + numOtherDigits + numRecursive;<span class="hljs-comment">//返回之和</span>&#125;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">NumberOf1Between1AndN_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>)<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">char</span> str[<span class="hljs-number">100</span>];<span class="hljs-built_in">sprintf</span>(str, <span class="hljs-string">"%d"</span>, n);<span class="hljs-comment">//将数字转化为字符串形式</span><span class="hljs-keyword">return</span> NumberOf1(str);&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络体系结构</title>
    <link href="/2020/06/29/computer-network-architecture/"/>
    <url>/2020/06/29/computer-network-architecture/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>这几天开始二刷希仁老师的著作。。。再一次开始感受网络的魅力。。。→_→</em> *</strong></p><blockquote><p><strong>当一个问题复杂且规模巨大时，可以将其转化为若干较小的局部问题。</strong></p></blockquote><p>网络世界的复杂性难以想象，<strong>不同的物理设备、不同的技术、采取不同的协议</strong>，这些因素都导致当今的网络结构异常复杂，因此对网络的处理办法采取<strong>层次划分</strong>的方法。</p><ol><li><p>层次划分的好处：</p><ul><li><p><strong>各层之间相互独立</strong>：每一层只实现一种相对独立的功能，它也不需要知道它的下一层如何实现，仅仅使用<strong>层间的接口</strong>所提供的服务</p></li><li><p><strong>灵活性好</strong>：当任何一层发生变化时，只要保证层间接口不变，则其余层均不会受到影响</p></li><li><p><strong>结构上可分割开</strong>：各层都可以采用最合适的技术实现</p></li><li><p><strong>易于实现和维护</strong></p></li><li><p><strong>促进标准化工作</strong></p></li></ul></li><li><p>计算机网络结构划分</p><ul><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE2MTQyMjIzNzg4?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="计算机网络体系结构"></p></li><li><p><strong>应用层（Application Layel）</strong>：通过应用进程间的交互来完成特定网络应用。<strong>应用层协议定义的是应用进程间通信和交互的规则。将应用层交互的数据单元称为报文</strong></p></li><li><p><strong>运输层（Transmission Layel）</strong>：<strong>负责向两个主机中进程之间通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文</strong>。其主要使用以下两种协议：</p><ul><li><p><strong>传输控制协议TCP（Transmission Control Protocol），其提供面向连接的、可靠的数据传输服务，其数据传输单位是报文段（Segment）</strong></p></li><li><p><strong>用户数据报协议UDP（User Datagram Protocol），其提供无连接的、尽最大努力交付的（Best-Effort）数据传输服务（不保证数据传输的可靠性），其数据传输的单位是用户数据报</strong></p></li></ul></li><li><p><strong>网络层（Network Layel）：</strong></p><ul><li><p>负责为分组交换网上的不同主机提供服务。<strong>网络层把运输层产生的报文段或用户数据报封装成分组或包（Packet）进行传送，一般称为IP数据报</strong></p></li><li><p><strong>选择合适的路由</strong>，使源主机运输层所传下来的分组能够通过网络中的路由器找到目的主机</p></li></ul></li><li><p><strong>数据链路层（Data Link Layel）</strong>：<strong>在两个节点之间传送数据时，数据链路层·将网络层交下来的IP数据报组装成帧（Frame），在两个相邻节点间的链路上传送帧</strong></p></li></ul></li></ol><ul><li><strong>物理层（Physical Layel）</strong>：在物理层上所传数据的单位时比特</li></ul><ol start="3"><li><p>网络中数据的传递方向</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE2MTU0NDUxMjUy?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="数据传递过程"><br> <strong>数据在协议的操作下，一层层封装，再一层层解封，每一层都认为自己和相同层在直接进行数据传递。层次划分很好的解决了复杂的网络问题。</strong></p></li></ol><p><strong>* <em>这次是对网络体系结构的总体说明，今后会对不同层的协议继续进行详细解释。。。</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（30）连续子数组的最大和</title>
    <link href="/2020/06/29/maximum-sum-of-consecutive-subarrays/"/>
    <url>/2020/06/29/maximum-sum-of-consecutive-subarrays/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">//求连续子段最大和时的过程中可能有两种情况</span><span class="hljs-comment">//1.计算到array[i]时，如果CurrentSum为负数，此时说明：</span><span class="hljs-comment">//(1)若加array[i]，则CurrentSum的值比array[i]还要小，所以应该放弃前面的子段，从array[i]开始重新计算子段和</span><span class="hljs-comment">//(2)否则将array[i]继续纳入此子段，且CurrentSum += array[i]</span><span class="hljs-comment">//2.比较当前子段和CurrentSum与历史最大子段和GreatestSum的大小，对GreatestSum进行更新</span><span class="hljs-comment">//注意判断arrry是否有效</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">int</span> FindGreatestSumOfSubArray(vector&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-built_in">array</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//防御性动作</span><span class="hljs-built_in">int</span> CurrentSum = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前最大子段和</span><span class="hljs-built_in">int</span> GreatestSum = <span class="hljs-number">0x80000000</span>;<span class="hljs-comment">//历史最大子段和，因为GreatestSum有可能为负数，所以其初始化为int类型的最小值</span><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">array</span>.size(); ++i)&#123;<span class="hljs-keyword">if</span> (CurrentSum &lt; <span class="hljs-number">0</span>)如果CurrentSum已经为负数，即从<span class="hljs-built_in">array</span>[i]开始重新计算子段和CurrentSum = <span class="hljs-built_in">array</span>[i];<span class="hljs-keyword">else</span><span class="hljs-comment">//否则将array[i]纳入当前子段</span>CurrentSum += <span class="hljs-built_in">array</span>[i];<span class="hljs-keyword">if</span> (GreatestSum &lt; CurrentSum)<span class="hljs-comment">//更新GreatestSum</span>GreatestSum = CurrentSum;&#125;<span class="hljs-keyword">return</span> GreatestSum;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（29）最小的k个数</title>
    <link href="/2020/06/29/the-smallest-k-number/"/>
    <url>/2020/06/29/the-smallest-k-number/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs arduino"><span class="hljs-comment">//测试用例中给出的返回值是有序的。。啧啧。。</span><span class="hljs-comment">//找到序列中最小的k个数，利用set，对数字进行insert或erase</span><span class="hljs-comment">//红黑树中查找、插入、删除操作都为 O（logk）</span><span class="hljs-comment">//最终将set中存储的值返回值vector中</span><span class="hljs-comment">//方法不改变原vector</span><span class="hljs-comment">//注意：</span><span class="hljs-comment">//1.判断传入的vector是否为空</span><span class="hljs-comment">//2.判断传入的k是否合法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; input, <span class="hljs-keyword">int</span> k)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; output;<span class="hljs-keyword">if</span> (input.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">0</span> || k &lt;= <span class="hljs-number">0</span> || k &gt; input.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> output;<span class="hljs-comment">//防御性动作</span><span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; se;<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; input.<span class="hljs-built_in">size</span>(); ++i)<span class="hljs-comment">//遍历原vector中的所有数</span>&#123;<span class="hljs-keyword">if</span> (i &lt; k)<span class="hljs-comment">//如果set中的个数小于k，则直接插入</span>se.insert(input[i]);<span class="hljs-keyword">else</span><span class="hljs-comment">//否则将set中的最大值和vector中第i个数比较</span>&#123;it = --se.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//取set中的最大值</span><span class="hljs-keyword">if</span> (*it &gt; input[i])<span class="hljs-comment">//若set中的最大值大于vector中第i个数</span>&#123;se.erase(it);<span class="hljs-comment">//删除set中的最大值</span>se.insert(input[i]);<span class="hljs-comment">//插入vector中第i个数</span>&#125;&#125;&#125;it = se.<span class="hljs-built_in">begin</span>();<span class="hljs-keyword">for</span> (; it != se.<span class="hljs-built_in">end</span>(); ++it)<span class="hljs-comment">//将set中的数以vector形式return</span>&#123;output.push_back(*it);&#125;<span class="hljs-keyword">return</span> output;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——进程的堆</title>
    <link href="/2020/06/29/process-heap/"/>
    <url>/2020/06/29/process-heap/</url>
    
    <content type="html"><![CDATA[<p> <strong>* <em>本次只是简要的总结堆的基本情况，具体的函数分析和堆算法分析今后会继续再学习。。。→_→</em> *</strong></p><blockquote><p><strong>程序在任意时刻都可能会发出请求，申请或释放一段内存资源，堆由此而生。</strong></p></blockquote><ol><li><strong>堆(Heap)</strong></li></ol><ul><li><p>堆是一块巨大的内存空间，占据虚拟空间的绝大部分。在这片空间里，<strong>程序可以请求一块连续内存并自由使用，这块内存在程序主动释放之前一直保持有效</strong></p></li><li><p><strong>程序向操作系统申请一块适当大小的堆空间，程序自己管理这块空间。管理堆空间分配的一般是程序的运行库，运行库向操作系统“批发”了一大块堆空间，然后“零售”给程序用。当全部“售完”或程序有已满足不了的更大内存需求时，再向操作系统“进货”</strong></p></li></ul><ol start="2"><li><strong>Linux进程堆管理</strong><br>Linux下的进程堆管理提供了两种堆空间分配方式（系统调用）：</li></ol><ul><li><p><strong><code>int brk(void *end_data_segment);</code></strong></p><pre><code>- **作用为设置进程数据段的结束地址，即扩大或缩小数据段重点内容**。将数据段的结束地址向高地址移动为扩大空间，反之亦然- **sbrk**与之类似，其**以一个增量（Increment）作为参数，表示需要增加或减少的空间大小，返回值为增加或减少后的数据段结束地址，实际上是对brk 系统调用的包装**</code></pre></li><li><p><strong><code>void* mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);</code></strong></p><ul><li><p>作用为<strong>向操作系统申请一段虚拟地址空间</strong>，这块虚拟地址空间也可以映射到文件，当其映射到文件时，称这块空间为<strong>匿名空间（Anonymous Space）</strong>，匿名空间就可以作为堆空间</p></li><li><p>第一、二个参数表示需要<strong>申请的空间的起始地址和长度</strong>，如果<strong>起始地址设置为0，那么Linux系统自动挑选合适的起始地址</strong></p></li><li><p>第三、四个参数表示<strong>申请空间的权限</strong>（可读、可写、可执行）和<strong>映射类型</strong>（文件映射、匿名空间）</p></li><li><p>第五、六个参数表示<strong>当文件映射时指定文件描述符和文件偏移</strong></p></li></ul><p><strong>glibc中的malloc函数</strong>处理请求方式如下</p><ul><li>当请求<strong>小于128KB</strong>时，在<strong>现有堆空间中</strong>，按照<strong>堆分配算法</strong>为其分配一块空间并返回</li><li>当请求<strong>大于128KB</strong>时，使用<strong>mmap()函数为其分配一块匿名空间</strong>，在这个匿名空间中为用户分配空间</li><li><strong>系统虚拟空间申请函数，申请的空间的起始地址和大小必须是系统页大小的整数倍</strong></li><li>影响malloc申请的最大空间大小的因素：<strong>系统资源限制（ulimit）</strong>、<strong>物理内存和交换空间的总和</strong>。因为<strong>mmap申请匿名空间时，系统会为它在内存或交换空间中预留地址，但申请空间的大小不能超过空闲内存和空闲交换空间的总和</strong></li></ul></li></ul><ol start="3"><li><strong>堆分配算法</strong>：管理一大块连续的内存空间，按照需求分配或释放其中的空间</li></ol><ul><li><p><strong>空闲链表（Free List）</strong>：<strong>把堆中各个空闲的块按照链表的方式连接起来，当用户请求一块空间时，遍历整个列表，直到找到合适大小的块并将它拆分；当用户释放空间时将它合并到空闲链表中</strong></p><pre><code>数据结构：在堆里的每一个**空闲空间的开头或结尾有一个头（header）**，头结构中记录了**上一个（prev）和下一个（next）空闲块的地址**，即所有的空闲块形成了一个空闲链表。</code></pre><p>  <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA0MTUwMzA1NjI1?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="空闲链表分配"></p><pre><code>具体分配算法：- **在空闲链表中查找足够容纳请求大小的一个空闲块，将其分成两块，一部分为程序请求的空间，另一部分为剩余的空闲空间**- **将空闲链表进行更新，若剩余的空闲块大小为0，则直接从空闲链表中删除**    ![空闲链表更新](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA0MTUyMzAyOTY1?x-oss-process=image/format,png)- 释放时需要知道资源大小，所以当**分配k个字节资源时，实际分配k+4个字节资源，这4个字节用于存储该分配资源的大小**，因此释放时查看这4个字节的值就能知道该内存块的大小再将其插入到空闲链表中</code></pre></li><li><p><strong>位图（Bitmap）</strong>：<strong>将整个堆划分为许多相同大小的块（block），当用户请求资源时，分配给用户整数个块空间</strong>。第一个块称为已分配区域的<strong>头（head）</strong>，其余的块称为已分配区域的<strong>主体（Body）</strong>。因此每个块只有<strong>头/主体/空闲三种状态，只需要两位二进制位即可表示一个块</strong>。</p><pre><code>数据结构：使用**整数数组记录块的使用情况****使用11表示H（Head），10表示主体（Body），00表示空闲（Free）**对应的位图为：（High）11-00-00-10-10-10-11-00-00-00-00-00-00-00-10-11![位图分配方式](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA0MTY1OTQ0NDI5?x-oss-process=image/format,png)分配算法特点：优点：- **速度快**：整个堆的空闲信息存储在一个数组中，因此访问该数组时cache容易命中- **稳定性好**：即使部分数据被破坏，也不会导致整个堆的无法工作- **块不需要额外信息，易于管理**缺点：- **分配内存时容易产生内存碎片**- 如**果堆很大或设置的块很小，那么位图将会很大，可能失去cache命中率高的优势而且会浪费空间**</code></pre></li><li><p><strong>对象池</strong>：<strong>把整个堆空间划分为大量小块每次请求时只需要找到一个小块</strong> </p><pre><code>- 数据结构：可采用空闲链表、位图等    区别在于，它**假定每次请求的都是一个固定大小，由于每次只请求一个单位的内存，因此请求得到满足的速度很快，无需查找一个足够大的空间**- 具体分配算法：    在现实应用中，堆的分配算法一般是多种算法复合而成的。**在Glibc中，当申请的空间资源小于64字节时，采用类似于对象池的方法；当大于64字节且小于512字节时，采用上述方法中的最佳折中策略；当大于512字节时，采用最佳适配算法；当大于128KB时，直接使用mmap向操作系统申请空间**</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——进程的栈</title>
    <link href="/2020/06/29/process-stack/"/>
    <url>/2020/06/29/process-stack/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>内存是承载程序的介质，是程序进行运算和表达的场所。</strong></p></blockquote><p><strong>未有特殊说明，则默认在32bit操作系统中。</strong></p><h2 id="1-程序的内存布局"><a href="#1-程序的内存布局" class="headerlink" title="1. 程序的内存布局"></a><strong>1. 程序的内存布局</strong></h2><p><strong>操作系统会将内存空间中的一部分分给内核使用，应用程序无法访问这段内存，这段内存被称为内核空间</strong>。Windows默认情况将高地址的2GB空间分配给内核，Linux默认情况将高地址的1GB空间分配给内核。<br>剩下的内存空间称为用户空间，用户空间中有许多默认区域。</p><ul><li><p><strong>栈</strong>：栈用于维护函数调用的上下文。<strong>栈通常在用户空间的最高地址处分配</strong>，一般大小位数兆字节</p></li><li><p><strong>堆</strong>：堆用来容纳应用程序动态分配的内存区域。<strong>堆通常在栈的下方（低地址方向）</strong>。堆一般比栈大可以有几十至数百兆字节的容量</p></li><li><p><strong>可执行文件映像</strong>：存储着可执行文件在内存里的映像。</p></li><li><p><strong>保留区</strong>：保留区不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称</p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAxMTA0MzM0MjM5?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="Linux地址空间布局"></p></li><li><p><strong>栈向低地址增长，堆向高地址增长</strong>。当栈或堆现有的大小不够用时，它们将按照增长方向扩大，直到预留的的空间被用完为止</p></li></ul><h2 id="2-栈（stack）"><a href="#2-栈（stack）" class="headerlink" title="2. 栈（stack）"></a><strong>2. 栈（stack）</strong></h2><ul><li><p><strong>将数据压入栈中（入栈，push），将已经压入栈中的数据弹出（出栈，pop），即先入栈的数据后出栈（First In Last Out，FIFO）</strong></p></li><li><p>压栈操作使栈增大，弹出操作使栈减小</p></li><li><p>栈总是向低地址增长的，栈顶由esp寄存器进行定位，栈底由ebp寄存器进行定位。压栈操作使栈顶地址减小，弹出操作使栈顶地址增大</p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAxMTEwNjE4NTU4?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="程序栈实例"></p></li><li><p><strong>栈保存了一个函数调用所需要的维护信息，其被称为栈帧（Stack Frame）或活动记录（Activate Record）</strong>，栈帧包含如下内容：</p><ul><li><p>函数的<strong>返回地址和参数</strong></p></li><li><p><strong>临时变量</strong>：包括<strong>函数的非静态局部变量</strong>、编译器自动生成的其他临时变量</p></li><li><p><strong>保存的上下文</strong>： 包括在<strong>函数调用前后需要保持不变的寄存器</strong></p></li></ul></li><li><p>一个函数的活动范围由ebp和esp寄存器划定范围。<strong>esp寄存器始终指向栈的顶部即当前函数的活动记录的顶部</strong>，ebp寄存器指向函数活动记录的底部，ebp寄存器也被称为帧指针（Frame Pointer）</p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAxMTExNzExMjgy?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="活动记录"></p></li><li><p>i386下的函数调用步骤如下</p><ul><li><p>把所有或一部分<strong>参数压入栈中</strong>，如果有其他参数没有入栈，那么使用某些特定的寄存器传递</p></li><li><p>把<strong>当前指令的下一条指令的地址压入栈中</strong></p></li><li><p><strong>跳转到函数体执行</strong></p></li><li><p>第二、三步由指令call一起执行</p></li></ul></li><li><p>i386下的函数体“标准”开头如下</p><ul><li><p><strong>push ebp（保存本栈帧的ebp）</strong></p></li><li><p><strong>mov ebp， esp（将ebp移动到栈顶）</strong></p></li><li><p><strong>sub esp， XXX（开辟新的栈帧）</strong></p></li><li><p><strong>push XXX（保存寄存器）</strong></p></li></ul></li><li><p>i386下的函数体“标准”结束如下</p><ul><li><p><strong>pop XXX（恢复寄存器）</strong></p></li><li><p><strong>mov esp， ebp（恢复成调用者所在栈帧的栈顶）</strong></p></li><li><p><strong>pop ebp（恢复成调用者所在栈帧的栈基址）</strong></p></li><li><p><strong>ret（从栈顶取得下一条指令的地址，并跳转）</strong></p></li></ul></li><li><p>示例如下</p><ul><li><p>测试代码<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTExNjQwMjg4?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="测试代码"></p></li><li><p>main函数反汇编<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTExODM5MDc5?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="main反汇编"></p></li><li><p>foo函数反汇编<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTEzMzU2Mjc0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="foo反汇编"></p></li><li><p>foo函数return之前时寄存器<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTEzNzQzMTIw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="foo函数返回之前时寄存器"></p></li><li><p>foo函数return之前时内存<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTE0MTI2NDk3?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="foo函数返回之前时内存"></p></li><li><p>foo函数反汇编代码解析<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTE0NjQxMTI2?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="foo函数反汇编代码解析"></p></li></ul></li><li><p><strong>某些场合，编译器生成函数的进入和退出指令序列不按照标准的方式进行</strong>，比如C函数满足：</p><ul><li><p><strong>函数被声明为static</strong>（不可在此编译单元之外访问）</p></li><li><p><strong>函数在本编译单元仅被直接调用，没有显示或隐式的取地址</strong>（即没有任何函数指针指向过这个函数）</p></li><li><p><strong>编译器确信满足这两条的函数不会在其他编译单元内被调用，因此可以修改指令，达到优化目的</strong></p></li></ul></li><li><p><strong>函数调用惯例（Calling Convention）</strong></p><ul><li><p><strong>函数参数的传递顺序和方式</strong>：规定函数调用方将参数压入栈的顺序（从左到右、从右至左）；规定函数参数的传递方式（通过栈传递，函数调用方将参数压入栈，自己在从栈中将参数取出、使用寄存器传递，提高性能）</p></li><li><p><strong>栈的维护</strong>：函数体执行完后，之前压入栈中的参数需要弹出，可以由函数调用方完成，也可以由函数体本身完成</p></li><li><p><strong>名字修饰（Name-mangling）策略</strong>：链接时区分调用惯例，不同的调用惯例有不同的名字修饰策略</p></li><li><p><strong>C语言默认调用惯例是cdecl</strong>，任何一个没有显式指定调用惯例的函数都默认是cdecl，比如：<code>int _cdecl foo(int a, int b, int c)</code></p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTIwODE1OTgy?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="函数调用惯例"></p></li></ul></li><li><p>函数返回值传递</p><ul><li>当返回值小于等于4字节时，函数将返回值存储在eax，调用者读取eax</li><li>当返回值大于4字节，小于等于8字节时，函数使用eax和edx联合返回的方式。eax存储低4字节，edx高4字节</li><li>当返回值大于8字节时，函数会使用一个临时的栈上内存空间（临时对象）作为中转，返回值对象会被拷贝两次</li><li>当返回值大于8字节时，函数返回值传递示例如下：<ul><li>函数返回值传递测试代码<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTMwNzIzMDcx?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="函数返回值传递测试代码"></li><li>main函数返回值反汇代码<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTMxMzIyMTgw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="main返回值反汇编"></li><li>return_test函数反汇编代码<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTMxNTE1NjY3?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="return_test反汇编"></li><li>main函数中n的地址<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTMyMzU3MjI1?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="main中n的地址"></li><li>临时对象给main函数中的n赋值<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTMyNDQzNzEx?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="临时对象给n赋值"></li></ul></li><li>首先调用者在栈上将一部分空间作为传递返回值的临时对象</li><li>将临时对象的地址作为隐藏参数传递给函数</li><li>函数将数据拷贝给临时对象，并将临时对象的地址用eax传出</li><li>函数返回后，调用者将eax指向临时对象的内容拷贝给局部变量</li><li>返回值传递流程<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTMzMTI1ODYx?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="返回值传递流程"></li><li>需要注意的是返回对象的拷贝情况完全不具备可移植性，不同的编译器产生的结果可能不同。函数传递大尺寸的返回值所使用的方法不是可移植的，不同编译器、不同平台、不同调用惯例、不同编译参数可能采用不同的实现方法</li><li>在C++中要使用返回值优化技术（Return Value Optimization， RVO），直接将对象构造在临时对象上，减少一次从函数内局部变量对临时对象的拷贝构造步骤<pre><code class="hljs aspectj">cpp_obj return_test()&#123;<span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">cpp_obj</span><span class="hljs-params">()</span></span>;&#125;</code></pre></li></ul></li></ul><p><strong>* <em>码字好累。。。→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——静态链接</title>
    <link href="/2020/06/29/static-link/"/>
    <url>/2020/06/29/static-link/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>赶紧结束这本书的总结。。太拖了。。→_→</em> *</strong></p><h1 id="第四章-静态链接"><a href="#第四章-静态链接" class="headerlink" title="第四章 静态链接"></a><strong>第四章 静态链接</strong></h1><h2 id="1-链接器的空间与地址分配"><a href="#1-链接器的空间与地址分配" class="headerlink" title="1.链接器的空间与地址分配"></a><strong>1.链接器的空间与地址分配</strong></h2><blockquote><p><strong>链接器为目标文件分配地址和空间</strong><br><strong>可执行文件中的代码段和数据段由输入的目标文件中合并而来。</strong></p></blockquote><ul><li><p><strong>按序叠加：直接将各个目标文件依次合并</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTMwMjAzODU2MTY2?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="简单的分配策略"><br>缺点：若有多个目标文件，则可能造成输出文件中有很多<strong>零散的段</strong>。每个段都有空间对齐要求，可能<strong>造成内存空间的大量内部碎片</strong>。</p></li><li><p><strong>相似段合并：将相同性质的段合并到一起</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTMwMjA0NjE2MDI2?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="实际的内存分配"></p></li></ul><ul><li><p>“.bss”段在目标文件和可执行文件中并不占用文件的空间（此空间指实际的<strong>物理数据空间</strong>），但其在装载时占用地址空间（此空间指<strong>虚拟地址空间</strong>）。</p></li><li><p>使用此策略的链接器一般都是<strong>两步链接（Two-pass Linking）</strong><br>第一步：<strong>空间地址分配</strong>。扫描所有的输入目标文件，获取各段长度、属性和位置，将它们合并，计算出输出文件中各段合并后的长度和位置，并<strong>建立映射关系</strong>（此时为合并之后的各段分配虚拟地址）。<strong>将符号表中的符号定义和符号引用收集，统一放到一个全局符号表</strong>。<br>第二步：<strong>符号解析与重定位</strong>。读取输入文件中段的数据、重定位信息，<strong>进行符号的解析与重定位、调整代码中的地址</strong>。</p></li></ul><h2 id="2-链接器的符号解析与重定位"><a href="#2-链接器的符号解析与重定位" class="headerlink" title="2.链接器的符号解析与重定位"></a><strong>2.链接器的符号解析与重定位</strong></h2><ul><li><p><strong>重定位</strong>：<strong>目标文件在链接的空间分配之前，代码段中的起始地址为0x00000000。</strong>编译器在<strong>编译阶段</strong>使用<strong>临时的假地址表示未知符号的地址</strong>，而将真正的地址计算工作留给链接器。链接器完成空间与地址分配后，<strong>根据符号的虚拟地址对每个需要重定位的指令进行修正</strong>。</p></li><li><p><strong>重定位表（Relocation Table）</strong>：保存与重定位相关的信息，用来描述如何修改相应的指令。<strong>每个要被重定位的ELF段都有一个对应的重定位表（或叫重定位段）</strong>。比如：“.rel.text”、“.rel.data”。</p></li><li><pre><code>//重定位表结构typedef struct{      //被重定位的地方叫**重定位入口（Relocation Entry）**      //表示重定位入口的**偏移**      //对于可重定位文件，即**所要修正的位置的第一个字节相对段起始的偏移**      //对于可执行文件或共享对象文件，即**所要修正的位置的第一个字节的虚拟地址**      Elf32_Addr r_offset;      //**重定位入口的类型和符号**，低8位表示重定位入口的类型，高24位表示重定位入口的符号在符号表中的下标       Elf32_Word r_info;}Elf32_Rel;</code></pre></li><li><p><strong>符号解析</strong>：重定位的过程中，<strong>每个重定位的入口都是一个符号的引用</strong>，当链接器对某个符号的引用进行重定位时，链接器会去<strong>查找由所有输入目标问价的符号表组成的全局符号表</strong>，找到相应的符号后进行重定位。</p></li></ul><h2 id="3-C-与静态链接的问题"><a href="#3-C-与静态链接的问题" class="headerlink" title="3.C++与静态链接的问题"></a><strong>3.C++与静态链接的问题</strong></h2><ul><li><p><strong>C++编译器可能在不同的编译单元中生成相同的代码</strong>（模板（Templates）、外部内联函数（Extern Function）、虚函数表（Virtual Function Table））。<br>若不消除重复代码，可能造成<strong>空间浪费、地址出错（两个函数指针不相等）、指令运行效率低（CPU对指令和数据进行缓存，副本过多造成指令Cache命中率低）</strong></p></li><li><p>解决方法：<strong>将每个模板的实例代码都单独存放在一个段里，每个段只包含一个模板实例</strong>。这样链接器在最终链接时可以区分相同的模板实例段，将它们合并入代码段。</p></li><li><p>GCC中叫做“<strong>Link Once</strong>”，将此类段命名为“.gun.linkonce.name”，“<strong>name”是该模板函数实例的修饰后名称</strong></p></li><li><p>当用到某个目标文件中的一个函数或变量时，需要将其整个链接，随着文件数量地增多，造成输出文件越来越大。<br>Visual C++中使用<strong>函数级别链接（Function-Level Linking）</strong>选项，其作用就是让<strong>所有的函数都单独保存到一个中，当链接器用到它时，就将其合并到输出文件中，抛弃没有用到的函数</strong>。<br>这种方减少了输出文件地大小，减少了空间浪费。但会减慢编译和链接过程，因为链接器要计算个函数之间的依赖关系，且目标函数段数量增大，重定位过程也会变得复杂。</p></li></ul><h2 id="4-静态库链接"><a href="#4-静态库链接" class="headerlink" title="4.静态库链接"></a><strong>4.静态库链接</strong></h2><ul><li><strong>静态库是一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件</strong></li><li><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTMxMTE1NzQ1OTE3?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="静态库链接"></li><li>链接器自动寻找所有需要的符号及其所在的目标文件从静态库中“解压”出来</li><li><strong>静态库中的一个目标文件只包含一个函数</strong>，每个函数独立的存放在一个目标文件中可以尽量减少空间浪费</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（28）数组中出现次数超过一半的数字</title>
    <link href="/2020/06/29/more-than-half-of-the-occurrences-in-the-array/"/>
    <url>/2020/06/29/more-than-half-of-the-occurrences-in-the-array/</url>
    
    <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p><strong>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</strong></p></blockquote><p>实现如下：</p><pre><code class="hljs swift"><span class="hljs-comment">//方法一</span><span class="hljs-comment">//原理：数组中出现次数超过一半的数字，在其有序序列中就是中位数</span><span class="hljs-comment">//利用partition的作用：将某个数字，放到它应该在的位置，而将其他数分类摆放，比它小的放它前面，比它大的放它后面</span><span class="hljs-comment">//注意：</span><span class="hljs-comment">//1.测试用例中可能存在重复的数，所以必须在判断条件的上注意稳定性</span><span class="hljs-comment">//2.防御性动作</span><span class="hljs-comment">//3.测试用例中有可能不存在满足条件的数，即出现次数最多的数都没有超过一半</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">public</span>:int <span class="hljs-built_in">partition</span>(vector&lt;int&gt;arr, int <span class="hljs-keyword">left</span>, int <span class="hljs-keyword">right</span>)&#123;int tmp = arr[<span class="hljs-keyword">left</span>];<span class="hljs-keyword">while</span> (<span class="hljs-keyword">left</span> &lt; <span class="hljs-keyword">right</span>)<span class="hljs-comment">//直到left和right重合，此时合适位置找到</span>&#123;<span class="hljs-keyword">while</span> (arr[<span class="hljs-keyword">right</span>] &gt;= tmp &amp;&amp; <span class="hljs-keyword">left</span> &lt; <span class="hljs-keyword">right</span>)<span class="hljs-comment">//等于号考虑稳定性</span>&#123;<span class="hljs-keyword">right</span>--;&#125;arr[<span class="hljs-keyword">left</span>] = arr[<span class="hljs-keyword">right</span>];<span class="hljs-keyword">while</span> (arr[<span class="hljs-keyword">left</span>] &lt;= tmp &amp;&amp; <span class="hljs-keyword">left</span> &lt; <span class="hljs-keyword">right</span>)<span class="hljs-comment">//等于号考虑稳定性</span>&#123;<span class="hljs-keyword">left</span>++;&#125;arr[<span class="hljs-keyword">right</span>] = arr[<span class="hljs-keyword">left</span>];&#125;arr[<span class="hljs-keyword">left</span>] = tmp;<span class="hljs-comment">//将tmp放在它应该在的位置</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">left</span>;&#125;bool checkNumber(vector&lt;int&gt; numbers, int number)<span class="hljs-comment">//检查结果是否满足条件</span>&#123;int time = <span class="hljs-number">0</span>;<span class="hljs-comment">//计数器</span><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; numbers.size(); ++i)&#123;<span class="hljs-keyword">if</span> (numbers[i] == number)++time;&#125;<span class="hljs-keyword">if</span> (time*<span class="hljs-number">2</span> &lt;= numbers.size())<span class="hljs-comment">//判断出现的次数是否超过一半</span><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;int <span class="hljs-type">MoreThanHalfNum_Solution</span>(vector&lt;int&gt; numbers)&#123;<span class="hljs-keyword">if</span> (numbers.empty())<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;int middle = numbers.size() / <span class="hljs-number">2</span>;int <span class="hljs-keyword">left</span> = <span class="hljs-number">0</span>;int <span class="hljs-keyword">right</span> = numbers.size() - <span class="hljs-number">1</span>;int pa = <span class="hljs-built_in">partition</span>(numbers, <span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span>);<span class="hljs-comment">//先进行一次partition</span><span class="hljs-keyword">while</span> (middle != pa)<span class="hljs-comment">//判断是否为中位数</span>&#123;<span class="hljs-keyword">if</span> (pa &lt; middle)<span class="hljs-comment">//如果位置小于中位数，则对pa的右边partition</span>&#123;<span class="hljs-keyword">left</span> = pa + <span class="hljs-number">1</span>;pa = <span class="hljs-built_in">partition</span>(numbers, <span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pa &gt; middle)<span class="hljs-comment">//如果位置大于中位数，则对pa的左边partition</span>&#123;<span class="hljs-keyword">right</span> = pa - <span class="hljs-number">1</span>;pa = <span class="hljs-built_in">partition</span>(numbers, <span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span>);&#125;&#125;<span class="hljs-keyword">if</span> (checkNumber(numbers, numbers[middle]))<span class="hljs-comment">//判断结果是否满足条件</span><span class="hljs-keyword">return</span> numbers[middle];<span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;&#125;;</code></pre><pre><code class="hljs angelscript"><span class="hljs-comment">//方法二</span><span class="hljs-comment">//方法二可以不用改变vector</span><span class="hljs-comment">//数组中出现次数超过一半的数字，其出现的次数一定比其他数出现次数总和还要多</span><span class="hljs-comment">//设置一个计数器time，等于res，++time；不等于res，若time==0，则替换res,计数器置1，否则--time</span><span class="hljs-comment">//注意：</span><span class="hljs-comment">//1.防御性动作</span><span class="hljs-comment">//2.判断结果是否满足条件</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">bool</span> checkNumber(vector&lt;<span class="hljs-built_in">int</span>&gt; numbers, <span class="hljs-built_in">int</span> number)<span class="hljs-comment">//判断结果是否满足条件</span>&#123;<span class="hljs-built_in">int</span> time = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.size(); ++i)&#123;<span class="hljs-keyword">if</span> (numbers[i] == number)++time;&#125;<span class="hljs-keyword">if</span> (time * <span class="hljs-number">2</span> &lt;= numbers.size())<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-built_in">int</span> MoreThanHalfNum_Solution(vector&lt;<span class="hljs-built_in">int</span>&gt; numbers) &#123;<span class="hljs-keyword">if</span> (numbers.empty())<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> time = <span class="hljs-number">0</span>;<span class="hljs-comment">//计数器初始化为0</span><span class="hljs-built_in">int</span> res = numbers[<span class="hljs-number">0</span>];<span class="hljs-comment">//记录结果</span><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.size(); ++i)&#123;<span class="hljs-keyword">if</span> (res == numbers[i])<span class="hljs-comment">//若与结果相同，计数器自加</span>++time;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (time == <span class="hljs-number">0</span>)<span class="hljs-comment">//此时res进行替换，将新res的time置为1</span>&#123;res = numbers[i];++time;&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//否则，计数自减</span>--time;&#125;&#125;<span class="hljs-keyword">if</span> (checkNumber(numbers, res))<span class="hljs-comment">//判断结果是否满足条件</span><span class="hljs-keyword">return</span> res;<span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——符号、引用、COMMON块</title>
    <link href="/2020/06/29/symbols-references-COMMON-blocks/"/>
    <url>/2020/06/29/symbols-references-COMMON-blocks/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>好久都没更这个了。。。请叫我拖更大魔王。。。→_→</em> *</strong></p><p><strong>* <em>这一篇看下来，对符号的理解更深了。。。</em> *</strong></p><blockquote><p><strong>在链接过程中，目标文件之间相互拼合实际上是目标文件之间对函数和变量的地址的引用。</strong></p><p><strong>在链接中，将函数和变量称为符号（Symbol），函数名和变量名为符号名（Symbol Name）。</strong> </p></blockquote><ol><li><p><strong>符号表（Symbol Table）</strong><br>每一个目标文件都有一个<strong>符号表（Symbol Table）</strong>，表中<strong>记录目标文件中所用到的所有符号</strong>。每个定义的符号有一个对应的<strong>符号值（Symbol Value）</strong>，对函数和变量来说，<strong>符号值就是其地址</strong>。<br>符号表中的所有符号分类：</p><ul><li><p>定义在<strong>本目标文件的全局变量，可以被其他目标文件引用</strong></p></li><li><p>在<strong>本目标文件中引用的全局符号，没有定义在本目标文件，称为外部符号（External Symbol）</strong></p></li><li><p>段名，由编译器产生，其值为该段的起始地址</p></li><li><p>局部符号，其只在编译单元内部可见</p></li><li><p>行号信息，可选</p></li></ul></li><li><p><strong>ELF符号表结构</strong><br>ELf文件的<strong>符号表是文件中的”.symtab“段</strong>。其结构是一个<strong>Elf32_Sym结构的数组，每一个元素对应一个符号。这个数组下标为0的元素为无效的“未定义”符号。</strong></p> <pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>Elf32_Word st_name;<span class="hljs-comment">//符号名。即该符号名在字符串表中的下标。</span>Elf32_Addr st_value;<span class="hljs-comment">//符号相对应的值。不同符号对应的值不一样。</span>Elf32_Word st_size;<span class="hljs-comment">//符号大小。包含数据的符号，该值为该数据类型大小。若该值为0，表示该符号大小为0或未知。</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> st_info;<span class="hljs-comment">//符号类型和绑定信息。低4位表示符号类型（Symbol Type），高28位表示符号绑定信息（Symbol Binding）。</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> st_other;<span class="hljs-comment">//目前为0，没用</span><span class="hljs-comment">//符号所在的段。如果符号定义在本目标文件中，其表示符号所在段在段表中的下标。若为0，表示在本目标文件中被引用，定义在其他目标文件中。</span>Elf32_Half at_shndx;&#125;Elf32_Sym;</code></pre></li></ol><p><strong>符号值（st_value）</strong>分类：</p><ul><li>在目标文件中，如果符号定义<strong>不是“COMMON块”</strong>类型，则符号值表示<strong>该符号在段中的偏移</strong>。</li><li>在目标文件中，如果符号<strong>是“COMMON块”类型</strong>，则符号值表示<strong>该符号的对其属性</strong>。</li><li><strong>在可执行文件中，符号值表示符号的虚拟地址</strong>。</li></ul><ol start="3"><li><strong>符号修饰与函数签名</strong></li></ol><p><strong>UNIX下的C语言规定，C语言代码源文件中的所有全局变量和函数经过编译后，相对应的符号名前加上下划线</strong>。<br>eg.Windows下的Visual C++编译器，C语言函数“foo”，编译后的符号名是“_foo”。<strong>Linux下的GCC编译器默认情况已经去掉了此方式</strong>。<br><strong>C++中增加了名称空间（Namespace）解决多模块的符号冲突问题</strong>。</p><ul><li><p><strong>符号修饰（Name Decoration）</strong> /<strong>符号改编（Name Mangling）</strong><br>C++中允许多个<strong>不同的参数类型</strong>的函数拥有<strong>相同的名字</strong>，即<strong>函数重载</strong>。<br>C++在语言级别支持<strong>名称空间</strong>，即允许在<strong>不同的名称空间</strong>中有多个<strong>同样名字的符号</strong>。</p></li><li><p><strong>函数签名（Function Signature）</strong><br>其包含了一个函数的信息，包括<strong>函数名、参数类型、所在的类和名称空间</strong>及其他信息。</p></li></ul><p><strong>函数签名用于识别不同的函数</strong>，函数的名字是函数签名的一部分。<br>在编译器及链接器处理符号时，它们使用某种<strong>名称修饰</strong>方法，使的每个函数签名对应一个<strong>修饰后名称（Decorated Name）</strong>。即<strong>目标文件中的符号名是函数和变量的修饰后名称</strong>。</p><ul><li>名称修饰机制也用在C++中的<strong>全局变量和静态变量</strong>。<strong>变量的类型并没有被加入到修饰后名称中</strong>。</li></ul><ol start="4"><li><p><strong>extern “C”</strong><br>C++为了与C兼容，在符号管理上，有一个用来声明或定义一个C的符号的“<strong>extern “C”</strong>”关键字。</p> <pre><code class="hljs cpp"><span class="hljs-comment">//大括号内部的代码当作C语言代码处理，C++的名称修饰机制将不起作用</span><span class="hljs-keyword">extern</span> “C”&#123;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-keyword">int</span> var;&#125;<span class="hljs-comment">//单独声明某个函数或变量为C语言的符号</span><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-keyword">int</span> var;<span class="hljs-comment">//C语言函数库中的string.h中的memset()如何在.c或.cpp中正确使用</span><span class="hljs-comment">//C++中必须使用extern "C"</span><span class="hljs-comment">//但C中不支持extern "C"语法</span><span class="hljs-comment">//因此利用C++中的宏”__cplusplus“，C++编译器在编译时默认定义这个宏</span><span class="hljs-comment">//使用条件宏自动判断选择哪种环境</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span>&#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">size_t</span>)</span></span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span>&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre></li><li><p><strong>强符号与弱符号</strong><br>多个目标文件中含有相同名字全局符号的定义，那么这些目标文件链接时将会出现<strong>符号重复定义</strong>错误。</p></li></ol><ul><li><p>C/C++语言中，编译器默认<strong>函数和初始化了的全局变量为强符号（Strong Symbol）</strong>，<strong>未初始化的全局变量为弱符号（Weak Symbol）</strong>。</p></li><li><p>通过GCC的”<strong>_ attribute _ ((weak))</strong>“<strong>定义任何一个强符号为弱符号</strong>。</p></li><li><p><strong>强符号和弱符号针对定义，不是针对符号的引用。</strong></p><p>链接器按照如下规则处理与选择被多次定义的全局符号</p><ul><li><p>不允许强符号被多次定义（<strong>不同目标文件中不能有同名的强符号</strong>）。</p></li><li><p>如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么<strong>选择强符号</strong>。</p></li><li><p>如果一个符号在所有目标文件中都是弱符号，那么<strong>选择其中占用内存空间最大的一个</strong>。</p></li></ul></li></ul><ol start="6"><li><strong>强引用和若引用</strong></li></ol><ul><li><p>链接时，如果<strong>没有找到引用符号的定义</strong>，链接器报符号<strong>未定义错误</strong>，这种被称为<strong>强引用（Strong Reference）</strong>。</p></li><li><p>如果<strong>声明为弱引用（Weak Reference）</strong>，若引用的符号<strong>有定义</strong>，则链接器将<strong>该符号引用决议</strong>；若引用的符号<strong>未定义</strong>，链接器<strong>不报错</strong>，<strong>默认其为0或是一个特殊值</strong>。</p></li><li><p>在GCC中，使用”<strong>_ attribute _ ((weakref))”</strong>声明一个外部函数的引用为弱引用。</p>  <pre><code class="hljs cpp"><span class="hljs-comment">//GCC在链接时不会报错，但在运行可执行文件时，发生运行错误</span><span class="hljs-comment">//因为当要调用foo()时，其地址为0，发生非法地址访问的错误</span>__attribute__ ((weakref)) <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;foo();<span class="hljs-comment">//改成if(foo) foo();</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul><ol start="7"><li><strong>COMMON块</strong><br>弱符号机制允许同一个符号的定义存在于多个文件中。<strong>链接器本身不支持符号类型，只知道符号的名字</strong>。但当<strong>一个弱符号以不同的类型定义在多个目标文件中</strong>时，链接器如何区分？<br>多个符号有多个类型定义时：</li></ol><ul><li><p><strong>两个或两个以上强符号</strong>类型不一致。（<strong>非法。符号重定义</strong>）。</p></li><li><p>有<strong>一个强符号</strong>，<strong>其他都是弱符号</strong>，出现类型不一致。</p></li><li><p><strong>两个或两个以上弱符号</strong>类型不一致。</p><p>现在的编译器和链接器支持<strong>COMMON块（Common Block）机制</strong>。<strong>COMMON类型的链接规则是针对符号都是弱符号的情况</strong>。如果其中有<strong>一个强符号，最终符号所占空间欲强符号相同</strong>。如果<strong>有弱符号大小大于强符号，链接器报警告</strong>。</p><p>问题：为什么编译器<strong>把未初始化的全局变量标记为一个COMMON类型的变量</strong>，而<strong>不</strong>直接把它当作<strong>未初始化的局部静态变量，为其在BSS段分配空间。</strong></p><p>答：</p><ol><li><p><strong>编译时</strong>，若目标文件中含有弱符号（比如未定义的全局变量），则<strong>该弱符号最终所占内存空间大小无法确定</strong>，因为有<strong>可能其他目标文件中该弱符号所占内存空间比本单元弱符号所占内存空间大</strong>，所以此时无法在.BSS段为该弱符号分配空间。</p></li><li><p><strong>链接时</strong>，读取了所有目标文件，<strong>确定了任意一个弱符号的大小</strong>。这时<strong>才在最终输出文件的.BSS段中为其分配空间</strong>。</p></li><li><p>总体看来，<strong>未初始化的全局变量最终还是被放在.BSS段。</strong></p></li></ol><p>在GCC中使用”<strong>-fno-commom</strong>“或”<strong>_ <em>attribute</em> _((nocommom))</strong>“，使未初始化的全局变量不以COMMOM块的形式处理。即相当于一个<strong>强符号</strong>。</p></li></ul><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> global <span class="hljs-constructor">__attribute__((<span class="hljs-params">nocommom</span>)</span>)；</code></pre><p><strong>* <em>码字好累。。。下次再见喽。。。</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（27）字符串的排列</title>
    <link href="/2020/06/29/arrangement-of-strings/"/>
    <url>/2020/06/29/arrangement-of-strings/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</strong>                                                                                                                                                                                                     </p></blockquote><p><strong>输入描述：</strong></p><blockquote><p><strong>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</strong></p></blockquote><p><strong>其实之前已经写过全排列问题了。。。请戳传送门<a href="http://blog.csdn.net/kongkongkkk/article/details/71629690" target="_blank" rel="noopener" title="optional title">全排列问题算法分析与实现（递归、非递归）</a>。这次仅仅是更改了接口，算法思想不变。</strong></p><p><strong>实现如下：</strong></p><pre><code class="hljs arduino"><span class="hljs-comment">//使用STL中的next_permutation，判断是否存在下一个字典序列</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class">&#123;</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; strVec;<span class="hljs-comment">//存储排列情况</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">Permutation</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> strVec;<span class="hljs-comment">//防御性动作</span>        sort(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//先将字符串有序化</span><span class="hljs-keyword">do</span>&#123;strVec.push_back(str);<span class="hljs-comment">//第一种情况直接添加</span>&#125; <span class="hljs-keyword">while</span> (next_permutation(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>()));<span class="hljs-comment">//判断是否存在下个字典系列</span><span class="hljs-keyword">return</span> strVec;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（26）二叉搜索树与双向链表</title>
    <link href="/2020/06/29/binary-search-tree-and-doubly-linked-list/"/>
    <url>/2020/06/29/binary-search-tree-and-doubly-linked-list/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs php"><span class="hljs-comment">//二叉搜索树的结构特点：根的左子树的节点值都小于根节点值，右子树的节点值都大于根节点值</span><span class="hljs-comment">//构建一个有序的双向链表可以利用left作为前驱、right作为后继</span><span class="hljs-comment">//       5</span><span class="hljs-comment">//   4      7</span><span class="hljs-comment">// 2   3  6    8</span><span class="hljs-comment">//2⇿3⇿4⇿5⇿6⇿7⇿8⇿</span><span class="hljs-comment">//root-&gt;left链接到已构建双向链表的最后一个节点</span><span class="hljs-comment">//root-&gt;right链接到右子树的最小值节点</span><span class="hljs-comment">//递归方式处理每一个root</span><span class="hljs-comment">//注意：</span><span class="hljs-comment">//1.因为最后要返回构建的双向链表的head，所以一开始就找到最小值节点。O(logn)</span><span class="hljs-comment">//2.在线测试用例为无头链表</span><span class="hljs-comment">//3.仔细思考指针赋值变化</span><span class="hljs-comment">/*节点结构体定义</span><span class="hljs-comment">struct TreeNode</span><span class="hljs-comment">&#123;</span><span class="hljs-comment">int val;</span><span class="hljs-comment">struct TreeNode *left;</span><span class="hljs-comment">struct TreeNode *right;</span><span class="hljs-comment">TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class"></span>&#123;TreeNode *lastNode = <span class="hljs-keyword">NULL</span>;<span class="hljs-comment">//记录构建的双向链表的最后一个节点</span>TreeNode *linkListHead = <span class="hljs-keyword">NULL</span>;<span class="hljs-comment">//记录所构建的双向链表的head</span><span class="hljs-keyword">public</span>:void findMinNode(TreeNode* pRootOfTree)<span class="hljs-comment">//寻找双向链表的head</span>&#123;<span class="hljs-keyword">if</span> (pRootOfTree == <span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">while</span> (pRootOfTree != <span class="hljs-keyword">NULL</span>)&#123;linkListHead = pRootOfTree;pRootOfTree = pRootOfTree-&gt;left;&#125;&#125;void BSTToOrderTwoWayLinkList(TreeNode* pRootOfTree)&#123;<span class="hljs-keyword">if</span> (pRootOfTree-&gt;left != <span class="hljs-keyword">NULL</span>)<span class="hljs-comment">//如果左子树不为空，则继续递归</span>BSTToOrderTwoWayLinkList(pRootOfTree-&gt;left);pRootOfTree-&gt;left = lastNode;<span class="hljs-comment">//将root-&gt;left链接到链表的最后一个节点</span><span class="hljs-keyword">if</span> (lastNode != <span class="hljs-keyword">NULL</span>)<span class="hljs-comment">//如果前驱不为空，则将前驱的right链接到root</span>lastNode-&gt;right = pRootOfTree;lastNode = pRootOfTree;<span class="hljs-comment">//root变为链表的最后一个节点</span><span class="hljs-keyword">if</span> (pRootOfTree-&gt;right != <span class="hljs-keyword">NULL</span>)<span class="hljs-comment">//如果右子树不为空，则继续递归</span>BSTToOrderTwoWayLinkList(pRootOfTree-&gt;right);&#125;TreeNode* Convert(TreeNode* pRootOfTree)&#123;<span class="hljs-keyword">if</span> (pRootOfTree == <span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span> linkListHead;<span class="hljs-comment">//防御性动作</span>findMinNode(pRootOfTree);<span class="hljs-comment">//寻找双向链表head</span>BSTToOrderTwoWayLinkList(pRootOfTree);<span class="hljs-comment">//开始递归调用</span><span class="hljs-keyword">return</span> linkListHead;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（25）复杂链表的复制</title>
    <link href="/2020/06/29/complex-linked-list-replication/"/>
    <url>/2020/06/29/complex-linked-list-replication/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs xl"><span class="hljs-comment">//老样子，在线测试用例依旧是无头链表。。。→_→</span><span class="hljs-comment">//本题可以利用辅助内存以空间换取时间</span><span class="hljs-comment">//第一次遍历：在原链表的每一个节点之后添加一个与它值相同的新节点，此时完成next指针域的构建</span><span class="hljs-comment">//第二次遍历：每一个newNode的随机指针域为它前一个节点的随机指针域的next，此时完成随机指针域的构建</span><span class="hljs-comment">//第三次遍历：将链表拆分成两个独立链表，一个为原链表，一个为复制链表</span><span class="hljs-comment">//注意：</span><span class="hljs-comment">//1.特殊情况判断：链表为空</span><span class="hljs-comment">//2.仔细思考指针的操作！</span><span class="hljs-comment">//3.在线测试用例必须保证原链表完整！在这被坑了好久。。。</span><span class="hljs-comment">//4.这道题的在线测试，就不用释放内存了。。。</span><span class="hljs-comment">/*</span><span class="hljs-comment">struct RandomListNode </span><span class="hljs-comment">&#123;</span><span class="hljs-comment">int label;//值域</span><span class="hljs-comment">struct RandomListNode *next, *random;//next指针域和随机指针域</span><span class="hljs-comment">RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span>class Solution &#123;public:RandomListNode *cloneHead = NULL;<span class="hljs-comment">//保存复制链表head</span>RandomListNode* createNode(int label)<span class="hljs-comment">//创建新节点</span>&#123;RandomListNode *p = (RandomListNode*)malloc(sizeof(RandomListNode));assert(p != NULL);memset(p, <span class="hljs-number">0</span>, sizeof(RandomListNode));<span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>label = label;return p;&#125;void freeNode(RandomListNode *p)<span class="hljs-comment">//虽然用不到但还写出来</span>&#123;free(p);&#125;void cloneLinkList(RandomListNode* pHead)<span class="hljs-comment">//第一次遍历：构建next</span>&#123;RandomListNode *newNode = NULL;<span class="hljs-keyword">while</span> (pHead != NULL)&#123;<span class="hljs-function"><span class="hljs-title">newNode</span> = createNode(pHead-&gt;</span>label);<span class="hljs-function"><span class="hljs-title">newNode</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span> = pHead-&gt;</span>next;<span class="hljs-function"><span class="hljs-title">pHead</span>-&gt;</span>next = newNode;<span class="hljs-function"><span class="hljs-title">pHead</span> = newNode-&gt;</span>next;&#125;&#125;void perfectLinkList(RandomListNode *pHead)<span class="hljs-comment">//第二次遍历：构建随机指针域</span>&#123;<span class="hljs-keyword">while</span> (pHead != NULL)&#123;<span class="hljs-function"><span class="hljs-title">if</span> (pHead-&gt;</span>random != NULL)<span class="hljs-comment">//有可能这个节点的随机指针域为NULL</span><span class="hljs-function"><span class="hljs-title">pHead</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">random</span> = pHead-&gt;</span><span class="hljs-function"><span class="hljs-title">random</span>-&gt;</span>next;<span class="hljs-comment">//新节点的随机指针域为其前一个节点的随机指针域的next</span><span class="hljs-function"><span class="hljs-title">pHead</span> = pHead-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>next;&#125;&#125;void divisionLinkList(RandomListNode* pHead)<span class="hljs-comment">//第三次遍历：拆分链表为两个自链表</span>&#123;RandomListNode *tmp = pHead;<span class="hljs-function"><span class="hljs-title">cloneHead</span> = pHead-&gt;</span>next;<span class="hljs-comment">//记录复制链表head</span><span class="hljs-function"><span class="hljs-title">pHead</span> = cloneHead-&gt;</span>next;<span class="hljs-keyword">while</span> (pHead != NULL)&#123;<span class="hljs-function"><span class="hljs-title">tmp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span> = pHead-&gt;</span>next;<span class="hljs-function"><span class="hljs-title">tmp</span>-&gt;</span>next = pHead;tmp = pHead;<span class="hljs-function"><span class="hljs-title">pHead</span> = pHead-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>next;&#125;<span class="hljs-function"><span class="hljs-title">tmp</span>-&gt;</span>next = NULL;<span class="hljs-comment">//最后要将原链表的最后一个节点的next置为NULL</span>&#125;RandomListNode* Clone(RandomListNode* pHead)&#123;<span class="hljs-keyword">if</span> (pHead == NULL) return cloneHead;<span class="hljs-comment">//防御性动作</span>cloneLinkList(pHead);perfectLinkList(pHead);divisionLinkList(pHead);return cloneHead;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（24）二叉树中和为某一值的路径</title>
    <link href="/2020/06/29/binary-tree-path-with-a-certain-value/"/>
    <url>/2020/06/29/binary-tree-path-with-a-certain-value/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs cpp"><span class="hljs-comment">//路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径</span><span class="hljs-comment">//所以必须是root到叶节点的和</span><span class="hljs-comment">//模拟一个栈，但在线用例要求将路径以vector的形式存储，所以只能使用vetor的push_back和pop模拟</span><span class="hljs-comment">//注意：</span><span class="hljs-comment">//1.父节点将自己的子节点递归调用判断完毕后，此时返回到自己的函数栈帧时。最后需要将自己也pop</span><span class="hljs-comment">//2.叶节点也需要将自己pop</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; valueVec;<span class="hljs-comment">//保存一路径中的元素值</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; allPathVec;<span class="hljs-comment">//保存符合某值的路径</span><span class="hljs-keyword">int</span> currentNumber = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前累计值</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Path</span><span class="hljs-params">(TreeNode *root, <span class="hljs-keyword">int</span> expectNumber, <span class="hljs-keyword">int</span> &amp;currentNumber)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//防御性动作</span>valueVec.push_back(root-&gt;val);<span class="hljs-comment">//将此节点的值存入路径</span>currentNumber += root-&gt;val;<span class="hljs-comment">//累计值累加</span><span class="hljs-keyword">if</span> (currentNumber == expectNumber &amp;&amp; root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//判断当前值和某值是否相等且此节点必须为叶节点</span>&#123;allPathVec.push_back(valueVec);<span class="hljs-comment">//将路径存储</span><span class="hljs-keyword">return</span>;<span class="hljs-comment">//结束本次调用</span>&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//否则递归调用传入left与right</span>&#123;Path(root-&gt;left, expectNumber, currentNumber);Path(root-&gt;right, expectNumber, currentNumber);currentNumber -= valueVec.back();<span class="hljs-comment">//此时将本节点pop</span>valueVec.pop_back();<span class="hljs-comment">//减去本节点的值</span>&#125;<span class="hljs-keyword">if</span> (root-&gt;left != <span class="hljs-literal">NULL</span> || root-&gt;right != <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//判断这是否为父节点</span>&#123;<span class="hljs-comment">//若为父节点，则将本节点从路径中删除且从累计值中减去</span>currentNumber -= valueVec.back();valueVec.pop_back();&#125;&#125;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-title">FindPath</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> expectNumber)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> allPathVec;<span class="hljs-comment">//防御性动作</span>Path(root, expectNumber, currentNumber);<span class="hljs-comment">//递归调用</span><span class="hljs-keyword">return</span> allPathVec;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（23）二叉搜索树的后序遍历序列</title>
    <link href="/2020/06/29/postorder-traversal-sequence-of-binary-search-tree/"/>
    <url>/2020/06/29/postorder-traversal-sequence-of-binary-search-tree/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>最近几天被推荐参加互联网+比赛，一直忙着团队前期工作。。拖更了。。</em> *</strong><br><strong>题目描述：</strong></p><blockquote><p><strong>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs reasonml"><span class="hljs-comment">//找规律</span><span class="hljs-comment">//      8</span><span class="hljs-comment">//  6      10</span><span class="hljs-comment">//5   7  9    11</span><span class="hljs-comment">//&#123;5，7，6，9，11，10，8&#125;</span><span class="hljs-comment">//最后一个为树的root</span><span class="hljs-comment">//&#123;5，6，7&#125;为左子树、&#123;9，11，10&#125;为右子树</span><span class="hljs-comment">//递归判断</span><span class="hljs-comment">//假定&#123;7，4，6，5&#125;</span><span class="hljs-comment">//7大于root，所以7之后的数为右子树，但又出现了比root小的数，所以次遍历结果false</span><span class="hljs-keyword">class</span> Solution &#123;public:<span class="hljs-comment">//传入root下标和此子树最小元素的下标</span><span class="hljs-built_in">bool</span> <span class="hljs-constructor">Verify(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt; <span class="hljs-params">sequence</span>, <span class="hljs-params">int</span> <span class="hljs-params">rootIndex</span>, <span class="hljs-params">int</span> <span class="hljs-params">minIndex</span>)</span>&#123;<span class="hljs-keyword">if</span> (minIndex - rootIndex &gt;= <span class="hljs-number">0</span>) return <span class="hljs-literal">true</span>;<span class="hljs-comment">//判断此子树是否为空或只有1个元素</span><span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">int</span> leftIndex = minIndex;<span class="hljs-comment">//保存左子树的root下标</span><span class="hljs-keyword">while</span> (leftIndex &lt; rootIndex<span class="hljs-operator"> &amp;&amp; </span>sequence<span class="hljs-literal">[<span class="hljs-identifier">leftIndex</span>]</span> &lt; sequence<span class="hljs-literal">[<span class="hljs-identifier">rootIndex</span>]</span>)<span class="hljs-comment">//寻找第一个大于root值的元素的下标</span>&#123;++leftIndex;&#125;<span class="hljs-built_in">int</span> rightIndex = leftIndex;<span class="hljs-keyword">while</span> (rightIndex &lt; rootIndex)<span class="hljs-comment">//判断右子树中是否有小于root的元素</span>&#123;<span class="hljs-keyword">if</span> (sequence<span class="hljs-literal">[<span class="hljs-identifier">rightIndex</span>]</span> &lt; sequence<span class="hljs-literal">[<span class="hljs-identifier">rootIndex</span>]</span>)<span class="hljs-comment">//若有直接return</span>return <span class="hljs-literal">false</span>;++rightIndex;&#125;return <span class="hljs-constructor">Verify(<span class="hljs-params">sequence</span>, <span class="hljs-params">leftIndex</span> - 1, <span class="hljs-params">minIndex</span>)</span><span class="hljs-operator"> &amp;&amp; </span><span class="hljs-constructor">Verify(<span class="hljs-params">sequence</span>, <span class="hljs-params">rootIndex</span> - 1, <span class="hljs-params">leftIndex</span>)</span>;<span class="hljs-comment">//对左子树和右子树继续递归</span>&#125;&#125;<span class="hljs-built_in">bool</span> <span class="hljs-constructor">VerifySquenceOfBST(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt; <span class="hljs-params">sequence</span>)</span> &#123;<span class="hljs-comment">//统一使用下标</span><span class="hljs-built_in">int</span> maxIndex = sequence.size<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (maxIndex &lt; <span class="hljs-number">0</span>) return <span class="hljs-literal">false</span>;<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (maxIndex<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) return <span class="hljs-literal">true</span>;<span class="hljs-comment">//只有一个元素时直接return</span><span class="hljs-keyword">else</span>return <span class="hljs-constructor">Verify(<span class="hljs-params">sequence</span>, <span class="hljs-params">maxIndex</span>, 0)</span>;<span class="hljs-comment">//将此树的root和最小数的下标传入</span>&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>棋盘覆盖问题算法分析与实现（递归）</title>
    <link href="/2020/06/29/algorithm-analysis-and-implementation-of-checkerboard-covering-problem/"/>
    <url>/2020/06/29/algorithm-analysis-and-implementation-of-checkerboard-covering-problem/</url>
    
    <content type="html"><![CDATA[<p><strong><strong>昨天上传的代码，经过再次测试发现有问题，其中对边界、终止条件的判断都有错误。。。→_→，今天重新改正，对之前看过代码的童鞋表示sorry。。。（2017.5.13 16：24）</strong></strong></p><p><strong>问题描述：</strong></p><blockquote><p><strong>在一个2^k×2^k （k≥0）个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为特殊方格。显然，特殊方格在棋盘中可能出现的位置有4^k种，因而有4^k种不同的棋盘。棋盘覆盖问题（chess cover problem）要求使用4种不同形状的L型骨牌覆盖给定棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。</strong></p></blockquote><p>关于棋盘划分的更多概念请戳传送门：<a href="http://baike.baidu.com/link?url=NRSk5y5ZEQJoMB1IOahHh0_C9EXAXz1jiNP2RwTjkV8HGonNBXiq7dxXZ8sZq5OotITXsl24E48V5IC5RLbbWfzHGoHnZuobWrdKwH4StaeryBS7LoiLZgxSm9Ivji5seRhr-062OJCwOYDsL7Y2oK" target="_blank" rel="noopener">棋盘覆盖问题</a></p><p><strong>实现如下：</strong></p><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution&#123;public:<span class="hljs-built_in">int</span> num = <span class="hljs-number">0</span>;<span class="hljs-comment">//累计计算</span><span class="hljs-built_in">int</span> **board = NULL;<span class="hljs-comment">//动态二维数组指针</span>void print<span class="hljs-constructor">Board(<span class="hljs-params">int</span> <span class="hljs-operator">**</span><span class="hljs-params">board</span>, <span class="hljs-params">int</span> <span class="hljs-params">row</span>, <span class="hljs-params">int</span> <span class="hljs-params">col</span>)</span><span class="hljs-comment">//输出函数</span>&#123;for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i)&#123;for (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j)cout &lt;&lt; setw(<span class="hljs-number">3</span>) &lt;&lt;board<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;cout &lt;&lt; endl;&#125;cout &lt;&lt; endl;&#125;void create<span class="hljs-constructor">Board(<span class="hljs-params">int</span> <span class="hljs-params">chessboardSize</span>, <span class="hljs-params">int</span> <span class="hljs-params">dr</span>, <span class="hljs-params">int</span> <span class="hljs-params">dc</span>)</span><span class="hljs-comment">//动态申请内存函数</span>&#123;board = (<span class="hljs-built_in">int</span> **)malloc(chessboardSize<span class="hljs-operator"> * </span>sizeof(<span class="hljs-built_in">int</span>*));<span class="hljs-keyword">assert</span>(board != NULL);for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; chessboardSize; ++i)&#123;board<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = (<span class="hljs-built_in">int</span>*)malloc(chessboardSize<span class="hljs-operator"> * </span>sizeof(<span class="hljs-built_in">int</span>));<span class="hljs-keyword">assert</span>(board<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> != NULL);memset(board<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>, <span class="hljs-number">0</span>, sizeof(<span class="hljs-built_in">int</span>)*chessboardSize);&#125;board<span class="hljs-literal">[<span class="hljs-identifier">dr</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">dc</span>]</span> = -<span class="hljs-number">1</span>;<span class="hljs-comment">//将特殊点设置为-1</span>&#125;void free<span class="hljs-constructor">Board(<span class="hljs-params">int</span> <span class="hljs-params">row</span>)</span><span class="hljs-comment">//释放动态内存空间，防止内存泄漏</span>&#123;for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i)free(board<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>);free(board);&#125;<span class="hljs-comment">//chessboardSize表示此时范围的n*n，n的值</span><span class="hljs-comment">//dr表示特殊点的行下标</span><span class="hljs-comment">//dc表示特殊点的列下标</span><span class="hljs-comment">//tr表示此时范围的左上角在数组中的行下标</span><span class="hljs-comment">//tc表示此时范围的左上角在数组中的列下标</span>void <span class="hljs-constructor">Coverage(<span class="hljs-params">int</span> <span class="hljs-params">chessboardSize</span>, <span class="hljs-params">int</span> <span class="hljs-params">dr</span>, <span class="hljs-params">int</span> <span class="hljs-params">dc</span>, <span class="hljs-params">int</span> <span class="hljs-params">tr</span>, <span class="hljs-params">int</span> <span class="hljs-params">tc</span>)</span>&#123;<span class="hljs-keyword">if</span> (chessboardSize<span class="hljs-operator"> == </span><span class="hljs-number">1</span>) return;<span class="hljs-comment">//当范围为1时，表示只有一个元素，return</span><span class="hljs-built_in">int</span> tmp = ++num;<span class="hljs-comment">//每进入一个范围内，num累加</span><span class="hljs-built_in">int</span> s = chessboardSize<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<span class="hljs-comment">//获取此时范围内的下一个小范围的n大小</span><span class="hljs-comment">//判断特殊点是否在范围内的第一象限</span><span class="hljs-keyword">if</span> (dr &lt; tr + s<span class="hljs-operator"> &amp;&amp; </span>dr &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>dc &lt; tc + s<span class="hljs-operator"> &amp;&amp; </span>dc &gt;= <span class="hljs-number">0</span>)<span class="hljs-constructor">Coverage(<span class="hljs-params">s</span>, <span class="hljs-params">dr</span>, <span class="hljs-params">dc</span>, <span class="hljs-params">tr</span>, <span class="hljs-params">tc</span>)</span>;<span class="hljs-keyword">else</span><span class="hljs-comment">//否则，将此第一象限的右下角设置为相对特殊点</span>&#123;board<span class="hljs-literal">[<span class="hljs-identifier">tr</span> + <span class="hljs-identifier">s</span> - <span class="hljs-number">1</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">tc</span> + <span class="hljs-identifier">s</span> - <span class="hljs-number">1</span>]</span> = tmp;<span class="hljs-constructor">Coverage(<span class="hljs-params">s</span>, <span class="hljs-params">tr</span> + <span class="hljs-params">s</span> - 1, <span class="hljs-params">tc</span> + <span class="hljs-params">s</span> - 1, <span class="hljs-params">tr</span>, <span class="hljs-params">tc</span>)</span>;&#125;<span class="hljs-comment">//判断特殊点是否在范围内的第四象限</span><span class="hljs-keyword">if</span> (dr &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>dr &lt; tr + s<span class="hljs-operator"> &amp;&amp; </span>dc &gt;= tc + s<span class="hljs-operator"> &amp;&amp; </span>dc &lt; tc + <span class="hljs-number">2</span><span class="hljs-operator"> * </span>s)<span class="hljs-constructor">Coverage(<span class="hljs-params">s</span>, <span class="hljs-params">dr</span>, <span class="hljs-params">dc</span>, <span class="hljs-params">tr</span>, <span class="hljs-params">tc</span> + <span class="hljs-params">s</span>)</span>;<span class="hljs-keyword">else</span><span class="hljs-comment">//否则，将此第四象限的右下角设置为相对特殊点</span>&#123;board<span class="hljs-literal">[<span class="hljs-identifier">tr</span> + <span class="hljs-identifier">s</span> - <span class="hljs-number">1</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">tc</span> + <span class="hljs-identifier">s</span>]</span> = tmp;<span class="hljs-constructor">Coverage(<span class="hljs-params">s</span>, <span class="hljs-params">tr</span> + <span class="hljs-params">s</span> - 1, <span class="hljs-params">tc</span> + <span class="hljs-params">s</span>, <span class="hljs-params">tr</span>, <span class="hljs-params">tc</span> + <span class="hljs-params">s</span>)</span>;&#125;<span class="hljs-comment">//判断特殊点是否在范围内的第二象限</span><span class="hljs-keyword">if</span> (dr &gt;= tr + s<span class="hljs-operator"> &amp;&amp; </span>dr &lt; tr + <span class="hljs-number">2</span><span class="hljs-operator"> * </span>s<span class="hljs-operator"> &amp;&amp; </span>dc &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>dc &lt; tc + s)<span class="hljs-constructor">Coverage(<span class="hljs-params">s</span>, <span class="hljs-params">dr</span>, <span class="hljs-params">dc</span>, <span class="hljs-params">tr</span> + <span class="hljs-params">s</span>, <span class="hljs-params">tc</span>)</span>;<span class="hljs-keyword">else</span><span class="hljs-comment">//否则，将此第二象限的右下角设置为相对特殊点</span>&#123;board<span class="hljs-literal">[<span class="hljs-identifier">tr</span> + <span class="hljs-identifier">s</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">tc</span> + <span class="hljs-identifier">s</span> - <span class="hljs-number">1</span>]</span> = tmp;<span class="hljs-constructor">Coverage(<span class="hljs-params">s</span>, <span class="hljs-params">tr</span> + <span class="hljs-params">s</span>, <span class="hljs-params">tc</span> + <span class="hljs-params">s</span> - 1, <span class="hljs-params">tr</span> + <span class="hljs-params">s</span>, <span class="hljs-params">tc</span>)</span>;&#125;<span class="hljs-comment">//判断特殊点是否在范围内的第三象限</span><span class="hljs-keyword">if</span> (dr &gt;= tr + s<span class="hljs-operator"> &amp;&amp; </span>dr &lt; tr + <span class="hljs-number">2</span><span class="hljs-operator"> * </span>s<span class="hljs-operator"> &amp;&amp; </span>dc &gt;= tc + s<span class="hljs-operator"> &amp;&amp; </span>dc &lt; tc + <span class="hljs-number">2</span><span class="hljs-operator"> * </span>s)<span class="hljs-constructor">Coverage(<span class="hljs-params">s</span>, <span class="hljs-params">dr</span>, <span class="hljs-params">dc</span>, <span class="hljs-params">tr</span> + <span class="hljs-params">s</span>, <span class="hljs-params">tc</span> + <span class="hljs-params">s</span>)</span>;<span class="hljs-keyword">else</span><span class="hljs-comment">//否则，将此第三象限的右下角设置为相对特殊点</span>&#123;board<span class="hljs-literal">[<span class="hljs-identifier">tr</span> + <span class="hljs-identifier">s</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">tc</span> + <span class="hljs-identifier">s</span>]</span> = tmp;<span class="hljs-constructor">Coverage(<span class="hljs-params">s</span>, <span class="hljs-params">tr</span> + <span class="hljs-params">s</span>, <span class="hljs-params">tc</span> + <span class="hljs-params">s</span>, <span class="hljs-params">tr</span> + <span class="hljs-params">s</span>, <span class="hljs-params">tc</span> + <span class="hljs-params">s</span>)</span>;&#125;<span class="hljs-comment">//printBoard(board, 8, 8);</span>&#125;void <span class="hljs-constructor">ChessboardCoverage(<span class="hljs-params">int</span> <span class="hljs-params">chessboardSize</span>, <span class="hljs-params">int</span> <span class="hljs-params">dr</span>, <span class="hljs-params">int</span> <span class="hljs-params">dc</span>)</span>&#123;<span class="hljs-keyword">if</span> (chessboardSize &lt; <span class="hljs-number">1</span><span class="hljs-operator"> || </span>dr &lt; <span class="hljs-number">0</span><span class="hljs-operator"> || </span>dc &lt; <span class="hljs-number">0</span><span class="hljs-operator"> || </span>dr &gt;= chessboardSize<span class="hljs-operator"> || </span>dc &gt;= chessboardSize) return;<span class="hljs-comment">//防御性动作</span>create<span class="hljs-constructor">Board(<span class="hljs-params">chessboardSize</span>, <span class="hljs-params">dr</span>, <span class="hljs-params">dc</span>)</span>;<span class="hljs-comment">//动态生成二维数组</span><span class="hljs-constructor">Coverage(<span class="hljs-params">chessboardSize</span>, <span class="hljs-params">dr</span>, <span class="hljs-params">dc</span>, 0, 0)</span>;<span class="hljs-comment">//开始覆盖</span>print<span class="hljs-constructor">Board(<span class="hljs-params">board</span>, <span class="hljs-params">chessboardSize</span>, <span class="hljs-params">chessboardSize</span>)</span>;<span class="hljs-comment">//输出</span>free<span class="hljs-constructor">Board(<span class="hljs-params">chessboardSize</span>)</span>;<span class="hljs-comment">//释放动态空间</span>&#125;&#125;;</code></pre><p><strong>测试用例：</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTEzMTYyNjI5OTkz?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="棋盘覆盖算法"></p>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整数划分问题算法分析与实现（递归）</title>
    <link href="/2020/06/29/algorithm-analysis-and-implementation-of-integer-partition-problem/"/>
    <url>/2020/06/29/algorithm-analysis-and-implementation-of-integer-partition-problem/</url>
    
    <content type="html"><![CDATA[<p><strong>问题描述：</strong></p><blockquote><p><strong>把一个正整数n写成多个大于等于1且小于等于其本身的整数的和，则其中各加数所构成的集合为n的一个划分。</strong><br><strong>把一个正整数n写成为 n=m1+m2+…+mi。其中，mi为正整数，并且1≤mi≤n；{m1，m2，…，mi}为n的一个划分。</strong><br><strong>如{m1，m2，…，mi}果中的最大值不超过m，即max(m1，m2，…，mi)≤m，则称它属于n的一个m划分。</strong></p></blockquote><p>关于整数划分和生成函数的具体概念请戳传送门：<a href="https://en.wikipedia.org/wiki/Partition_(number_theory)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Partition_(number_theory)</a></p><p><strong>实现如下：</strong></p><ol><li><p>当n = 1时，无论m为何值，只有{1}一种划分</p></li><li><p>当m = 1时，无论n为何值，只有{n}一种划分</p></li><li><p>当n &lt; m时，因为m为正整数，所以不可能出现负数情况，所以相当于IntegerPartition(n, n)</p></li><li><p>当n == m时，细分为划分中是否包含n的情况</p><ul><li><p>当划分中包含n时，划分为{n}，一种情况</p></li><li><p>当划分中不包含n时，划分中mi最大值一定小于n，则划分为IntegerPartition(n, m-1)</p></li><li><p>此时IntegerPartition(n, m) = 1 + IntegerPartition(n, m-1)</p></li></ul></li><li><p>当n &gt; m时，细分为划分中是否包含m的情况</p><ul><li>当划分中包含m时，划分为{m，{x1，x2，…，xi}}，此时划分为IntegerPartition(n-m, m)</li><li>当划分中不包含m时，此时划分中的max一定小于m，此时划分为IntegerPartition(n, m-1)</li><li>此时IntegerPartition(n, m) = IntegerPartition(n-m, m) + IntegerPartition(n, m-1)</li></ul></li></ol><pre><code class="hljs angelscript"><span class="hljs-comment">//注意输入值的判断</span><span class="hljs-comment">//保证所有路径都有返回值</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">int</span> IntegerPartition(<span class="hljs-built_in">int</span> n, <span class="hljs-built_in">int</span> m)&#123;<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span> || m &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || m == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt; m) <span class="hljs-keyword">return</span> IntegerPartition(n, n);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == m) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + IntegerPartition(n, m - <span class="hljs-number">1</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt; m) <span class="hljs-keyword">return</span> IntegerPartition(n - m, m) + IntegerPartition(n, m - <span class="hljs-number">1</span>);&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求子集问题算法分析与实现（递归、非递归）</title>
    <link href="/2020/06/29/algorithm-analysis-and-Implementation-of-seeking-subset-problem/"/>
    <url>/2020/06/29/algorithm-analysis-and-Implementation-of-seeking-subset-problem/</url>
    
    <content type="html"><![CDATA[<p><strong>问题描述：</strong></p><blockquote><p><strong>若有数字集合{1，2，3}，则其子集为NULL、{1}、{2}、{3}、{1，2}、{1，3}、{2，3}、{1，2，3}。现给定数组，求其的全部子集。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs arduino"><span class="hljs-comment">//非递归</span><span class="hljs-comment">//&#123;1，2，3&#125;</span><span class="hljs-comment">// 0  0  0</span><span class="hljs-comment">// 0  0  1</span><span class="hljs-comment">// 0  1  0</span><span class="hljs-comment">// 0  1  1</span><span class="hljs-comment">// 1  0  0</span><span class="hljs-comment">// 1  0  1</span><span class="hljs-comment">// 1  1  0</span><span class="hljs-comment">// 1  1  1</span><span class="hljs-comment">//计算子集的个数，即2的元素个数次方</span><span class="hljs-comment">//一次规律</span><span class="hljs-comment">//空集需要特殊输出</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *value, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (value == <span class="hljs-literal">NULL</span> || <span class="hljs-built_in">size</span> &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">int</span> *tmp = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">size</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<span class="hljs-comment">//开辟空间存放输出标志</span>assert(tmp != <span class="hljs-literal">NULL</span>);<span class="hljs-built_in">memset</span>(tmp, <span class="hljs-number">0</span>, <span class="hljs-built_in">size</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<span class="hljs-keyword">int</span> num = (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">pow</span>((<span class="hljs-keyword">double</span>)<span class="hljs-number">2</span>, (<span class="hljs-keyword">double</span>)<span class="hljs-built_in">size</span>);<span class="hljs-comment">//计算子集个数</span><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"NULL"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; num; ++i)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">size</span>; ++j)<span class="hljs-comment">//给输出标志赋值，二进制计算</span>&#123;<span class="hljs-keyword">if</span> (tmp[j] == <span class="hljs-number">1</span>) tmp[j] = <span class="hljs-number">0</span>;<span class="hljs-comment">//逢二进一</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp[j] == <span class="hljs-number">0</span>)&#123;tmp[j] = <span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">size</span>; ++j)<span class="hljs-comment">//比较输出标志，得出子集所包含元素</span>&#123;<span class="hljs-keyword">if</span> (tmp[j] == <span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span> &lt;&lt; value[j] &lt;&lt; <span class="hljs-string">" "</span>;&#125;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">delete</span> tmp;<span class="hljs-comment">//释放内存空间</span>&#125;&#125;;<span class="hljs-comment">//递归</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">int</span> *tmp;<span class="hljs-comment">//指向动态数组的指针</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span><span class="hljs-comment">//创建动态数组</span></span><span class="hljs-function"></span>&#123;tmp = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">size</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));assert(tmp != <span class="hljs-literal">NULL</span>);<span class="hljs-built_in">memset</span>(tmp, <span class="hljs-number">0</span>, <span class="hljs-built_in">size</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteArray</span><span class="hljs-params">()</span><span class="hljs-comment">//释放内存空间</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">free</span>(tmp);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subsetRecursive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *value, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (m == <span class="hljs-number">-1</span>)<span class="hljs-comment">//此时标志位都已赋值，进行统计输出</span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)&#123;<span class="hljs-keyword">if</span> (tmp[i] == <span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span> &lt;&lt; value[i] &lt;&lt; <span class="hljs-string">" "</span>;<span class="hljs-comment">//为1输出</span>&#125;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">else</span>&#123;tmp[m] = <span class="hljs-number">0</span>;<span class="hljs-comment">//先将此标志位赋值为0，即不输出</span>subsetRecursive(value, m - <span class="hljs-number">1</span>, <span class="hljs-built_in">size</span>);<span class="hljs-comment">//递归到下一位</span>tmp[m] = <span class="hljs-number">1</span>;<span class="hljs-comment">//再将此标志位赋值为1，即输出</span>subsetRecursive(value, m - <span class="hljs-number">1</span>, <span class="hljs-built_in">size</span>);<span class="hljs-comment">//递归到下一位</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *value, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (value == <span class="hljs-literal">NULL</span> || <span class="hljs-built_in">size</span> &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//防御性动作</span>createArray(<span class="hljs-built_in">size</span>);subsetRecursive(value, <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>, <span class="hljs-built_in">size</span>);<span class="hljs-comment">//从最高位开始</span>deleteArray();&#125;&#125;;</code></pre><p><strong>结果如图：</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTE0MTUwMjA0OTk0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="求子集算法结果"></p>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全排列问题算法分析与实现（递归、非递归）</title>
    <link href="/2020/06/29/algorithm-analysis-and-implementation-of-full-classification-problem/"/>
    <url>/2020/06/29/algorithm-analysis-and-implementation-of-full-classification-problem/</url>
    
    <content type="html"><![CDATA[<p><strong>问题描述：</strong></p><blockquote><p><strong>若有数字集合{1，2，3}，则其全排列为123、132、213、231、321、312。现给定字符数组，求其字符的全排列。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs axapta"><span class="hljs-comment">//1.递归方法</span><span class="hljs-comment">//如例，其全排列可以分成</span><span class="hljs-comment">//1-&gt;&#123;2,3&#125;</span><span class="hljs-comment">//2-&gt;&#123;1,3&#125;</span><span class="hljs-comment">//3-&gt;&#123;2,1&#125;</span><span class="hljs-comment">//再递归求其剩余字符的全排列</span><span class="hljs-comment">//重点在于如何交换字符</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-keyword">void</span> swap(<span class="hljs-keyword">char</span> &amp;ch1, <span class="hljs-keyword">char</span> &amp;ch2)<span class="hljs-comment">//交换元素值</span>&#123;<span class="hljs-keyword">char</span> tmp = ch1;ch1 = ch2;ch2 = tmp;&#125;<span class="hljs-keyword">void</span> fullPermutation(<span class="hljs-keyword">char</span> *<span class="hljs-keyword">str</span>, <span class="hljs-keyword">int</span> beginIndex, <span class="hljs-keyword">int</span> endIndex)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">str</span> == NULL) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">if</span> (beginIndex == endIndex)<span class="hljs-comment">//当起点下标等于终点下标时，说明已没有待排元素，输出此排列情况</span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= endIndex; ++i)cout &lt;&lt; <span class="hljs-keyword">str</span>[i] &lt;&lt; <span class="hljs-string">" "</span>;cout &lt;&lt; endl;&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//否则说明还有未排元素</span>&#123;<span class="hljs-comment">//j代表目前需要排列的元素</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = beginIndex; j &lt;= endIndex; ++j)&#123;<span class="hljs-comment">//其和beginIndex下标的元素swap，保证它是这个排列子序列中的第一个元素</span>swap(<span class="hljs-keyword">str</span>[beginIndex], <span class="hljs-keyword">str</span>[j]);<span class="hljs-comment">//接着进行递归，此时传参beginIndex需要加1，保证起点下标后移</span>fullParrangement(<span class="hljs-keyword">str</span>, beginIndex + <span class="hljs-number">1</span>, endIndex);<span class="hljs-comment">//此时须将之前交换过的值换回来，保证后序的排列顺序</span>swap(<span class="hljs-keyword">str</span>[beginIndex], <span class="hljs-keyword">str</span>[j]);&#125;&#125;&#125;&#125;;</code></pre><p><strong>方法2中使用STL中的next_permutation()函数，具体说明参见<a href="http://www.cplusplus.com/reference/algorithm/next_permutation/" target="_blank" rel="noopener" title="optional title">next_permutation</a>或参考我自己实现的my_next_permutation()。</strong></p><pre><code class="hljs cpp"><span class="hljs-comment">//2.非递归方法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>：<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fullPermutation</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">int</span> <span class="hljs-built_in">strlen</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (str == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//防御性动作</span>sort(str, str + <span class="hljs-built_in">strlen</span>);<span class="hljs-comment">//首先将str排序</span><span class="hljs-comment">//第一次直接输出</span><span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-built_in">strlen</span>; ++i)<span class="hljs-built_in">cout</span> &lt;&lt; str[i];<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125; <span class="hljs-keyword">while</span> (my_next_permutation(str, str + <span class="hljs-built_in">strlen</span>));<span class="hljs-comment">//若下一个字典序存在，则继续输出，否则结束</span>&#125;&#125;;<span class="hljs-comment">//my_next_permutation()实现如下</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *ch1, <span class="hljs-keyword">char</span> *ch2)</span><span class="hljs-comment">//交换元素值</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">char</span> tmp = *ch1;*ch1 = *ch2;*ch2 = tmp;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">my_next_permutation</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *strBegin, <span class="hljs-keyword">char</span> *strEnd)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (strBegin == <span class="hljs-literal">NULL</span> || strEnd == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">if</span> (strEnd - strBegin &lt;= <span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//当元素数小于等于1个时，无须排列</span><span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<span class="hljs-comment">//条件标志判断是否存在下一个字典序列，初始值为假</span><span class="hljs-keyword">char</span> *i = strEnd - <span class="hljs-number">2</span>;<span class="hljs-comment">//i与ii表示相邻两个元素</span><span class="hljs-keyword">char</span> *ii = strEnd - <span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> *j = strEnd - <span class="hljs-number">1</span>;<span class="hljs-comment">//j表示第一个大于i元素的元素</span><span class="hljs-keyword">for</span> (; i &gt;= strBegin &amp;&amp; ii &gt; strBegin; --i,--ii)&#123;<span class="hljs-keyword">if</span> (*i &lt; *ii)<span class="hljs-comment">//寻找第一对i小于ii的相邻元素</span>&#123;flag = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (flag)<span class="hljs-comment">//如果没找到则表示不存在下一个字典序列，反之继续</span>&#123;flag = <span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span> (; j &gt; strBegin; --j)&#123;<span class="hljs-keyword">if</span> (*j &gt; *i)<span class="hljs-comment">//从末尾开始寻找第一个大于i元素的元素</span>&#123;flag = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (flag)<span class="hljs-comment">//如果没找到则表示不存在下一个字典序列，反之继续</span>&#123;swap(i, j);将两者元素的值交换sort(ii, strEnd);<span class="hljs-comment">//将ii之后的所有元素排序</span>&#125;&#125; <span class="hljs-keyword">return</span> flag；&#125;</code></pre><p><strong>next_permutation实现效果：</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTExMTgyNjI0MTQ5?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="next_permutation"></p><p><strong>* <em>啊。。码字真累。。→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（22）从上往下打印二叉树&amp;&amp;层次遍历</title>
    <link href="/2020/06/28/print-binary-tree-and-level-traversal-from-top-to-bottom/"/>
    <url>/2020/06/28/print-binary-tree-and-level-traversal-from-top-to-bottom/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs reasonml"><span class="hljs-comment">//层次遍历时使用队列容器，保证先进先出</span><span class="hljs-comment">//分别判断节点的左右孩子是否为空</span><span class="hljs-comment">//非空就将孩子节点尾插</span><span class="hljs-comment">//每次都从队头获取打印值、头删出队</span><span class="hljs-comment">//队列为空时说明遍历结束</span><span class="hljs-comment">//注意判断root是否合法</span><span class="hljs-keyword">class</span> Solution &#123;public:deque&lt;TreeNode*&gt; q;<span class="hljs-comment">//存放层次遍历时的节点顺序</span>vector&lt;<span class="hljs-built_in">int</span>&gt; vec;vector&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-constructor">PrintFromTopToBottom(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>)</span> &#123;<span class="hljs-keyword">if</span> (root<span class="hljs-operator"> == </span>NULL) return vec;<span class="hljs-comment">//root为空时，直接return</span>q.push<span class="hljs-constructor">_back(<span class="hljs-params">root</span>)</span>;<span class="hljs-comment">//root非空时，首先尾插</span><span class="hljs-keyword">while</span> (!q.empty<span class="hljs-literal">()</span>)<span class="hljs-comment">//判断是否遍历结束</span>&#123;TreeNode *tmp = q.front<span class="hljs-literal">()</span>;<span class="hljs-comment">//队头获取该打印的节点</span>q.pop<span class="hljs-constructor">_front()</span>;<span class="hljs-comment">//分别判断左右孩子是否为空，非空时队列尾插</span><span class="hljs-keyword">if</span> (tmp-&gt;left != NULL)q.push<span class="hljs-constructor">_back(<span class="hljs-params">tmp</span>-&gt;<span class="hljs-params">left</span>)</span>;<span class="hljs-keyword">if</span> (tmp-&gt;right != NULL)q.push<span class="hljs-constructor">_back(<span class="hljs-params">tmp</span>-&gt;<span class="hljs-params">right</span>)</span>;vec.push<span class="hljs-constructor">_back(<span class="hljs-params">tmp</span>-&gt;<span class="hljs-params">val</span>)</span>;<span class="hljs-comment">//将val添加</span>&#125;return vec;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（21）栈的压入、弹出序列</title>
    <link href="/2020/06/28/stack-push-and-pop-sequence/"/>
    <url>/2020/06/28/stack-push-and-pop-sequence/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs arduino"><span class="hljs-comment">//模拟栈的push与pop，利用辅助栈</span><span class="hljs-comment">//在线测试用例中给出了pushV&#123;1&#125;，popV&#123;2&#125;的情况V，万恶→_→</span><span class="hljs-comment">//判断一个出栈序列是否合法，需要在已知的入栈序列情况下判断</span><span class="hljs-comment">//出栈序列中的数pop时，必须保证此数在入栈序列中位置之前的数全部入过栈</span><span class="hljs-comment">//特殊情况：</span><span class="hljs-comment">//1.序列为空</span><span class="hljs-comment">//2.序列中的数字值不一致</span><span class="hljs-comment">//3.出栈顺序不合法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; assistStack;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsPopOrder</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; pushV, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; popV)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//判断是否为空</span><span class="hljs-keyword">if</span> (pushV.empty() || popV.empty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<span class="hljs-comment">//j作为pushV的下标记录</span><span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; popV.<span class="hljs-built_in">size</span>(); ++i)&#123;<span class="hljs-comment">//如果辅助栈不为空且其top不等于该出栈的数且数已全部入过栈，此时出栈顺序不合法</span><span class="hljs-keyword">if</span> (!assistStack.empty() &amp;&amp; assistStack.top() != popV[i] &amp;&amp; j &gt;= pushV.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果辅助栈为空或辅助栈top不等于该出栈的数且还有数字未入过栈</span><span class="hljs-keyword">if</span> (assistStack.empty() || (assistStack.top() != popV[i] &amp;&amp; j &lt; popV.<span class="hljs-built_in">size</span>()))&#123;<span class="hljs-comment">//直至在pushV中找到与该出栈的数相同值的位置</span><span class="hljs-keyword">while</span> ((j &lt; pushV.<span class="hljs-built_in">size</span>()) &amp;&amp; pushV[j] != popV[i])assistStack.push(pushV[j++]);<span class="hljs-comment">//此时j自加1，是因为此循环有可能因为pushV[j] == popV[i]，所以模拟push操作(其实没往assistStack中push)，跳过此数</span>++j;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (assistStack.top() == popV[i])<span class="hljs-comment">//当pushV栈顶元素等于该出栈的数，正常出栈</span>&#123;assistStack.pop();<span class="hljs-keyword">continue</span>;&#125;&#125;&#125;<span class="hljs-comment">//此条件判断有可能两序列中的数字值不一致情况</span><span class="hljs-keyword">if</span> (assistStack.empty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（20）包含min函数的栈</title>
    <link href="/2020/06/28/the-stack-containing-the-min-function/"/>
    <url>/2020/06/28/the-stack-containing-the-min-function/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs cs"><span class="hljs-comment">//利用一个辅助栈，用来存放和数据栈相对应的每层之下的最小值</span><span class="hljs-comment">//利用minValue存储当前最小值，O(1)</span><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-keyword">int</span> minValue = <span class="hljs-number">0</span>;stack&lt;<span class="hljs-keyword">int</span>&gt; assistStack;stack&lt;<span class="hljs-keyword">int</span>&gt; dataStack;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span></span>) </span><span class="hljs-function"></span>&#123;dataStack.push(<span class="hljs-keyword">value</span>);<span class="hljs-keyword">if</span> (dataStack.size() == <span class="hljs-number">1</span>)<span class="hljs-comment">//此时value为第一个元素，直接将value push进辅助栈，及当前最小值</span>&#123;assistStack.push(<span class="hljs-keyword">value</span>);minValue = <span class="hljs-keyword">value</span>;&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//否则用minValue与value比较，小的push进辅助栈，且更新minValue</span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> &lt; minValue)minValue = <span class="hljs-keyword">value</span>;assistStack.push(minValue);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span>(<span class="hljs-params"></span>) </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (!dataStack.empty())<span class="hljs-comment">//非空时操作</span>&#123;dataStack.pop();assistStack.pop();<span class="hljs-comment">//更新辅助栈，保证每层之下的最小值不变</span>minValue = assistStack.top();<span class="hljs-comment">//将minValue更新为这层之下的最小值</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span>(<span class="hljs-params"></span>) </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(!dataStack.empty())<span class="hljs-comment">//非空时进行</span><span class="hljs-keyword">return</span> dataStack.top();<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span>(<span class="hljs-params"></span>) </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> minValue;<span class="hljs-comment">//直接返回minValue</span>&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（19）顺时针打印矩阵</title>
    <link href="/2020/06/28/print-matrix-clockwise/"/>
    <url>/2020/06/28/print-matrix-clockwise/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">/*</span><span class="hljs-comment">1 -&gt; 2 -&gt; 3  -&gt;   4</span><span class="hljs-comment">                  ↓</span><span class="hljs-comment">5 -&gt; 6 -&gt; 7       8</span><span class="hljs-comment">↑        ↓       ↓</span><span class="hljs-comment">9   10  &lt;-  11    12</span><span class="hljs-comment">↑                 ↓</span><span class="hljs-comment">13 &lt;- 14 &lt;- 15 &lt;- 16</span><span class="hljs-comment">*/</span><span class="hljs-comment">//将问题分解成若干子问题</span><span class="hljs-comment">//1.控制按圈打印</span><span class="hljs-comment">//2.一圈之内如何打印</span><span class="hljs-comment">//每一圈的起始坐标都在矩阵主对角线上，判断何时结束绕圈</span><span class="hljs-comment">//圈内打印时注意判断特殊情况，最少都有一行</span><span class="hljs-comment">//1.只有一行</span><span class="hljs-comment">//2.只有一列</span><span class="hljs-comment">//3.2*2大小</span><span class="hljs-comment">//4.3*3大小及以上</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:vector&lt;<span class="hljs-built_in">int</span>&gt; printMatrix(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt; &gt; matrix) &#123;vector&lt;<span class="hljs-built_in">int</span>&gt; vec;<span class="hljs-built_in">int</span> row = matrix.size();<span class="hljs-keyword">if</span> (row &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> vec;<span class="hljs-comment">//判断vector是否为空</span><span class="hljs-built_in">int</span> col = matrix[<span class="hljs-number">0</span>].size();<span class="hljs-built_in">int</span> startRow = <span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> startCol = <span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> endRow = matrix.size() - <span class="hljs-number">1</span>;<span class="hljs-built_in">int</span> endCol = matrix[<span class="hljs-number">0</span>].size() - <span class="hljs-number">1</span>;<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (row &gt; startRow * <span class="hljs-number">2</span> &amp;&amp; col &gt; startCol * <span class="hljs-number">2</span>)<span class="hljs-comment">//判断起始点是否真实存在</span>&#123;<span class="hljs-keyword">for</span> (i = startCol; i &lt;= endCol; ++i)<span class="hljs-comment">//无论如何，最少都会有一行</span>&#123;vec.push_back(matrix[startRow][i]);&#125;<span class="hljs-comment">//如果进行第二步打印，必须满足endRow-startRow&gt;=1,排除只有一行的情况</span><span class="hljs-keyword">if</span> (endRow - startRow &gt;= <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">for</span> (i = startRow + <span class="hljs-number">1</span>; i &lt;= endRow; ++i)&#123;vec.push_back(matrix[i][endCol]);&#125;&#125;<span class="hljs-comment">//如果进行第三步打印，要在第二步条件的基础上满足endCol-startCol&gt;=1,排除只有一列的情况</span><span class="hljs-keyword">if</span> (endCol - startCol &gt;= <span class="hljs-number">1</span> &amp;&amp; endRow - startRow &gt;= <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">for</span> (i = endCol - <span class="hljs-number">1</span>; i &gt;= startCol; --i)&#123;vec.push_back(matrix[endRow][i]);&#125;&#125;<span class="hljs-comment">//如果进行第四步打印，要在第三步条件的基础上满足endRow-startRow&gt;=2,排除2*2的情况</span><span class="hljs-keyword">if</span> (endRow - startRow &gt;= <span class="hljs-number">2</span> &amp;&amp; endCol - startCol &gt;= <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">for</span> (i = endRow - <span class="hljs-number">1</span>; i &gt; startRow; --i)&#123;vec.push_back(matrix[i][startCol]);&#125;&#125;<span class="hljs-comment">//调整边界范围，进行下一圈打印</span>startRow += <span class="hljs-number">1</span>;startCol += <span class="hljs-number">1</span>;endRow -= <span class="hljs-number">1</span>;endCol -= <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> vec;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（18）二叉树的镜像</title>
    <link href="/2020/06/28/mirror-of-the-binary-tree/"/>
    <url>/2020/06/28/mirror-of-the-binary-tree/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>操作给定的二叉树，将其变换为源二叉树的镜像。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs xl"><span class="hljs-comment">//每一个节点都是每一棵子树的根节点，只须交换左右孩子节点即可</span><span class="hljs-comment">//注意输入空指针防御</span><span class="hljs-comment">/*输入样例</span><span class="hljs-comment">二叉树的镜像定义：源二叉树 </span><span class="hljs-comment">        8</span><span class="hljs-comment">       /  \</span><span class="hljs-comment">      6   10</span><span class="hljs-comment">     / \  / \</span><span class="hljs-comment">    5  7 9 11</span><span class="hljs-comment">    镜像二叉树</span><span class="hljs-comment">        8</span><span class="hljs-comment">       /  \</span><span class="hljs-comment">      10   6</span><span class="hljs-comment">     / \  / \</span><span class="hljs-comment">    11 9 7  5</span><span class="hljs-comment">*/</span><span class="hljs-comment">/*节点结构体定义</span><span class="hljs-comment">struct TreeNode </span><span class="hljs-comment">&#123;</span><span class="hljs-comment">int val;</span><span class="hljs-comment">struct TreeNode *left;</span><span class="hljs-comment">struct TreeNode *right;</span><span class="hljs-comment">TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span>class Solution &#123;public:void Mirror(TreeNode *pRoot) &#123;<span class="hljs-keyword">if</span> (pRoot == NULL) return;<span class="hljs-comment">//判断是否为空指针</span>T<span class="hljs-function"><span class="hljs-title">reeNode</span> *tmp = pRoot-&gt;</span>left;<span class="hljs-comment">//否则交换左右孩子的指向</span><span class="hljs-function"><span class="hljs-title">pRoot</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> = pRoot-&gt;</span>right;<span class="hljs-function"><span class="hljs-title">pRoot</span>-&gt;</span>right = tmp;M<span class="hljs-function"><span class="hljs-title">irror</span>(pRoot-&gt;</span>left);<span class="hljs-comment">//递归调用对左孩子镜像处理</span>M<span class="hljs-function"><span class="hljs-title">irror</span>(pRoot-&gt;</span>right);<span class="hljs-comment">//递归调用对右孩子镜像处理</span>&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（17）树的子结构</title>
    <link href="/2020/06/28/tree-substructure/"/>
    <url>/2020/06/28/tree-substructure/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs zephir"><span class="hljs-comment">//分两步</span><span class="hljs-comment">//第一步：寻找与B树根节点val相等的A树节点。如果找到进入第二步，否则继续寻找，直到找完A树</span><span class="hljs-comment">//第二步：以找的节点作为A树子树的根节点，同时遍历两棵树，判断是否所有节点都相同</span><span class="hljs-comment">//特殊情况：</span><span class="hljs-comment">//1.进行第二步时注意有可能存在B树大小等于A的子树、B树大小小于A的子树、B树大小大于A的子树</span><span class="hljs-comment">//2.注意对无效值的防御</span><span class="hljs-comment">//3.减少递归此数，及时判断return</span><span class="hljs-comment">/*</span><span class="hljs-comment">struct TreeNode </span><span class="hljs-comment">&#123;</span><span class="hljs-comment">int val;</span><span class="hljs-comment">struct TreeNode *left;</span><span class="hljs-comment">struct TreeNode *right;</span><span class="hljs-comment">TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-comment">//第二步</span><span class="hljs-keyword">bool</span> Subtree(TreeNode* pRoot1, TreeNode* pRoot2)&#123;<span class="hljs-keyword">if</span> (pRoot1 == <span class="hljs-keyword">NULL</span> &amp;&amp; pRoot2 == <span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<span class="hljs-comment">//B树大小等于A的子树</span><span class="hljs-keyword">if</span> (pRoot1 != <span class="hljs-keyword">NULL</span> &amp;&amp; pRoot2 == <span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<span class="hljs-comment">//B树大小小于A的子树</span><span class="hljs-keyword">if</span> (pRoot1 == <span class="hljs-keyword">NULL</span> &amp;&amp; pRoot2 != <span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<span class="hljs-comment">//B树大小大于A的子树</span><span class="hljs-keyword">if</span> (pRoot1-&gt;val == pRoot2-&gt;val)<span class="hljs-comment">//如果val相等则进行进一步比较</span><span class="hljs-keyword">return</span> Subtree(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; Subtree(pRoot1-&gt;right, pRoot2-&gt;right);<span class="hljs-keyword">else</span><span class="hljs-comment">//否则直接return</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-comment">//第一步</span><span class="hljs-keyword">bool</span> HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)&#123;<span class="hljs-comment">//对空指针防御</span><span class="hljs-keyword">if</span> (pRoot1 == <span class="hljs-keyword">NULL</span> || pRoot2 == <span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;TreeNode *p1 = pRoot1;<span class="hljs-keyword">bool</span> flag = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//是否相等标志</span><span class="hljs-keyword">if</span> (p1-&gt;val == pRoot2-&gt;val)<span class="hljs-comment">//若A树有节点val等于B树根节点val，进入第二步</span>&#123;flag = Subtree(p1, pRoot2);<span class="hljs-comment">//开始第二步递归调用</span><span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> flag;<span class="hljs-comment">//如果是子结构，直接return</span>&#125;<span class="hljs-comment">//否则继续第一步</span>flag = HasSubtree(p1-&gt;left, pRoot2);<span class="hljs-comment">//对左子树进行第一步</span><span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> flag;flag = HasSubtree(p1-&gt;right, pRoot2);<span class="hljs-comment">//对右子树进行第一步</span><span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> flag;<span class="hljs-keyword">return</span> flag;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（16）合并两个排序的链表</title>
    <link href="/2020/06/28/merge-two-sorted-linked-lists/"/>
    <url>/2020/06/28/merge-two-sorted-linked-lists/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs php"><span class="hljs-comment">//本题在线测试用例怎么还是无头节点链表→_→，啊...</span><span class="hljs-comment">//比较value谁小谁添加到新链表中</span><span class="hljs-comment">//新链表的头节点指针为newHead，由s指针负责添加信节点</span><span class="hljs-comment">//特殊情况：</span><span class="hljs-comment">//1.传入空指针</span><span class="hljs-comment">//2.任意一个链表添加完毕</span><span class="hljs-comment">//3.传入的一个链表为空，另一个不为空</span><span class="hljs-comment">//节点结构体定义</span><span class="hljs-comment">/*</span><span class="hljs-comment">struct ListNode </span><span class="hljs-comment">&#123;</span><span class="hljs-comment">int val;</span><span class="hljs-comment">struct ListNode *next;</span><span class="hljs-comment">ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">public</span>:ListNode* Merge(ListNode* pHead1, ListNode* pHead2)&#123;<span class="hljs-comment">//判断传入参数是否为空</span><span class="hljs-keyword">if</span> (pHead1 == <span class="hljs-keyword">NULL</span> &amp;&amp; pHead2 == <span class="hljs-keyword">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">NULL</span>;ListNode *newHead = <span class="hljs-keyword">NULL</span>;<span class="hljs-comment">//新链表的头指针</span>ListNode *s = <span class="hljs-keyword">NULL</span>;<span class="hljs-comment">//负责给新链表添加心节点</span><span class="hljs-keyword">while</span> (pHead1 != <span class="hljs-keyword">NULL</span> &amp;&amp; pHead2 != <span class="hljs-keyword">NULL</span>)<span class="hljs-comment">//直到将一个链表添加完</span>&#123;<span class="hljs-keyword">if</span> (pHead1-&gt;val &lt;= pHead2-&gt;val)<span class="hljs-comment">//谁小谁添加</span>&#123;<span class="hljs-keyword">if</span> (newHead == s &amp;&amp; newHead == <span class="hljs-keyword">NULL</span>)<span class="hljs-comment">//第一次添加节点</span>&#123;newHead = pHead1;s = pHead1;&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//除第一次以外添加节点</span>&#123;s-&gt;next = pHead1;s = s-&gt;next;&#125;pHead1 = pHead1-&gt;next;<span class="hljs-comment">//使pHead1指向为排序节点</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (newHead == s &amp;&amp; newHead == <span class="hljs-keyword">NULL</span>)<span class="hljs-comment">//第一次添加节点情况</span>&#123;newHead = pHead2;s = pHead2;&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//除第一次情况以外</span>&#123;s-&gt;next = pHead2;s = s-&gt;next;&#125;pHead2 = pHead2-&gt;next;&#125;&#125;<span class="hljs-comment">//判断是否为一个为空另一个不为空的情况</span><span class="hljs-keyword">if</span> (newHead == <span class="hljs-keyword">NULL</span> &amp;&amp; pHead1 != <span class="hljs-keyword">NULL</span>) newHead = pHead1;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newHead == <span class="hljs-keyword">NULL</span> &amp;&amp; pHead2 != <span class="hljs-keyword">NULL</span>) newHead = pHead2;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pHead1 != <span class="hljs-keyword">NULL</span>) s-&gt;next = pHead1;<span class="hljs-comment">//判断是否还有链表未添加完</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pHead2 != <span class="hljs-keyword">NULL</span>)s-&gt;next = pHead2;<span class="hljs-keyword">return</span> newHead;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（15）反转链表</title>
    <link href="/2020/06/28/reverse-linked-list/"/>
    <url>/2020/06/28/reverse-linked-list/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一个链表，反转链表后，输出链表的所有元素。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs php"><span class="hljs-comment">//此题在线用例还是无头链表→_→</span><span class="hljs-comment">//1&lt;-2&lt;-3 4-&gt;5</span><span class="hljs-comment">//   p  s q</span><span class="hljs-comment">//保证三个指针指向相邻的三个节点</span><span class="hljs-comment">//健壮性：</span><span class="hljs-comment">//1.传入空指针</span><span class="hljs-comment">//2.链表中只有一个节点</span><span class="hljs-comment">/*节点结构体定义</span><span class="hljs-comment">struct ListNode </span><span class="hljs-comment">&#123;</span><span class="hljs-comment">int val;</span><span class="hljs-comment">struct ListNode *next;</span><span class="hljs-comment">ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">public</span>:ListNode* ReverseList(ListNode* pHead) &#123;<span class="hljs-keyword">if</span> (pHead == <span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">NULL</span>;<span class="hljs-comment">//放置传入空指针</span>ListNode *p = pHead;ListNode *s = pHead-&gt;next;ListNode *q = pHead;p-&gt;next = <span class="hljs-keyword">NULL</span>;<span class="hljs-comment">//首先将第一个节点的next赋值为NULL</span><span class="hljs-keyword">while</span> (s != <span class="hljs-keyword">NULL</span>)<span class="hljs-comment">//判断是否还有为反转节点</span>&#123;q = s-&gt;next;<span class="hljs-comment">//预先保存s的next</span>s-&gt;next = p;<span class="hljs-comment">//连到已反转链表</span>p = s;<span class="hljs-comment">//指向已反转链表的第一个节点</span>s = q;<span class="hljs-comment">//指向未反转链表的第一个节点</span>&#125;<span class="hljs-keyword">return</span> p;&#125;&#125;;<span class="hljs-comment">//使用两个指针，用pHead代替上面方法的p的作用</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">public</span>:ListNode* ReverseList(ListNode* pHead)&#123;<span class="hljs-keyword">if</span> (pHead == <span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">NULL</span>;ListNode *p = pHead;ListNode *s = pHead-&gt;next;pHead-&gt;next = <span class="hljs-keyword">NULL</span>;<span class="hljs-keyword">while</span> (s != <span class="hljs-keyword">NULL</span>)&#123;p = s;s = s-&gt;next;<span class="hljs-comment">//保存下一个未反转节点</span>p-&gt;next = pHead;pHead = p;&#125;<span class="hljs-keyword">return</span> pHead;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（14）链表中倒数第k个结点</title>
    <link href="/2020/06/28/the-last-k-th-node-in-the-list/"/>
    <url>/2020/06/28/the-last-k-th-node-in-the-list/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一个链表，输出该链表中倒数第k个结点。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs zephir"><span class="hljs-comment">//在线测试用例依旧是无头链表→_→</span><span class="hljs-comment">//最后一个节点定义为倒数第一个节点</span><span class="hljs-comment">//1-&gt;2-&gt;3-&gt;4-&gt;5</span><span class="hljs-comment">//p     s</span><span class="hljs-comment">//      p     s</span><span class="hljs-comment">//eg.寻找倒数第3个节点 k-1=2</span><span class="hljs-comment">//要想一次遍历找到倒数第k个节点，关键在于最后一个节点与倒数第k个节点之间相差k-1个节点</span><span class="hljs-comment">//所以要保证两个指针之间一直保持k-1个节点差</span><span class="hljs-comment">//健壮性：</span><span class="hljs-comment">//1.传入空指针</span><span class="hljs-comment">//2.k为无符号正数，k&lt;1</span><span class="hljs-comment">//3.不存在倒数第k个节点</span><span class="hljs-comment">/*节点结构体定义</span><span class="hljs-comment">struct ListNode &#123;</span><span class="hljs-comment">int val;</span><span class="hljs-comment">struct ListNode *next;</span><span class="hljs-comment">ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">public</span>:ListNode* FindKthToTail(ListNode* pListHead, unsigned <span class="hljs-keyword">int</span> k) &#123;<span class="hljs-keyword">if</span> (pListHead == <span class="hljs-keyword">NULL</span> || k &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">NULL</span>;<span class="hljs-comment">//传入空指针、k无效</span>ListNode *p = pListHead;ListNode *s = pListHead;<span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录s指针移动的次数</span><span class="hljs-keyword">while</span> (s-&gt;next != <span class="hljs-keyword">NULL</span>)<span class="hljs-comment">//直到遍历完此链表</span>&#123;s = s-&gt;next;++num;<span class="hljs-comment">//当s移动次数大于等于k时，才能让p开始移动，此时两指针保持k-1距离</span><span class="hljs-keyword">if</span> (num &gt;= k) p = p-&gt;next;&#125;<span class="hljs-comment">//如果s移动次数都小于两者必须的间距，说明不存在倒数第k个节点</span><span class="hljs-keyword">if</span> (num &lt; k - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">NULL</span>;<span class="hljs-keyword">return</span> p;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（13）调整数组顺序使奇数位于偶数前面</title>
    <link href="/2020/06/28/adjust-the-array-order-so-that-odd-numbers-are-in-front-of-even-numbers/"/>
    <url>/2020/06/28/adjust-the-array-order-so-that-odd-numbers-are-in-front-of-even-numbers/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs arduino"><span class="hljs-comment">//很奇怪，竟然加了“保证奇数和奇数，偶数和偶数之间的相对位置不变。”这个条件→_→</span><span class="hljs-comment">//如果加了这个条件，目前想到的是开辟一个新的vector从array中遍历</span><span class="hljs-comment">//第一次遍历，将奇数push，第二次遍历再将偶数push</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reOrderArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;<span class="hljs-built_in">array</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">array</span>.<span class="hljs-built_in">size</span>(); ++i)<span class="hljs-comment">//array为空直接跳出</span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i] &amp; <span class="hljs-number">0x1</span>)res.push_back(<span class="hljs-built_in">array</span>[i]);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">array</span>.<span class="hljs-built_in">size</span>(); i++)<span class="hljs-comment">//array为空直接跳出</span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)res.push_back(<span class="hljs-built_in">array</span>[i]);&#125;<span class="hljs-built_in">array</span> = res;&#125;&#125;;<span class="hljs-comment">//如果不考虑“保证奇数和奇数，偶数和偶数之间的相对位置不变。”这个条件</span><span class="hljs-comment">//维护两个指针/迭代器，itp寻找下一个最近的偶数，its寻找前一个最近的奇数</span><span class="hljs-comment">//当itp &gt; its时，说明全部奇数都在偶数前面</span><span class="hljs-comment">//特殊情况：</span><span class="hljs-comment">//当its - itp == 1时，不需要再交换</span><span class="hljs-comment">//全部为奇数</span><span class="hljs-comment">//全部为偶数</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reOrderArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;<span class="hljs-built_in">array</span>)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = <span class="hljs-built_in">array</span>.<span class="hljs-built_in">size</span>();<span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> == <span class="hljs-number">0</span> || <span class="hljs-built_in">size</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//为空或只有一个元素时</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator itp = <span class="hljs-built_in">array</span>.<span class="hljs-built_in">begin</span>();<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator its = <span class="hljs-built_in">array</span>.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (itp &lt; its)<span class="hljs-comment">//保证还有数字未调整</span>&#123;<span class="hljs-comment">//寻找下一个偶数，</span><span class="hljs-keyword">while</span> (itp != <span class="hljs-built_in">array</span>.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span> &amp;&amp; *itp &amp; <span class="hljs-number">0x1</span>) ++itp;<span class="hljs-comment">//寻找下一个奇数</span><span class="hljs-keyword">while</span> (its != <span class="hljs-built_in">array</span>.<span class="hljs-built_in">begin</span>() &amp;&amp; !(*its &amp; <span class="hljs-number">0x1</span>)) --its;<span class="hljs-comment">//判断是否itp剩下的全为奇数或its剩下的全为偶数</span><span class="hljs-keyword">if</span> (itp == <span class="hljs-built_in">array</span>.<span class="hljs-built_in">end</span>() || its == <span class="hljs-built_in">array</span>.<span class="hljs-built_in">begin</span>()) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(itp &lt; its)<span class="hljs-comment">//保证非its - itp == 1的情况</span>&#123;tmp = *itp;*itp = *its;*its = tmp;&#125;&#125;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（12）数值的整数次方</title>
    <link href="/2020/06/28/numerical-integer-power/"/>
    <url>/2020/06/28/numerical-integer-power/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">//方法一：循环</span><span class="hljs-comment">//此题不需要考虑计算后值溢出的情况，即不存在大数情况</span><span class="hljs-comment">//异常情况：</span><span class="hljs-comment">//底数为0时-&gt;0.0</span><span class="hljs-comment">//指数为0时-&gt;1.0(数学定义)</span><span class="hljs-comment">//指数为负数时，需要考虑先计算指数绝对值的结果，再取倒数</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">double</span> Power(<span class="hljs-built_in">double</span> base, <span class="hljs-built_in">int</span> exponent)&#123;<span class="hljs-comment">//底数为0时，因为base为double类型，所以需要进行范围判断</span><span class="hljs-keyword">if</span> (base - <span class="hljs-number">0</span> &lt;= <span class="hljs-number">0.0000001</span> &amp;&amp; base - <span class="hljs-number">0</span> &gt;= <span class="hljs-number">-0.0000001</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<span class="hljs-keyword">if</span> (exponent == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<span class="hljs-comment">//指数为0，return</span><span class="hljs-built_in">double</span> res = base;<span class="hljs-built_in">int</span> unsigned_exponent = abs(exponent);<span class="hljs-comment">//先取绝对值，考虑exp为负</span><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">2</span>; i &lt;= unsigned_exponent; ++i)&#123;res *= base;&#125;<span class="hljs-keyword">if</span> (exponent &lt; <span class="hljs-number">0</span>) res = <span class="hljs-number">1.0</span> / res;<span class="hljs-comment">//exp为负数时，取res的倒数</span><span class="hljs-keyword">return</span> res;&#125;&#125;;<span class="hljs-comment">//方法二：递归</span><span class="hljs-comment">//计算的指数若为n，则只需计算指数为(n/2)时的值，用这个值再平方就可以得到指数为n的值</span><span class="hljs-comment">//注意：</span><span class="hljs-comment">//n为奇数时。需要再乘以一个base，因为(n/2)向下取整</span><span class="hljs-comment">//exponent还是先计算为正数的情况，之后再判断是否求倒数</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">double</span> unsignedPower(<span class="hljs-built_in">double</span> base, <span class="hljs-built_in">int</span> exponent)&#123;<span class="hljs-keyword">if</span> (exponent == <span class="hljs-number">1</span>)<span class="hljs-comment">//指数为1，return base</span><span class="hljs-keyword">return</span> base;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exponent == <span class="hljs-number">0</span>)<span class="hljs-comment">//指数为0，return 1</span><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-built_in">double</span> res = unsignedPower(base, exponent &gt;&gt; <span class="hljs-number">1</span>);<span class="hljs-comment">//右移一位-&gt;除2</span>res *= res;<span class="hljs-comment">//再平方，减少运算次数</span><span class="hljs-keyword">if</span> (exponent &amp; <span class="hljs-number">0x1</span>) res *= base;<span class="hljs-comment">//判断指数是否为奇数，与1异或-&gt;模2</span><span class="hljs-keyword">return</span> res;&#125;<span class="hljs-built_in">double</span> Power(<span class="hljs-built_in">double</span> base, <span class="hljs-built_in">int</span> exponent)&#123;<span class="hljs-comment">//判断底数是否为0</span><span class="hljs-keyword">if</span> (base - <span class="hljs-number">0</span> &lt;= <span class="hljs-number">0.0000001</span> &amp;&amp; base - <span class="hljs-number">0</span> &gt;= <span class="hljs-number">-0.0000001</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<span class="hljs-keyword">if</span> (exponent == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>; <span class="hljs-comment">//判断指数是否为0</span><span class="hljs-keyword">if</span> (exponent &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / unsignedPower(base, abs(exponent));<span class="hljs-comment">//负指数应求倒数</span><span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> unsignedPower(base, abs(exponent));&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（11）二进制中1的个数</title>
    <link href="/2020/06/28/the-number-of-1s-in-binary/"/>
    <url>/2020/06/28/the-number-of-1s-in-binary/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">//方法一</span><span class="hljs-comment">//使测试数据x中只有一个1，逐步右移，使这个1从数值最低位到数值最高位与n依次比较</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">int</span> NumberOf1(<span class="hljs-built_in">int</span> n) &#123;<span class="hljs-built_in">int</span> x = <span class="hljs-number">1</span>;<span class="hljs-built_in">int</span> num = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; sizeof(<span class="hljs-built_in">int</span>)*<span class="hljs-number">8</span>; ++i)<span class="hljs-comment">//计算x的位数</span>&#123;<span class="hljs-keyword">if</span> (n &amp; x) ++num;<span class="hljs-comment">//n与x进行位与运算</span>x = x &lt;&lt; <span class="hljs-number">1</span>;<span class="hljs-comment">//x右移1位</span>&#125;<span class="hljs-keyword">return</span> num;&#125;&#125;;<span class="hljs-comment">//方法二</span><span class="hljs-comment">//数字0中没有1</span><span class="hljs-comment">//非0数字中一定有1</span><span class="hljs-comment">//将n = n-1使其最低位的1变零，此位之前的位不受影响，此位之后的位全从0变1</span><span class="hljs-comment">//如果n此时不为0，说明还有1存在，重复上步骤。</span><span class="hljs-comment">//如果n = 0时，1的个数计算完毕，return。</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">int</span> NumberOf1(<span class="hljs-built_in">int</span> n)&#123;<span class="hljs-built_in">int</span> num = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>)<span class="hljs-comment">//n中还有1存在</span>&#123;++num;n = n &amp; (n - <span class="hljs-number">1</span>);<span class="hljs-comment">//进行位与计算，使此位的1变0</span>&#125;<span class="hljs-keyword">return</span> num;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（10）矩形覆盖</title>
    <link href="/2020/06/28/rectangle-cover/"/>
    <url>/2020/06/28/rectangle-cover/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">//有两种放置方法</span><span class="hljs-comment">//1.左边竖着放一个，则还剩下2*(n-1)</span><span class="hljs-comment">//2.左上角横着放一个，相应左下角也横着放一个，则还剩下2*(n-2)</span><span class="hljs-comment">//f(n) = f(n-1) + f(n-2)</span><span class="hljs-comment">//特殊情况：不存在时返回0；2*1时只有竖着放一种情况；2*2时两种情况</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">int</span> rectCover(<span class="hljs-built_in">int</span> number)&#123;<span class="hljs-keyword">if</span> (number &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//特殊情况</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(number == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (number == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>, tmp = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">3</span>; i &lt;= number; ++i)&#123;tmp = a + b;a = b;b = tmp;&#125;<span class="hljs-keyword">return</span> tmp;&#125;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（9）变态跳台阶</title>
    <link href="/2020/06/28/abnormal-jump-step/"/>
    <url>/2020/06/28/abnormal-jump-step/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">//有n级台阶</span><span class="hljs-comment">//若跳1级则剩下n-1级，跳法f(n-1)</span><span class="hljs-comment">//若跳2级则剩下n-2级，跳法f(n-2)</span><span class="hljs-comment">//若跳3级则剩下n-3级，跳法f(n-3)</span><span class="hljs-comment">//若跳n-级则剩下1级，跳法f(n-(n-1))，即剩下一个台阶</span><span class="hljs-comment">//若跳n级则剩下0级，跳法f(0)，即为1种方法</span><span class="hljs-comment">//f(n) = 1 + f(n-1) + f(n-2) + ... +f (1)</span><span class="hljs-comment">//f(1) = 1</span><span class="hljs-comment">//f(2) = 1 + f(1) = 2；</span><span class="hljs-comment">//f(3) = 1 + f(2) + f(1) = 4...</span><span class="hljs-comment">//以此类推</span><span class="hljs-comment">//f(n) = 2^(n-1)</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">int</span> jumpFloorII(<span class="hljs-built_in">int</span> number)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &lt;&lt; --number;<span class="hljs-comment">//左移n-1位</span>&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（8）跳台阶</title>
    <link href="/2020/06/28/jump-the-stairs/"/>
    <url>/2020/06/28/jump-the-stairs/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">//两种跳跃方式：跳1级或跳2级</span><span class="hljs-comment">//假设有n级台阶，跳1级还剩余n-1级，跳2级还剩余n-2级，那剩余台阶继续选择跳法</span><span class="hljs-comment">//f(n) = f(n-1) + f(n-2) -&gt; 斐波那契数列</span><span class="hljs-comment">//n = 1时，1</span><span class="hljs-comment">//n = 2时，2</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">int</span> jumpFloor(<span class="hljs-built_in">int</span> n)&#123;        <span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>, tmp = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//特殊情况只有1级台阶</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-comment">//特殊情况只有2级台阶</span><span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; ++i)&#123;tmp = a + b;a = b;b = tmp;&#125;<span class="hljs-keyword">return</span> b;&#125;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（7）斐波那契数列</title>
    <link href="/2020/06/28/fibonacci-sequence/"/>
    <url>/2020/06/28/fibonacci-sequence/</url>
    
    <content type="html"><![CDATA[<p><strong>题目说明：</strong></p><blockquote><p><strong>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">//0 1 1 2 3 5 8 13 21...</span><span class="hljs-comment">//简洁的递归，但是注意消除重复计算项，采用map存储已计算的n的value</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:map&lt;<span class="hljs-built_in">int</span>, long long&gt; m;long long num;<span class="hljs-built_in">int</span> Fibonacci(<span class="hljs-built_in">int</span> n) &#123;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span>&#123;map&lt;<span class="hljs-built_in">int</span>, long long&gt;::iterator it = m.find(n);<span class="hljs-comment">//查找是否已计算过</span><span class="hljs-keyword">if</span> (m.end() == it)<span class="hljs-comment">//之前没算过，进行计算，再insert</span>&#123;num = Fibonacci(n - <span class="hljs-number">1</span>) + Fibonacci(n - <span class="hljs-number">2</span>);m.insert(pair&lt;<span class="hljs-built_in">int</span>, long long&gt;(n, num));<span class="hljs-keyword">return</span> num;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> it-&gt;second;<span class="hljs-comment">//若之前算过，直接get second</span>&#125;&#125;&#125;;<span class="hljs-comment">//O(n)的循环方法，没有什么好解释的...→_→</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">int</span> Fibonacci(<span class="hljs-built_in">int</span> n) &#123;long long res[<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span> &#125;;long long tmp = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)&#123;<span class="hljs-comment">//空瓶子swap</span>tmp = res[<span class="hljs-number">0</span>] + res[<span class="hljs-number">1</span>];res[<span class="hljs-number">0</span>] = res[<span class="hljs-number">1</span>];res[<span class="hljs-number">1</span>] = tmp;&#125;<span class="hljs-keyword">return</span> res[<span class="hljs-number">1</span>];&#125;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（6）旋转数组的最小数字</title>
    <link href="/2020/06/28/rotate-the-smallest-number-of-an-array/"/>
    <url>/2020/06/28/rotate-the-smallest-number-of-an-array/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</strong><br>   <strong>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。</strong><br>   <strong>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。</strong><br>   <strong>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs arduino"><span class="hljs-comment">//&#123;3,4,5,1,2&#125;</span><span class="hljs-comment">// l   m   r</span><span class="hljs-comment">//规律：一般前旋转区的数大于等于后旋转区的数</span><span class="hljs-comment">//注意特殊情况</span><span class="hljs-comment">//1.旋转数为0个，即未旋转，此时rotateArray[0]为min</span><span class="hljs-comment">//2.&#123;0,1,1,1,1&#125;-&gt;&#123;1,1,1,0,1&#125;</span><span class="hljs-comment">//                l   m   r 此时无法判断middle在前旋转区还是后旋转区</span><span class="hljs-comment">//O(logn)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-comment">//遍历vector</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">searchInRotateArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; rotateArray)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = rotateArray.<span class="hljs-built_in">begin</span>();<span class="hljs-keyword">int</span> <span class="hljs-built_in">min</span> = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (; it != rotateArray.<span class="hljs-built_in">end</span>(); ++it)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span> &gt; *it) <span class="hljs-built_in">min</span> = *it;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minNumberInRotateArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; rotateArray)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (rotateArray.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//数组异常</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator itleft = rotateArray.<span class="hljs-built_in">begin</span>();<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator itright = rotateArray.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator itmiddle = itleft;<span class="hljs-comment">//防止未旋转情况</span><span class="hljs-comment">//第一次循环条件不满足时，即为未旋转情况，直接return</span><span class="hljs-keyword">while</span> (*itleft &gt;= *itright)&#123;itmiddle = itleft + (itright - itleft)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> (itright - itleft == <span class="hljs-number">1</span>)<span class="hljs-comment">//相邻时itright即为min</span>&#123;itmiddle = itright;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-comment">//当l==m==r时，只能采取遍历方式寻找min</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*itleft == *itright &amp;&amp; *itleft == *itmiddle)<span class="hljs-keyword">return</span> searchInRotateArray(rotateArray);<span class="hljs-comment">//此时min在后旋转区</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*itleft &lt;= *itmiddle) itleft = itmiddle;<span class="hljs-comment">//此时min在前旋转区</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*itright &gt;= *itmiddle) itright = itmiddle;&#125;<span class="hljs-keyword">return</span> *itmiddle;&#125;&#125;;<span class="hljs-comment">//嘿嘿...直接sort，费这老鼻子劲→_→</span><span class="hljs-comment">//O(n)</span><span class="hljs-comment">/*</span><span class="hljs-comment">#include &lt;algorithm&gt;</span><span class="hljs-comment">class Solution &#123;</span><span class="hljs-comment">public:</span><span class="hljs-comment">int minNumberInRotateArray(vector&lt;int&gt; rotateArray)</span><span class="hljs-comment">&#123;</span><span class="hljs-comment">sort(rotateArray.begin(), rotateArray.end());</span><span class="hljs-comment">return rotateArray[0];</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（5）用两个栈实现队列</title>
    <link href="/2020/06/28/implement-queue-with-two-stacks/"/>
    <url>/2020/06/28/implement-queue-with-two-stacks/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs arduino"><span class="hljs-comment">//栈：先进后出 队列：先进先出</span><span class="hljs-comment">//注意最后一个元素的转移优化</span><span class="hljs-comment">//两个队列实现一个栈</span><span class="hljs-comment">//stack1负责入栈，stack2负责出栈</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span> </span><span class="hljs-function"></span>&#123;stack1.push(node);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (!stack2.empty())<span class="hljs-comment">//stack2不为空，说明有数据，可以直接pop</span>&#123;x = stack2.top();stack2.pop();&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//否则将stack1中的除最后一个的其余数据先pop再依次push到stack2中</span><span class="hljs-keyword">while</span> (!stack1.empty())&#123;x = stack1.top();<span class="hljs-keyword">if</span> (stack1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)&#123;stack1.pop();<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span>&#123;stack1.pop();stack2.push(x);&#125;&#125;&#125;<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-keyword">private</span>:<span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; stack1;<span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; stack2;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（4）重建二叉树</title>
    <link href="/2020/06/28/rebuild-binary-tree/"/>
    <url>/2020/06/28/rebuild-binary-tree/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs reasonml"><span class="hljs-comment">//前序中序、后序中序都可以重建二叉树，但前序后序不可以，因为只有中序可以区分左子树与右子树</span><span class="hljs-comment">/*</span><span class="hljs-comment">pre:&#123;1,2,4,7,3,5,6,8&#125;</span><span class="hljs-comment">vin:&#123;4,7,2,1,5,3,8,6&#125;</span><span class="hljs-comment">*/</span><span class="hljs-comment">//Definition for binary tree</span><span class="hljs-comment">/*</span><span class="hljs-comment">struct TreeNode</span><span class="hljs-comment">&#123;</span><span class="hljs-comment">    int val;</span><span class="hljs-comment">    TreeNode *left;</span><span class="hljs-comment">    TreeNode *right;</span><span class="hljs-comment">    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-keyword">class</span> Solution&#123;public:    TreeNode* re<span class="hljs-constructor">ConstructBinaryTree(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt; <span class="hljs-params">pre</span>, <span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt; <span class="hljs-params">vin</span>)</span>    &#123;    <span class="hljs-comment">//判断异常情况：前序为空或后序为空或两者个数不同</span>        <span class="hljs-keyword">if</span> (pre.size<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> || </span>vin.size<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> || </span>pre.size<span class="hljs-literal">()</span> != vin.size<span class="hljs-literal">()</span>)         return NULL;        <span class="hljs-keyword">else</span> <span class="hljs-comment">//调用递归函数</span>        return <span class="hljs-constructor">ConstructBinaryTree(<span class="hljs-params">pre</span>.<span class="hljs-params">begin</span>()</span>, vin.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>, pre.size<span class="hljs-literal">()</span>);    &#125;     TreeNode* <span class="hljs-constructor">ConstructBinaryTree(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;::<span class="hljs-params">iterator</span> <span class="hljs-params">itp</span>, <span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;::<span class="hljs-params">iterator</span> <span class="hljs-params">itv</span>, <span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span>    &#123;        TreeNode *s = NULL;        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)        &#123;            s = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-operator">*</span><span class="hljs-params">itp</span>)</span>;            <span class="hljs-comment">//在中序序列中寻找根结点的对应下标</span>            <span class="hljs-built_in">int</span> index = <span class="hljs-constructor">FindIndex(<span class="hljs-params">itv</span>, <span class="hljs-params">n</span>, <span class="hljs-operator">*</span><span class="hljs-params">itp</span>)</span>;            <span class="hljs-keyword">if</span> (index<span class="hljs-operator"> == </span>-<span class="hljs-number">1</span>) exit<span class="hljs-number">(-1)</span>;<span class="hljs-comment">//未找到数字，序列错误</span>            <span class="hljs-comment">//缩小节点的范围，仅限s的左子树，注意下标和个数的变化</span>            s-&gt;left = <span class="hljs-constructor">ConstructBinaryTree(<span class="hljs-params">itp</span> + 1, <span class="hljs-params">itv</span>, <span class="hljs-params">index</span>)</span>;            <span class="hljs-comment">//缩小节点的范围，仅限s的右子树</span>            s-&gt;right = <span class="hljs-constructor">ConstructBinaryTree(<span class="hljs-params">itp</span> + <span class="hljs-params">index</span> + 1, <span class="hljs-params">itv</span> + <span class="hljs-params">index</span> + 1, <span class="hljs-params">n</span> - <span class="hljs-params">index</span> - 1)</span>;        &#125;        return s;    &#125;    <span class="hljs-built_in">int</span> <span class="hljs-constructor">FindIndex(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;::<span class="hljs-params">iterator</span> <span class="hljs-params">itv</span>, <span class="hljs-params">int</span> <span class="hljs-params">n</span>, <span class="hljs-params">int</span> <span class="hljs-params">x</span>)</span>    &#123;        for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i, ++itv)        &#123;            <span class="hljs-keyword">if</span> (*itv<span class="hljs-operator"> == </span>x) return i;        &#125;        return -<span class="hljs-number">1</span>;<span class="hljs-comment">//未找到返回-1</span>    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（3）从尾到头打印链表</title>
    <link href="/2020/06/28/print-a-linked-list-from-end-to-end/"/>
    <url>/2020/06/28/print-a-linked-list-from-end-to-end/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一个链表，从尾到头打印链表每个节点的值。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs reasonml"><span class="hljs-comment">//可以使用stack的先进后出，也可以使用递归，因为已给定函数所以使用递归</span><span class="hljs-comment">//本题的在线测试用例是无头链表→_→</span><span class="hljs-comment">/*节点结构体</span><span class="hljs-comment">struct ListNode </span><span class="hljs-comment">&#123;</span><span class="hljs-comment">int val;</span><span class="hljs-comment">    struct ListNode *next;</span><span class="hljs-comment">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-keyword">class</span> Solution&#123;public:vector&lt;<span class="hljs-built_in">int</span>&gt; print<span class="hljs-constructor">ListFromTailToHead(ListNode<span class="hljs-operator">*</span> <span class="hljs-params">head</span>)</span>&#123;vector&lt;<span class="hljs-built_in">int</span>&gt; v;<span class="hljs-comment">//判断是否为空，不为空调用递归函数</span><span class="hljs-keyword">if</span> (head != NULL) <span class="hljs-constructor">ListFromTailToHead(<span class="hljs-params">head</span>, <span class="hljs-params">v</span>)</span>;return v;&#125;<span class="hljs-comment">//递归函数传参为指向当前结点的指针和存储value的vector引用，因为vector需要共同使用</span>void <span class="hljs-constructor">ListFromTailToHead(ListNode <span class="hljs-operator">*</span><span class="hljs-params">p</span>, <span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt; &amp;<span class="hljs-params">vec</span>)</span>&#123;<span class="hljs-comment">//当前指针不为空时说明节点存在</span><span class="hljs-keyword">if</span> (p != NULL)&#123;<span class="hljs-constructor">ListFromTailToHead(<span class="hljs-params">p</span>-&gt;<span class="hljs-params">next</span>, <span class="hljs-params">vec</span>)</span>;<span class="hljs-comment">//先递归后压value</span>vec.push<span class="hljs-constructor">_back(<span class="hljs-params">p</span>-&gt;<span class="hljs-params">val</span>)</span>;&#125;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（2）替换空格</title>
    <link href="/2020/06/27/replace-spaces/"/>
    <url>/2020/06/27/replace-spaces/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。在此字符串上完成替换，空间保证足够。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs hsp"><span class="hljs-comment">//"We Are Happy"</span><span class="hljs-comment">//" helloworld"</span><span class="hljs-comment">//""</span><span class="hljs-comment">//"  "</span>class Solution &#123;public:void replaceSpace(char *<span class="hljs-keyword">str</span>, <span class="hljs-keyword">int</span> <span class="hljs-keyword">length</span>) &#123;<span class="hljs-comment">//判断异常情况</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">str</span> == NULL || *<span class="hljs-keyword">str</span> == NULL || <span class="hljs-keyword">length</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span><span class="hljs-comment">;</span><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span><span class="hljs-comment">;</span><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span><span class="hljs-comment">;</span><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-keyword">length</span>)<span class="hljs-comment">//遍历统计' '个数</span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">str</span>[i] == <span class="hljs-string">' '</span>) ++num<span class="hljs-comment">;</span>++i<span class="hljs-comment">;</span>&#125;i = <span class="hljs-keyword">length</span> - <span class="hljs-number">1</span><span class="hljs-comment">;//将i移动到str最后一个字符位置</span><span class="hljs-keyword">length</span> = <span class="hljs-keyword">length</span> + num * <span class="hljs-number">2</span> - <span class="hljs-number">1</span><span class="hljs-comment">;//将length移动到替换后最后一个字符位置</span><span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">str</span>[i] != <span class="hljs-string">' '</span>)<span class="hljs-comment">//非' '时正常移动</span>&#123;<span class="hljs-keyword">str</span>[<span class="hljs-keyword">length</span>] = <span class="hljs-keyword">str</span>[i]<span class="hljs-comment">;</span>--<span class="hljs-keyword">length</span><span class="hljs-comment">;</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">length</span> -= <span class="hljs-number">3</span><span class="hljs-comment">;//否则将length先前移动三个字节完成替换</span><span class="hljs-keyword">str</span>[<span class="hljs-keyword">length</span> + <span class="hljs-number">1</span>] = <span class="hljs-string">'%'</span><span class="hljs-comment">;</span><span class="hljs-keyword">str</span>[<span class="hljs-keyword">length</span> + <span class="hljs-number">2</span>] = <span class="hljs-string">'2'</span><span class="hljs-comment">;</span><span class="hljs-keyword">str</span>[<span class="hljs-keyword">length</span> + <span class="hljs-number">3</span>] = <span class="hljs-string">'0'</span><span class="hljs-comment">;</span>&#125;--i<span class="hljs-comment">;</span>&#125;&#125;&#125;<span class="hljs-comment">;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（1）二维数组中的查找</title>
    <link href="/2020/06/27/find-in-a-two-dimensional-array/"/>
    <url>/2020/06/27/find-in-a-two-dimensional-array/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">/*</span><span class="hljs-comment">1 2 8  9</span><span class="hljs-comment">2 4 9  12</span><span class="hljs-comment">4 7 10 13</span><span class="hljs-comment">6 8 11 15</span><span class="hljs-comment">*/</span><span class="hljs-comment">//从右上角或左下角突破，时间复杂度O(n)</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">bool</span> Find(<span class="hljs-built_in">int</span> target, vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; <span class="hljs-built_in">array</span>)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>.empty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//为空结束</span><span class="hljs-comment">//获取行、列数</span><span class="hljs-built_in">int</span> row = <span class="hljs-built_in">array</span>.size();<span class="hljs-built_in">int</span> col = <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>].size()；<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> j = col - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> ((i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; row) &amp;&amp; (j &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; col))<span class="hljs-comment">//防止越界</span>&#123;<span class="hljs-comment">//说明array[i][y]此行右边和此列下方的数都大于target</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i][j] &gt; target)--j;<span class="hljs-comment">//找到返回true</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i][j] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//说明array[i][j]此行左边的数和此列上方的数都小于target</span><span class="hljs-keyword">else</span>++i;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//没找到返回false</span>&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节序</title>
    <link href="/2020/06/27/endianness/"/>
    <url>/2020/06/27/endianness/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>字节序是何物。。。？</em> *</strong></p><blockquote><p><strong>小人国的内战源于吃水煮鸡蛋时究竟是从大头敲开还是从小头敲开，因此曾发生过6次叛乱，其中一个皇帝送了命，另一个丢了王位。</strong></p></blockquote><p>不同的计算机体系结构中，可能采用不同的存储和传输机制，通常采用的<strong>字节存储机制</strong>主要有两种：<strong>大端（Big-endian）</strong>和<strong>小端（Little-endian）</strong>。</p><ul><li><p><strong>最重要的位或最重要的字节（MSB，Most Significant Bit/Byte）</strong>，表明在一个bit序列或一个byte序列中对整个序列取值影响最大的那个bit/byte。</p></li><li><p><strong>最不重要的位或最不重要的字节（LSB，Least Significant Bit/Byte）</strong>，表明在一个bit序列或一个byte序列中对整个序列取值影响最小的那个bit/byte。</p></li></ul><p>Big-endian规定<strong>MSB在存储时放在低地址，在传输时MSB放在流的开始</strong>。<strong>LSB存储时放在高地址，在传输时放在流的末尾</strong>。目前的PowerPC系列处理器、<strong>TCP/IP网络</strong>及<strong>Java虚拟机</strong>的字节序为Big-endian。<br>Little-endian规定与之相反。目前的Intel的<strong>x86系列</strong>及衍生CPU的字节序为Little-endian。</p><pre><code class="hljs cpp"><span class="hljs-comment">//判断机器采用何种存储机制</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> i = <span class="hljs-number">0x12345678</span>;<span class="hljs-keyword">if</span> (<span class="hljs-number">0x78</span> == (<span class="hljs-keyword">char</span>)i)<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Little-endian"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Big-endian"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDI3MTkxNjA4OTUy?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="监视"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDI3MTkxNjQxNDM3?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="内存"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDI3MTkxNzA0OTYz?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="Little-endian"></p><p><strong>* <em>鉴定完毕。。。牙膏厂果然是Little-endian。。。</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——目标文件（3）</title>
    <link href="/2020/06/27/object-file-3/"/>
    <url>/2020/06/27/object-file-3/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>总结的速度，追不上看书的速度了。。。</em> *</strong></p><h1 id="第三章-目标文件里面有什么"><a href="#第三章-目标文件里面有什么" class="headerlink" title="第三章 目标文件里面有什么"></a>第三章 目标文件里面有什么</h1><blockquote><p><strong>ELF文件的基本结构是什么样子？</strong></p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDI2MTg0NTQzNzgx?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="图3.6 ELF文件结构"></p><p>ELF目标文件的最前部是ELF <strong>文件头（ELF Header）</strong>，其包含<strong>描述整个文件的基本属性</strong>，如ELF文件版本、目标机器型号、程序入口地址等。接着是各段。之后为<strong>段表（Section Header Table）</strong>，该表<strong>描述了ELF文件包含的所有段的信息</strong>，如短的段名、段的长度、在文件中的偏移、读写权限及段的其他属性。</p><ol><li><p>ELF文件头中定义了<strong>ELF魔数</strong>、<strong>文件机器字节长度</strong>、<strong>数据存储方式</strong>、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、<strong>入口地址</strong>、<strong>程序头入口和长度</strong>、<strong>段表的位置和长度及段的数量</strong>。ELF文件头结构及相关常数被定义在“<strong>/usr/include/elf.h</strong>”。</p><pre><code class="hljs cpp"><span class="hljs-comment">//32位文件结构头</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> e_ident[<span class="hljs-number">16</span>];<span class="hljs-comment">//魔数</span> ELF32_Half e_type;<span class="hljs-comment">//文件类型</span> ELF32_Half e_machine;<span class="hljs-comment">//平台属性</span> ELF32_Word e_version;<span class="hljs-comment">//版本号</span> ELF32_Addr e_entry;<span class="hljs-comment">//入口虚拟地址</span> ELF32_Off e_phoff; ELF32_Off e_shoff;<span class="hljs-comment">//段表在文件中的偏移</span> ELF32_Word e_flags; ELF32_Half e_ehsize; ELF32_Half e_phentsize; ELF32_Half e_phnum; ELF32_Half e_shentsize;<span class="hljs-comment">//段表描述符大小，一般为sizeof(Elf32_Shdr)</span> ELF32_Half e_shnum;<span class="hljs-comment">//段描述符数量，等于文件中拥有段的数量</span> <span class="hljs-comment">//Seciton header sting table index</span> ELF32_Half e_shstrndx;<span class="hljs-comment">//段表字符串表所在的段在段表中的下标</span>&#125;ELF32_Ehdr;</code></pre></li></ol><ul><li>ELF文件头最前面的“<strong>Magic</strong>”的16个字节对应“ELF32_Ehdr“的e_ident成员，用来标识ELF文件的平台属性。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDI3MTE0MDU2NzUy?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="ELF魔数"></li><li>前四个字节为ELF文件<strong>统一标识码</strong>，为0x7F、0x45、0x4c、0x46.分别对应ASCII字符中的DEL控制符、E、L、F。第五个字节用来标识<strong>ELF文件类</strong>。第六个字节规定ELF文件<strong>大小端</strong>。第七个字节规定ELF文件主版本号。后九个未定义，填0。</li></ul><ol start="2"><li><p><strong>段表（Section Header Table）</strong>保存着段的基本属性的结构，它描述了各段的信息，如段的段名、段的长度、在文件中的偏、读写权限及段的其他属性。<strong>段结构由段表决定，编译器、连接器依靠段表定位和访问各段的属性。段表的位置由文件头的”e_shoff“决定。</strong></p><pre><code class="hljs cpp"><span class="hljs-comment">//段描述符结构</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span><span class="hljs-comment">//段名是一个字符串，位于.shstrtab字符串表。sh_name是段名字符串在.shstrtab中的偏移</span>Elf32_Word sh_name;Elf32_Word sh_type;<span class="hljs-comment">//段的类型</span>Elf32_Word sh_flags;<span class="hljs-comment">//段的标志位</span><span class="hljs-comment">//段虚拟地址，若该段可以被加载则sh_addr为该段被加载后在进程地址空间中的虚拟的地址；否则为0</span>Elf32_Addr sh_addr;<span class="hljs-comment">//段偏移，如果该段存在于文件中，则表示该段在文件中的偏移，否则无意义如.bss段</span>Elf32_Off sh_offset;Elf32_Word sh_size;<span class="hljs-comment">//段的长度</span>Elf32_Word sh_link;<span class="hljs-comment">//段链接信息</span>Elf32_Word sh_info;<span class="hljs-comment">//段链接信息</span><span class="hljs-comment">//段地址对齐，地址对齐的数量都是2的指数倍，sh_addralign表示地址对齐数量中的指数</span>Elf32_Word sh_addralign;<span class="hljs-comment">//项的长度，有些段包含固定大小的项，如符号表所包含的每个符号大小一样；若不包含固定大小的项，则为0</span>Elf32_Word sh_entsize;&#125;Elf32_Shdr;</code></pre><ul><li>段表是一个以”<strong>Elf32_Shdr</strong>“ ——<strong>段描述符（Section Description）</strong>结构体为元素的<strong>数组</strong>。<strong>数组元素的个数等于段的个数</strong>，每个”Elf32_Shdr“结构体对应一个段。<strong>ELF段表的数组的第一个元素是无效的段描述符，其类型为NULL。</strong>Elf32_Shdr被定义在”/usr/include/elf.h“中</li></ul><p>更复杂的ELF文件结构：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDI3MTQ1MTQwOTg0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="更复杂的ELF文件结构">    </p></li><li><p><strong>重定位表（Relocation Table）</strong>，类型（sh_type）为”<strong>SHT_REL</strong>“。链接器在处理目标文件时，须要对目标文件中的某些部位进行重定位，即代码段和数据段中对绝对地址引用的位置<strong>。重定位信息都记录在重定位表中，每个须要重定位的段都会有一个相应的重定位表。</strong>一个重定位表同时也是ELF的一个段。</p></li><li><p>因为字符串的长度是不固定的，所以常见的表示方法是<strong>把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串</strong>。在ELF文件中<strong>引用字符串只须给出一个数字下标即可，不用考虑字符串长度的问题</strong>。<br>一般字符串表在ELF文件中以段的形式保存，常见段<strong>字符串表（String Table）”.strtab“</strong>和<strong>段表字符串表（Section Header String Table）”.shstrtab“</strong>。字符串表保存<strong>普通的字符串</strong>，如<strong>符号的名字</strong>；段表字符串表保存<strong>段表中用到的字符串</strong>，如<strong>段名（sh_name）</strong>。</p></li></ol><blockquote><p><strong>分析ELF文件头，得到段表和段表字符串表的位置，继而解析整个ELF文件</strong></p></blockquote><p><strong>* <em>下次就是静态链接了。。。Link！</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——目标文件（2）</title>
    <link href="/2020/06/27/object-file-2/"/>
    <url>/2020/06/27/object-file-2/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>逐个分析各段。。。</em> *</strong></p><h1 id="第三章-目标文件里面有什么"><a href="#第三章-目标文件里面有什么" class="headerlink" title="第三章 目标文件里面有什么"></a>第三章 目标文件里面有什么</h1><blockquote><p><strong>真正了不起的程序员对自己的程序的每一个字节都了如指掌。</strong> </p></blockquote><pre><code class="hljs cpp"><span class="hljs-comment">//Test.c</span><span class="hljs-keyword">int</span> global_init_var = <span class="hljs-number">84</span>;<span class="hljs-keyword">int</span> global_uninit_var;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> static_var = <span class="hljs-number">85</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> static_var2;<span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> bfunc1(static_var + static_var2 + a + b);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>示例程序中包括代码段、数据段、BSS段、只读数据段（.rodata）、注释信息段（.comment）。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDI2MTUwMzA1NzAw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="图3.4 目标文件组成"></p><ol><li><p><strong>代码段</strong>：</p><ul><li><strong>.text</strong>段中存放的是Test.c中函数func()和main()的<strong>指令</strong>。</li></ul></li><li><p><strong>数据段</strong>和<strong>只读数据段</strong>：</p><ul><li><strong>.data</strong>段保存<strong>初始化了的全局变量和局部静态变量</strong>（上述代码中的global_init_var和static_var）。</li></ul></li></ol><ul><li><p><strong>.rodata</strong>段存放<strong>只读数据</strong>，一般是程序的<strong>只读变量（const修饰的变量）</strong>和<strong>字符串常量</strong>（上述代码中”<strong>%d\n</strong>“是一种只读数据）。单独设立.rodata段从<strong>语义上支持C++的const关键字</strong>，也在加载时<strong>将属性映射成只读</strong>，保证安全性。有时编译器会把字符串常量放到.data段，而不会单独放在.rodata段。</p><ol start="3"><li><strong>BSS段</strong>：</li></ol></li><li><p><strong>.bss</strong>段中存放的是<strong>未初始化的全局变量和局部静态变量</strong>（上述代码中的global_uninit_var和static_var2），准确的说是.bss段为他们<strong>预留了空间</strong>。</p></li><li><p>有些编译器将未初始化的全局变量存放在目标文件.bss段，有些不存放只是<strong>预留一个未定义的全局变量符号”COMMON 符号“，到最终链接成可执行文件的时候再在.bss段·分配空间。</strong></p></li><li><p>但编译单元<strong>内部可见的静态变量</strong>（如·global_uninit_var加上static修饰），是存放在.bss段。</p></li><li><p><strong><code>static int x1 = 0;</code></strong></p></li></ul><p><strong>x1被放在.bss段，因为可以认为是未初始化的，所以被优化放在.bss段。</strong></p><ul><li><strong><code>static int x2 = 1;</code></strong></li></ul><p><strong>x2被放在.data段，因为初始化值为1，所以放在.data段。</strong></p><ol start="4"><li><p>其他段：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDI2MTgwNzEzMzI0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="图3.5 其他段"></p></li><li><p>自定义段：</p><ul><li><strong><code>_attribute_((section(&quot;FOO&quot;))) int global = 42;</code></strong></li></ul></li></ol><ul><li><strong><code>_attribute_((section(&quot;BAR&quot;))) void foo()</code></strong><br>在全局变量和函数之前加上<code>_attribute_((section(&quot;name&quot;)))</code>属性可以把相应的变量或函数放到以”name“作为的段中。</li></ul><p><strong>* <em>以上为主要段，下一次总结ELF文件结构，包括文件头、段表。。。</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——目标文件（1）</title>
    <link href="/2020/06/27/object-file-1/"/>
    <url>/2020/06/27/object-file-1/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>一直被催更。。。</em> *</strong></p><h1 id="第三章-目标文件里面有什么"><a href="#第三章-目标文件里面有什么" class="headerlink" title="第三章 目标文件里面有什么"></a>第三章 目标文件里面有什么</h1><blockquote><p>PC平台流行的<strong>可执行文件格式（Executable）</strong>主要为Windows下的<strong>PE（Portable</strong><br><strong>Executable）</strong>和Linux下的<strong>ELF（Executable Linkable</strong><br><strong>Format）</strong>，都是<strong>COFF（Common file format）</strong>格式的变种。</p></blockquote><p>编译器编译源代码后生成的目标文件，其结构已经是编译后的可执行文件格式，但还没有经过链接，有些符号或地址还未调整，所以一般跟可执行文件采用相同格式存储。<strong>在Windows下将它们统称为PE-COFF文件格式，在Linux下将它们统称为ELF文件。</strong></p><p> <strong>动态链接库（DLL，Dynamic Linking Library）</strong>（<strong>Windows的.dll和Linux的.so</strong>）、<strong>静态链接库（Static Linking Library）</strong>（<strong>Windows的.lib和Linux的.a</strong>）都按照可执行文件格式存储。<strong>静态链接库是把很多目标文件捆绑在一起形成一个文件再加上索引，简单理解为一个包含很多目标文件的文件包。</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDEyMTcxNTUxOTA0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="图3.1 ELF格式文件（1）"><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDEyMTcxNjE0NjI0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="图3.2 ELF格式文件（2）"></p><p>1.目标文件文件中至少包含编译后的机器指令代码、数据、链接时所需信息（如符号表、调试信息、 字符串等）。一般目标文件将这些信息按不同属性以“<strong>节</strong>”<strong>（Section）</strong>的形式存储，有时也叫<strong>段（Segment）</strong>（其实这两个是不同的角度的定义，看到后面时才理解），<strong>一般情况下他们都表示一个一定长度的区域。</strong></p><ul><li><p>程序源代码编译后的<strong>机器指令</strong>保存在<strong>代码段（Code Section，常见名字.code或.text）</strong></p></li><li><p><strong>初始化的全局变量</strong>和<strong>局部静态变量</strong>保存在<strong>数据段（Data Section，常见名字.data）</strong></p></li><li><p><strong>未初始化的全局变量</strong>和<strong>局部静态变量</strong>保存在<strong>.bss section</strong></p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDEyMTczMjM4ODE4?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="图3.3 程序与目标文件"></p></li><li><p><strong>ELF文件的文件头描述了整个文件的属性</strong>，包括文件是否可执行、是静态链接还是动态链接及入口地址、目标硬件、目标操作系统等信息。文件头还包含一个<strong>段表（Section Table），段表是一个描述文件各段的数组，具有每个段的信息（各段在文件中的偏移位置和段的属性等）。</strong></p></li><li><p>未初始化的全局变量和局部静态变量<strong>默认值都为0</strong>，本可以存放在.data段，但是在.data存放数据0没有必要。程序运行时他们的确占内存空间，并且可执行文件必须记录它们的大小总和，为其预留位置，记为.bss段。但<strong>.bss段没有内容，在文件中不占空间（better save space）。</strong></p></li></ul><p>2.程序源代码被编译后主要分为两种段：<strong>程序指令</strong>和<strong>程序数据</strong>。区分好处如下：</p><ul><li><p>程序被装载后，数据和指令被分别映射到<strong>两个虚存空间</strong>，将其<strong>权限</strong>分别设置为<strong>可读写</strong>和<strong>只读</strong>。<strong>防止程序的指令被改写。</strong></p></li><li><p><strong>指令和数据分离有利于提高程序的局部性。</strong>现代计算机的CPU缓存一般都被设计成数据缓存和指令缓存分离，所以两者分离存放<strong>对CPU缓存命中率提高有好处。</strong></p></li><li><p>当系统中运行同一个程序的多个副本时，其指令都是一样的，所以内存中只须保存一份该程序的指令部分。<strong>共享指令可以大量节省内存</strong>，对其他的只读数据同理。</p></li></ul><p><strong>* <em>先大概了解目标文件里面有什么，下次再逐个深入。。。</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——编译与链接</title>
    <link href="/2020/06/27/compile-and-link/"/>
    <url>/2020/06/27/compile-and-link/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>从第二章开始不再按照目录的顺序总结，而是将大块知识点总结在一起。。。</em> *</strong></p><h1 id="第二章-编译和链接"><a href="#第二章-编译和链接" class="headerlink" title="第二章 编译和链接"></a><strong>第二章 编译和链接</strong></h1><blockquote><p><strong>集成开发环境（IDE）</strong>一般都将编译和链接的过程一步完成，此过程成为构建（Bulid）。但其掩盖了系统软件运行机制。</p></blockquote><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$gcc</span> hello.c</span><span class="hljs-symbol">$</span>./a.out</code></pre><p>一个<strong>可执行文件的生成</strong>，可以分解成4个步骤：<strong>预处理（Prepressing）</strong>、<strong>编译（Compilation）</strong>、<strong>汇编（Assembly）</strong>和<strong>链接（Linking）</strong>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzIyMjA1MzA4MTUy?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="GCC编译过程分解"></p><p>1.<strong>预编译</strong>：C程序源代码文件和相关头文件被预编译器cpp预编译成 .i 文件。C++程序被预编译后的文件拓展名为 .ii 。</p><pre><code class="hljs stylus"><span class="hljs-comment">/* -E表示只进行预编译 */</span><span class="hljs-variable">$gcc</span> -E hello<span class="hljs-selector-class">.c</span> -o hello<span class="hljs-selector-class">.i</span> 或 <span class="hljs-variable">$cpp</span> hello<span class="hljs-selector-class">.c</span> &gt; hello.i</code></pre><p><strong>预编译过程主要处理源代码文件中以“#”开始的预编译指令。</strong></p><ul><li><p>将所有的“#define”删除，并展开所有宏定义</p></li><li><p>处理所有条件预编译指令，如“#if”、“#ifdef”、“#elif”、“#else”、“#endif”</p></li><li><p>处理“#include”预编译指令，将包含的文件插入到该预编译指令的位置。此过程是递归的。</p></li><li><p>删除所有的注释“//”和“/**/”</p></li><li><p>添加行号和文件标识，以便于编译时器编译器产生调试用的行号信息及编译时产生错误或警告的时显示行号</p></li><li><p>保留所有#pragma编译器指令，因为编译器需要使用它们</p></li></ul><p>2.<strong>编译</strong>：把预处理完的文件进行一系列<strong>词法分析</strong>、<strong>语法分析</strong>、<strong>语义分析</strong>及<strong>优化后生成相应的汇编代码文件</strong>。</p><pre><code class="hljs stylus"><span class="hljs-comment">/* -S表示只进行编译 */</span><span class="hljs-variable">$gcc</span> -S hello<span class="hljs-selector-class">.i</span> -o hello<span class="hljs-selector-class">.s</span> 或 <span class="hljs-variable">$gcc</span> -S hello<span class="hljs-selector-class">.c</span> -o hello.s</code></pre><p>现在版本的GCC将<strong>预编译和编译两个步骤合并在一个步骤中，由编译器完成</strong>。对于C语言代码使用cc1程序、C++语言使用cc1plus、Objective-C语言使用cc1obj、fortran语言使用f771、Java语言使用jc1。</p><blockquote><p><strong>实际上gcc命令只是后台程序的包装，其根据不同的参数调用预编译器cc1、汇编器as、链接器ld。</strong></p></blockquote><p><strong>编译器是将高级语言翻译成机器语言的一个工具</strong>，其编译过程一般分为6步：<strong>扫描</strong>、<strong>语法分析</strong>、<strong>语义分析</strong>、<strong>源代码优化</strong>、<strong>代码生成</strong>和<strong>目标代码优化</strong>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzIyMjEzMjE1MDMw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="编译过程"></p><ul><li><strong>语法分析</strong>：源代码程序被输入到<strong>扫描机（Scanner）</strong>，运用一种类似于<strong>有限状态机（Finite State Machine）</strong>的算法，将源代码的字符序列分割成一系列<strong>记号（Token）</strong>。<br>词法分析产生的记号一般分为：关键字、标识符、字符量（包含数字、字符串等）和特殊符号（如加号、等号）。此过程中，扫描器也将标识符存放到符号表，将数字、字符串常量存放到文字表。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzIyMjE0NTI4Nzcx?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="语法树"></li></ul><p> <strong>符号和数字是最小的表达式，它们不再由表达式来组成，它们通常作为整个语法树的叶节点。</strong>语法分析的同时运算符号的优先级和含义也被确定下来。如果出现了表达式不合法，比如括号不匹配、表达式中缺少操作符等，编译器会报告语法分析阶段的错误。</p><ul><li><p><strong>语义分析</strong>：<strong>语义分析器（Semantic Analyzer）</strong>判断语句是否正真的有意义。编译器能分析的是<strong>静态语义（Static Semantic）</strong>，是在<strong>编译期可以确定的</strong>语义，通常包括声明、类型的匹配、类型的转换。而<strong>动态语义（Dynamic Semantic）</strong>只有在运行期才能确定，比如0作为除数。<br>语义分析后，<strong>语法树的标识符都标识了类型</strong>，若有类型的隐式转换，语义分析器会在语法树中插入相应的转换结点。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzIzMjMyNDI5NzQ0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="这里写图片描述"></p></li><li><p><strong>中间语言生成</strong>：<strong>源代码优化器（Source Code Optimizer）</strong>在源代码级别进行优化。源代码优化器往往将整个语法树转换成<strong>中间代码（Intermediate Code）</strong>，它是<strong>语法树的顺序表示</strong>。<br>它与目标代码非常接近，但<strong>其跟目标机器和运行环境无关</strong>，<strong>不包含数据的大小</strong>、<strong>变量地址</strong>、<strong>寄存器名</strong>等。中间代码常见类型有：<strong>三地址码（Three-address Code）</strong>和<strong>P-代码（P-Code）</strong>。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI2MjAxNTUwMTk5?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="优化后的语法树"><br>上图语法树翻译成三地址码为：</p><pre><code class="hljs mipsasm"><span class="hljs-built_in">t1</span> = <span class="hljs-number">2</span> + <span class="hljs-number">6</span><span class="hljs-built_in">t2</span> = index + <span class="hljs-number">4</span><span class="hljs-built_in">t3</span> = <span class="hljs-built_in">t2</span> * <span class="hljs-built_in">t3</span>array[index] = <span class="hljs-built_in">t3</span><span class="hljs-comment">/*继续优化*/</span><span class="hljs-built_in">t2</span> = index + <span class="hljs-number">4</span><span class="hljs-built_in">t2</span> = <span class="hljs-built_in">t2</span> * <span class="hljs-number">8</span></code></pre><p><strong>中间代码使编译器分成前端和后端。编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。</strong></p></li><li><p><strong>目标代码优化与生成</strong>：编译器后端主要包括<strong>代码生成器（Code Generator）</strong>和<strong>目标代码优化器（Target Code Optimizer）</strong>。<br><strong>代码生成器将中间代码转换成目标机器代码，目标代码优化器对目标代码进行优化</strong>，比如选择合适的寻址方式、使用位移代替乘法运算、删除多余指令等。</p></li></ul><p>3.<strong>汇编</strong>：汇编器将<strong>汇编代码转化成机器可以执行的指令</strong>，每一个汇编语句几乎都对应一条机器指令。根据<strong>汇编指令和机器指令的对照表</strong>一一翻译。</p><pre><code class="hljs stylus"><span class="hljs-variable">$as</span> hello<span class="hljs-selector-class">.s</span> -o hello<span class="hljs-selector-class">.o</span> 或 <span class="hljs-variable">$gcc</span> -c hello<span class="hljs-selector-class">.s</span> -o hello<span class="hljs-selector-class">.o</span> 或 <span class="hljs-variable">$gcc</span> -c hello<span class="hljs-selector-class">.c</span> -o hello.o</code></pre><p>4.<strong>链接</strong>：重新计算各个目标地址的过程叫做<strong>重定位（Relocation）</strong>。<strong>符号（Symbol）</strong>用来表示一个地址，这个地址可能是函数或变量的起始地址。汇编器在每次汇编程序的时候重新计算符号的地址，把所有引用该符号的指令修正到这个正确的地址。</p><p>一个程序被分割成多个模块之后，模块之间的通信方式有<strong>模块间的函数调用</strong>和<strong>模块间的变量访问</strong>两种方式，归结为模块间符号的引用。</p><blockquote><p><strong>定义符号的模块多出一块区域，引用该符号的模块刚好少了那一块区域。两者的拼接过程即链接（Linking）。</strong></p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI2MjEyOTE5MTUw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="模块间拼接"></p><ul><li>模块拼接——<strong>静态链接</strong></li></ul><blockquote><p><strong>将每个源代码模块独立地编译，然后按照需要将它们组装起来，这个组装模块的过程就是链接（Linking）。</strong></p></blockquote><p>链接过程主要包括<strong>地址和空间分配（Address and Storage Allocation）</strong>、<strong>符号决议（Symbol Resolution）</strong>和<strong>重定位（Relocation）</strong>等。每个模块的源代码文件经过编译器编译成<strong>目标文件（Object File，一般拓展名为.o或.obj）</strong>，<strong>目标文件和库（Library）一起链接形成最终可执行文件</strong>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI2MjEzODMzNzcy?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="连接过程"></p><p>每个模块都是单独编译，编译器编译a.c时并不知道引用的函数的地址，所以暂时把调用该函数的目标地址搁置，等待最后链接时由链接器将这些指令的目标地址修正。<strong>链接器在链接时根据所引用的符号，自动去相应的模块查找该符号的地址，然后将a.c模块中所有引用到该符号的指令重新修正，让其目标地址为真正的符号的地址。</strong><br>地址修正的过程叫做<strong>重定位（Relocation）</strong>，每个要被修正的地方叫一个<strong>重定位入口（Relacation Entry）。</strong></p><p><strong>* <em>下次想总结一下UDP/TCP相关。。。</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——进程与线程</title>
    <link href="/2020/06/27/processes-and-threads/"/>
    <url>/2020/06/27/processes-and-threads/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>第一章最后一部分，part.3。。。</em> *</strong></p><h1 id="第一章-温故而知新"><a href="#第一章-温故而知新" class="headerlink" title="第一章 温故而知新"></a><strong>第一章 温故而知新</strong></h1><h2 id="1-6-众人拾柴火焰高"><a href="#1-6-众人拾柴火焰高" class="headerlink" title="1.6 众人拾柴火焰高"></a><strong>1.6 众人拾柴火焰高</strong></h2><h3 id="1-6-1-线程基础"><a href="#1-6-1-线程基础" class="headerlink" title="1.6.1 线程基础"></a><strong>1.6.1 线程基础</strong></h3><p>1.<strong>线程（Thread）</strong>，也称<strong>轻量级进程（Lightweight Process，LWP）</strong>，是<strong>程序执行流的最小单元</strong>。一个标准线程由线程ID，当前指令指针（PC），寄存器集合和堆栈组成。进程由一个或多个线程组成，各线程之间共享（全局变量）代码段、数据段、堆、打开文件描述符、信号等。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE5MTM0MDM3Mzg5?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="进程内的线程"></p><p>2.线程拥有的私有空间</p><ul><li><p><strong>线程栈</strong></p></li><li><p><strong>线程局部存储（Thread Local Storage，TLS）</strong>，某些操作系统为线程单独提供有限容量的私有空间。</p></li><li><p><strong>寄存器（包括PC寄存器）</strong>，是执行流的的基本数据，为线程私有。</p></li></ul><table><thead><tr><th>线程私有</th><th>线程共享（进程所有）</th></tr></thead><tbody><tr><td>局部变量</td><td>全局变量</td></tr><tr><td>函数的参数</td><td>堆数据</td></tr><tr><td>TLS数据</td><td>函数中的静态变量</td></tr><tr><td></td><td>程序代码</td></tr><tr><td></td><td>打开的文件，A线程打开的文件，B线程可以读写</td></tr></tbody></table><p>3.当线程数量小于等于处理器数量时，才是真正的线程并发，不同线程运行在不同的处理器上。当单处理器对应多线程时，并发是模拟出来的状态，操作系统让多线程程序轮流执行。一个不断在处理器上切换不同状态的线程的行为成为<strong>线程调度（Thread Schedule）</strong>。</p><ul><li><p><strong>运行（Running）</strong>：此时线程正在执行。</p></li><li><p><strong>就绪（Ready）</strong>：此时线程可以立刻运行，但CPU已被占用。</p></li><li><p><strong>等待（Waiting）</strong>：此时线程正在等待某一事件（比如I/O或同步）发生，无法执行。</p></li></ul><p>处于运行中的线程拥有一段可以执行的时间，这段时间被称为<strong>时间片（Time Slice）</strong>。</p><ul><li><p><strong>如果时间片用尽时，该线程进入就绪状态。</strong></p></li><li><p><strong>如果在时间片用尽之前线程就开始等待某事件，该线程进入等待状态。</strong></p></li><li><p><strong>当一个线程离开运行状态时，调度系统选择一个就绪线程继续执行。</strong></p></li><li><p><strong>当处于等待状态的线程所等待的事件发生后，该线程进入就绪状态。</strong></p></li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE5MTQzOTEzODY0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="线程状态切换"></p><p>4.线程调度的方法中都带有<strong>优先级调度（Priority Schedule）</strong>和<strong>轮转法（Round Robin）</strong>的痕迹。</p><ul><li><p>轮转法：各个线程轮流执行一小段时间。</p></li><li><p>优先级调度：线程拥有各自的<strong>线程优先级（Thread Priority）</strong>线程按照优先级顺序轮流执行。</p></li></ul><blockquote><p> CPU也喜欢先捏软柿子。</p></blockquote><p>系统会根据线程的表现自动调整优先级。频繁地进入等待状态（会放弃之后剩余的可占用时间份额）的线程（例如处理I/O的线程）称为<strong>IO密集型线程（IO Bound Thread）</strong>；频繁地进行大量运算，以至于每次都把时间片全部用尽的线程称为<strong>CPU密集型线程（CPU Bound Thread）</strong>。<strong>IO密集型线程总比CPU密集型线程容易得到优先级提升。</strong></p><p>5.<strong>饿死（Starvation）</strong>现象：一个线程优先级较低，在它执行之前总是有优先级较高的线程要执行，因此这个低优先级线程始终无法执行。为了避免饿死现象，<strong>调度系统常常会逐步提升等待了过长时间得不到执行的线程的优先级</strong>。</p><p>改变线程优先级一般的三种方式：</p><ul><li><p>用户指定优先级</p></li><li><p>根据进入等待状态的频繁程度而提升或降低优先级</p></li><li><p>长时间得不到执行而被提升优先级</p></li></ul><p>6.线程在用尽时间片之后会被强制剥夺继续执行的权利，进入就绪状态，这个过程叫做<strong>抢占（Preemption）</strong>，即之后执行的别的线程抢占了当前线程。早期系统中线程是不可抢占的。线程必须手动发出放弃执行的命令，才能让其他线程得到执行。此时线程是主动进入就绪状态的，而不是靠时间片用尽被强制进入。若线程始终拒绝进入就绪状态也不进行等待，那么其他线程将永远无法执行。但此时线程调度的时机是确定的。</p><p>在不可抢占线程中，线程主动放弃执行的情况：</p><ul><li><p>党线程试图等待某事件时（I/O等）</p></li><li><p>线程主动放弃时间片</p></li></ul><p>7.Linux内核中并不存在正真意义上的线程概念。Linux将所有执行实体都称为<strong>任务（Task）</strong>，每一个任务概念上都类似于一个单线程，具有内存空间、执行实体、文件资源。共享同一个内存空间的多个任务构成了一个进程。</p><table><thead><tr><th>系统调用</th><th>作用</th></tr></thead><tbody><tr><td>fork</td><td>复制当前进程</td></tr><tr><td>exec</td><td>使用新的可执行映像覆盖当前可执行映像</td></tr><tr><td>clone</td><td>创建子进程并从指定位置开始执行</td></tr></tbody></table><p><strong>fork函数产生一个和当前进程完全一样的新进程，并和当前进程一同从fork函数返回。</strong></p><pre><code class="hljs jboss-cli">pid_t pid;<span class="hljs-keyword">if</span><span class="hljs-params">(<span class="hljs-attr">pid</span> == fork()</span>)&#123;<span class="hljs-string">...</span>&#125;</code></pre><ul><li><p>调用fork函数后，新的任务启动并和本任务一起从fork函数返回。<strong>本任务fork返回新任务的pid，新任务fork返回0</strong>。</p></li><li><p>fork不复制原任务的内存空间，而是和原任务一起共享一个<strong>写时复制/写时拷贝（Copy on Write，COW）</strong>的内存空间。写时复制指的是<strong>两个任务可以同时自由读取内存，但任意一个任务试图对内存进行修改时，内存就会复制一份提供给修改方单独使用，避免影响到其他任务使用。</strong></p></li><li><p><strong>exec可以用新的可执行映像替换当前的可执行影响</strong>，所以在fork产生一个新的任务之后，新任务调用exec来执行新的可执行文件。</p></li><li><p><strong>clone可以产生一个新任，从指定位置开始执行，可选共享当前进程的内存空间和文件等</strong>。</p></li></ul><pre><code class="hljs oxygene">int clone(int <span class="hljs-comment">(*fn)(void*)</span>, void* child_stack, int <span class="hljs-keyword">flags</span>, void* arg);</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE5MTk0MDU1NTAx?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="写时复制"></p><h3 id="1-6-2-线程安全"><a href="#1-6-2-线程安全" class="headerlink" title="1.6.2 线程安全"></a><strong>1.6.2 线程安全</strong></h3><p>1.在多线程环境中，可访问的全局变量和堆数据随时都可能被其他的线程改变。多线程程序在<strong>并发时数据的一致性</strong>非常重要。</p><p>2.单指令的操作称为<strong>原子的（Atomic）</strong>，单条指令的执行是不会被打断的。例如自增（++）会被操作系统编译为汇编代码后不止一条指令，所以有可能执行一半就被调度系统打断，去执行别的代码，这不是线程安全的。</p><table><thead><tr><th>Windows API</th><th>作用</th></tr></thead><tbody><tr><td>InterlockedExchange</td><td>原子地交换两个值</td></tr><tr><td>InterlockedDecrement</td><td>原子地减少一个值</td></tr><tr><td>InterlockedIncrement</td><td>原子地增加一个值</td></tr><tr><td>InterlockedXor</td><td>原子地进行异或操作</td></tr></tbody></table><p>3.<strong>同步</strong>是指在一个线程访问数据未结束的时候。其他线程不得对同一个数据进行访问，如此对数据的访问被原子化了。</p><p>4.同步最常用的方法是使用<strong>锁（Lock）</strong>。锁是一种非强制机制，每一个线程在访问数据资源之前需试图<strong>获取（Acquire）</strong>锁，并在访问结束之后<strong>释放（Release）</strong>锁。<strong>在锁已经被占用的时候试图获取锁，线程会等待，直到锁被重新可用。</strong></p><p>5.<strong>二元信号量（Binary Semaphore）</strong>是最简单的锁，有<strong>占用与非占用</strong>两种状态。它适合只能被唯一一个线程独占访问的资源。对于允许多个线程并发访问的资源，多元信号量简称<strong>信号量（Semaphore）</strong>。<strong>一个初始值为N的信号量允许N个线程并发访问。</strong>线程访问资源的时候对信号量的操作步骤如下：</p><ul><li>将信号量的值减1</li><li>如果信号量的值小于0，则进入等待状态，否则继续执行。访问完资源后，线程释放信号量</li><li>将信号量的值加1</li><li>如果信号量的值小于1，唤醒一个等待中的线程</li></ul><p>6.<strong>互斥量（Mutex）</strong>和二元信号量类似，资源同时允许一个线程访问。<strong>信号量在整个系统中可以被任意线程获取或释放</strong>，即同一个信号量可以被系统中的任意一个线程获取之后由另一个线程释放。<strong>互斥量要求哪个线程获取互斥量，哪个线程负责释放互斥量。</strong></p><p>7.<strong>临界区（Critical Section）</strong>是比互斥量更加严格的同步手段。把临界区的锁获取称为进入临界区，锁的释放称为离开临界区。<strong>互斥量和信号量在系统的任何进程里都是可见的，即一个进程创建的互斥量或信号量，另一个进程试图去获取该锁是合法的。临界区作用范围仅限于本进程，其他进程无法获取该锁。</strong></p><p>8.<strong>读写锁（Read-Write Lock）</strong>是一种特定的场合的同步。对于同一个锁，读写锁有<strong>共享的（Shard）</strong>或<strong>独占的（Exclusive）</strong>两种获取方式。</p><ul><li><p>当锁处于自由状态时，试图以任何一种方式获取锁都能成功，并将锁置于对应状态。</p></li><li><p>如果锁处于共享状态，其他线程以共享的方式获取锁仍会成功，此时锁分配给多个线程。</p></li><li><p>如果其他线程试图以独占的方式获取已经处于共享状态的锁，那么它必须等待锁被所有的线程释放。</p></li><li><p>处于独占的锁阻止任何其他线程获取该锁。</p></li></ul><table><thead><tr><th>读写锁状态</th><th>以共享方式获取</th><th>以独占方式获取</th></tr></thead><tbody><tr><td>自由</td><td>成功</td><td>成功</td></tr><tr><td>共享</td><td>成功</td><td>等待</td></tr><tr><td>独占</td><td>等待</td><td>等待</td></tr></tbody></table><p>9.条件变量（Condition Variable）类似于一个栅栏。</p><ul><li><p>线程可以等待条件变量，一个条件变量可以可以被多个线程等待</p></li><li><p>线程可以唤醒条件变量，此时某个或所有等待此条件的变量的线程都会被唤醒并继续支持</p></li></ul><p><strong><strong>未完待续，下次继续补在后面。。。</strong></strong></p><p><strong><em>=================================================</em></strong></p><p><strong><strong>继续。。。</strong></strong></p><p>10.一个函数被重入，表示这个函数没有执行完成，由于外部因素或内部调用，又一次进入该函数执行。只有两种情况：</p><ul><li><strong>多个线程同时执行这个函数</strong></li><li><strong>函数自身调用自身（递归调用）</strong></li></ul><p>一个函数是<strong>可重入的（Reentrant）</strong>，说明该函数被重入之后不会产生任何不良后果，可以在多线程环境中安全使用。如要成为可重入，需有以下特点：</p><ul><li>不使用任何<strong>（局部）静态</strong>或<strong>全局的非const变量</strong></li><li>不返回任何<strong>（局部）静态</strong>或<strong>全局的非const变量的指针</strong></li><li>仅依赖于调用方提供的参数</li><li>不依赖于任何单个资源的锁（mutex等）</li><li>不调用任何不可重入的函数</li></ul><p>11.过度优化：<strong>编译器进行优化时，有可能为了提高变量的访问速度，把变量放到某个寄存器中却不写回；也有可能为了效率而交换毫不相干的两条相邻指令。</strong></p><p>使用<strong>volatile</strong>关键字试图阻止编译器过度优化。</p><ul><li>阻值编译器为了提高速度将一个变量缓存到寄存器内而不写回</li><li>阻值编译器调整操作volatile变量的指令顺序</li></ul><p><strong>CPU进行动态调度时，在执行程序时为了提高效率可能交换指令的顺序。</strong></p><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><span class="hljs-comment">C++中new包含两个步骤：(1)分配内存、(2)调用析构函数</span><span class="hljs-comment">pInst = new T 包含三个步骤：(1)分配内存、(2)在内存的位置上调用构造函数、(3)将内存的地址赋值给pInst，(2)(3)顺序是可以颠倒的。</span><span class="hljs-comment">*/</span><span class="hljs-keyword">volatile</span> T *pInst = <span class="hljs-number">0</span>;<span class="hljs-function">T* <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(pInst == <span class="hljs-literal">NULL</span>)&#123;lock();<span class="hljs-keyword">if</span>(pInst == <span class="hljs-literal">NULL</span>）pInst = <span class="hljs-keyword">new</span> T;unlock();&#125;<span class="hljs-keyword">return</span> pInst;&#125;</code></pre><p>通常情况下调用CPU提供的一条指令，通常被称为<strong>barrier</strong>，一条barrier指令会阻值CPU将该指令之前的指令交换到barrier之后。</p><pre><code class="hljs pgsql"><span class="hljs-keyword">if</span>(!pInst)&#123;T *<span class="hljs-keyword">temp</span> = <span class="hljs-built_in">new</span> T;barrier();pInst = <span class="hljs-keyword">temp</span>;&#125;</code></pre><h3 id="1-6-3-多线程内部情况"><a href="#1-6-3-多线程内部情况" class="headerlink" title="1.6.3 多线程内部情况"></a><strong>1.6.3 多线程内部情况</strong></h3><p>1.<strong>线程的并发执行是由多处理器或操作系统调度来实现的。</strong>用户实际使用的线程并不是内核线程，而是存在于用户态的用户线程。用户态线程并不一定在操作系统内核中对应同等数量的内核线程。</p><ul><li><strong>一对一模型</strong>：一个用户使用的线程唯一对应一个内核线程</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzIxMTcxMjQ3NzEz?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="一对一线程模型"></p><p>优点：线程之间<strong>真正的并发</strong>，一个线程阻塞，其他线程执行不受影响。<br>缺点：<strong>操作系统限制了内核线程的数量</strong>，一对一模型的数量受到限制；<strong>线程调度时上下文切换开销大，导致用户线程执行效率低下。</strong></p><ul><li><strong>多对一模型</strong>：<strong>多个用户线程映射到一个内核线程上</strong>，线程之间的切换由用户态的代码决定。</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzIxMTcxODMyNjky?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="多对一线程模型"></p><p>优点：<strong>高效的上下文切换和几乎无限制的线程数量。</strong><br>缺点：如果一个用户线程阻塞，那么所有线程都无法得到执行，内核线程也随之阻塞。</p><ul><li><strong>多对多模型</strong>：将多个用户线程映射到少数但不止一个内核线程上。</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzIxMTcyMzI2Nzg5?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="多对多线程模型"></p><p>优点：一个用户线程阻塞不会使所有用户线程阻塞，因为此时还会有别的线程可以被调度执行。</p><p><strong>* <em>终于完了。。。后面就不会跟着目录写了。。。</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——虚拟地址空间</title>
    <link href="/2020/06/27/virtual-address-space/"/>
    <url>/2020/06/27/virtual-address-space/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>接着第一章继续，part.2。。。</em> *</strong></p><h1 id="第一章-温故而知新"><a href="#第一章-温故而知新" class="headerlink" title="第一章 温故而知新"></a><strong>第一章 温故而知新</strong></h1><h2 id="1-5-内存不够怎么办"><a href="#1-5-内存不够怎么办" class="headerlink" title="1.5 内存不够怎么办"></a><strong>1.5 内存不够怎么办</strong></h2><p>1.早期的计算机中，程序直接运行在物理内存上，即程序在运行时所访问的地址都是物理地址。计算机将有限的物理内存分配给多个程序使用。这种简单的内存分配策略有很多问题。</p><ul><li><p><strong>地址空间不隔离</strong><br>所有程序直接访问物理地址，程序所使用的内存空间不是相互隔离的。恶意程序可以很容易改写其他程序的内存数据。</p></li><li><p><strong>内存使用效率低</strong><br>一个程序执行时，监控程序直接将整个程序装入内存中然后开始执行。如果要运行一个需要内存非常大的程序，此时剩余可用的内存已经不够了，此时可以将其他程序的数据暂时写入磁盘，等到要用时再读回来。整个过程中有大量的数据在换入换出，导致效率十分低下。</p></li><li><p><strong>程序运行的地址不确定</strong><br>程序每次装入运行时，需要给它从内存中分配一块足够大的空闲区域，此时空闲区域的位置是不确定的。这样影响了之后访问数据和指令跳转时的目标地址，涉及程序的重定位（PS:在后面的链接部分有讲，看了之后真是恍然大悟。。。）。</p></li></ul><p>解决这些问题的法宝：增加中间层，即使用一种间接的地址访问方法。把程序给出的地址看作一种<strong>虚拟地址（Virtual Address）</strong>，通过某些<strong>映射方法</strong>，将<strong>虚拟地址转换成实际的物理地址</strong>。只要能妥善地控制这个虚拟地址到物理地址的映射过程，就可以保证任意一个程序所能访问的物理内存跟另一个程序相互不重叠，达到地址空间隔离的效果。</p><h3 id="1-5-1-关于隔离"><a href="#1-5-1-关于隔离" class="headerlink" title="1.5.1 关于隔离"></a><strong>1.5.1 关于隔离</strong></h3><p>1.所谓地址空间可以想象成一个很大的数组，每个数组的元素都是一个字节，这个数组的大小由地址空间的地址长度决定。地址空间分为两种：<strong>虚拟地址空间（Virtual Address Space）</strong>和<strong>物理地址空间（Physical Address Space）</strong>。物理地址空间是实实在在存在的。虚拟地址空间是指虚拟的、人们想象出来的地址空间，其实它并不存在，<strong>每个进程都有自己独立的虚拟空间，而且每个进程只能访问自己的地址空间</strong>，有效地做到了进程的隔离。</p><h3 id="1-5-2-分段（Segmentation）"><a href="#1-5-2-分段（Segmentation）" class="headerlink" title="1.5.2 分段（Segmentation）"></a><strong>1.5.2 分段（Segmentation）</strong></h3><p>1.最开始使用<strong>分段（Segmentation）</strong>的方法，基本思路是把一段与程序所需要的内存空间大小的虚拟空间映射到某个地址空间。把这两块相同大小的地址空间一一映射。即<strong>虚拟空间中的每个字节相对应于物理空间中的每个字节</strong>。映射过程由软件来设置。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE2MjI1MTMwNTY5?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="段映射机制"></p><p>分段的方法解决了第一个和第三个问题。做到了<strong>地址隔离</strong>、<strong>程序不再需要重定位</strong>。但依旧没有解决内存使用效率的问题。分段对内存区域的映射以程序为单位，还是会将整个程序换入换出到磁盘。</p><h3 id="1-5-3-分页（Paging）"><a href="#1-5-3-分页（Paging）" class="headerlink" title="1.5.3 分页（Paging）"></a><strong>1.5.3 分页（Paging）</strong></h3><p>1.根据程序的<strong>局部性原理</strong>，<strong>当一个程序在运行时，在某个时间段内，它只是频繁地用到了一小部分数据</strong>。使用更小粒度的内存分割和映射的方法，使程序的局部性原理得到充分利用。</p><p>2.<strong>分页是将地址空间人为地等分为固定大小的页</strong>，每一页的大小由硬件决定，或硬件支持多种大小的页，操作系统决定页的大小。但在<strong>同一时刻只能选择一种大小</strong>。目前几乎所有的PC上的操作系统都使用<strong>4KB</strong>大小的页。</p><p>3.<strong>当进程的虚拟地址空间按页分割时，把常用的的数据和代码页装载到内存中，把不常用的代码和数据保存在磁盘里，当需要用的时候从磁盘中读取</strong>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE2MjMxMjQ5NjE1?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="进程虚拟空间、物理空间和磁盘之间的页映射关系"></p><p>虚拟空间的页叫做<strong>虚拟页（VP，Virtual Page）</strong>，物理内存中的页叫做<strong>物理页（PP，Physical Page）</strong>，磁盘中的页叫做<strong>磁盘页（DP，Disk Page）</strong>。有些虚拟空间的页被映射到同一个物理页，实现了<strong>内存共享</strong>。</p><p>4.当进程所需的页不在内存中时，硬件会捕获此消息，即<strong>页错误（Page Fault）</strong>，操作系统接管进程，将需要的页从磁盘中读出并装入内存，之后建立映射关系。</p><p>5.保护也是页映射的目的之一，每个页可以设置权限属性。</p><p>6.虚拟存储的实现需要依靠硬件的支持。几乎所有的硬件都采用<strong>MMU（Memory Management Unit）</strong>部件进行页映射。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE2MjMyNTA5NDc2?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="虚拟地址到物理地址的转换"></p><p>在页映射模式下，CPU发出Virtual Address，即虚拟地址。经过MMU转换变成Physical Address。</p><p><strong>* <em>下次继续线程相关吧。。。</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——计算机组成</title>
    <link href="/2020/06/27/computer-composition/"/>
    <url>/2020/06/27/computer-composition/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>从这篇开始连续记录我的读书笔记，将书中重要的知识点总结，方便自己以后快速回忆与阅读。那就先从《程序员的自我修养——装载、链接与库》第一章开始喽。</em> *</strong></p><h1 id="第一章-温故而知新"><a href="#第一章-温故而知新" class="headerlink" title="第一章 温故而知新"></a><strong>第一章 温故而知新</strong></h1><h2 id="1-1-从Hello-World-说起"><a href="#1-1-从Hello-World-说起" class="headerlink" title="1.1 从Hello World 说起"></a><strong>1.1 从Hello World 说起</strong></h2><p>无</p><h2 id="1-2-万变不离其宗"><a href="#1-2-万变不离其宗" class="headerlink" title="1.2 万变不离其宗"></a><strong>1.2 万变不离其宗</strong></h2><p>1.计算机中有三个最为关键的部件，分别为<strong>中央处理器CPU</strong>、<strong>内存</strong>和<strong>I/O控制芯片</strong>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE1MTkzMjQ5MjE5?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="早期计算机硬件结构"></p><p>早期的CPU的核心频率与内存一样，所以直接连接在<strong>同一个总线（Bus）上</strong>。但为了协调I/O设备与总线之间的速度，<strong>一般每个设备都会有一个相应的I/O控制器</strong>。</p><p>2.由于CPU核心频率的提升，且远远快于内存的速度，于是产生了与<strong>内存频率相一致的系统总线</strong>，而CPU采用<strong>倍频的方式与系统总线进行通信</strong>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE1MTk0NDE4MDIx?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="硬件结构框架"></p><p>为了协调CPU、内存和高速的图形设备，专门设计了一个<strong>高速的北桥芯片</strong>，以便它们之间能够高速地交换数据。但如果相对低速的设备全部连接在北桥上，北桥同时处理不同速度的设备，设计会十分复杂。于是设计了<strong>专门处理低速设备的南桥（Southbridge）芯片</strong>,将低速设备都连接在南桥上，由南桥汇总后连接到北桥上。90年代时，PC在系统总线上采用PCI结构，在低速设备上采用ISA总线。</p><p>3.<strong>多对称处理器（SMP，Symmetry Multi-Processing）</strong>，每个CPU在系统中所处地位和所发挥的功能一样，是相互对称的。<strong>多核处理器（Multi-core Processor）</strong>实际上就是SMP的简化版，它们之间的区别很小，逻辑上来看它们是完全相同的。区别在于多核和SMP在<strong>缓存共享</strong>等方面有细微的差别，使得程序在优化上可以有针对性地处理。</p><h2 id="1-3-站得高，望得远"><a href="#1-3-站得高，望得远" class="headerlink" title="1.3 站得高，望得远"></a><strong>1.3 站得高，望得远</strong></h2><p>1.计算机系统软件体系结构采用一种层的结构。</p><blockquote><p>“计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。”</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE1MjAxMTI3OTI1?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="计算机软件体系结构"></p><ul><li><p>每个层次之间都需要相互通信，一般将通信的协议成为<strong>接口（Interface）</strong>，接口的下层是接口提供者，由它定义接口；接口的上层是接口的使用者，它使用接口来实现所需功能。</p></li><li><p>从整体层次结构上来看，开发工具与应用程序是是属于同一个层次的，都使用操作系统<strong>应用程序编程接口（Application Programming Interface）</strong>。应用程序接口的提供者运行库，什么样的运行库提供什么样的API。运行库使用操作系统提供的<strong>系统调用接口（System call Interface）</strong>,系统调用接口在实现中往往以<strong>软件中断（Software Interrupt）</strong>的方式提供。</p></li></ul><h2 id="1-4-操作系统做什么"><a href="#1-4-操作系统做什么" class="headerlink" title="1.4 操作系统做什么"></a><strong>1.4 操作系统做什么</strong></h2><blockquote><p><strong>操作系统的一个功能是提供抽象的接口，另外一个主要功能是管理硬件资源。</strong></p></blockquote><h3 id="1-4-1-不要让CPU打盹"><a href="#1-4-1-不要让CPU打盹" class="headerlink" title="1.4.1 不要让CPU打盹"></a><strong>1.4.1 不要让CPU打盹</strong></h3><p>1.如何高效、充分的利用CPU？</p><ul><li><p>计算机发展早期，为了充分利用CPU资源，编写了一个监控程序，当某个程序暂时无需使用CPU时，监控程序就把另外正在等待CPU资源的程序启动，使<strong>CPU充分利用</strong>。这种方法被称为<strong>多道程序（Multiprogramming）</strong>。其最大的问题是程序之间的调度太粗糙，程序之间不分轻重缓急。</p></li><li><p>经过改进，程序运行模式变成一种协作模式，即每个程序运行一段时间后都主动让出CPU给其他程序，使得一段时间内每个程序都有机会运行一小段时间。这种程序协作模式叫做<strong>分时系统（Time-Sharing System）</strong>。但如果一个程序一直霸占CPU，那么其他程序都得等着。</p></li><li><p><strong>多任务（Multi-tasking）系统</strong>，操作系统接管了所有的硬件资源，并且本身运行在一个手硬件保护的级别。所有的应用程序都以<strong>进程（Process）</strong>的方式运行在比操作系统权限更低的级别，<strong>每个进程都有自己独立的地址空间，使得进程之间的地址空间相互隔离。</strong></p></li><li><p>CPU由操作系统统一进行分配，<strong>每个进程根据进程优先级的高低都有机会得到CPU</strong>，如果运行时间超出了一定时间，操作系统会暂停该进程，将CPU资源分配给其他等待运行的进程。这种分配方式即<strong>抢占式（Preemptive）</strong>，<strong>操作系统可以强制剥夺并且分配给它认为目前最需要的进程。</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE1MjEzNzQ3MzQ4?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="进程转换流程"></p></li></ul><h3 id="1-4-2-设备驱动"><a href="#1-4-2-设备驱动" class="headerlink" title="1.4.2 设备驱动"></a><strong>1.4.2 设备驱动</strong></h3><p>1.当成熟的操作系统出现以后，硬件逐渐被抽象成了一系列概念。在UNIX中，硬件设备的访问跟访问普通文件一样。从硬件细节中解放，将繁琐的的硬件细节全交给操作系统中的<strong>硬件驱动（Device Driver）程序</strong>来完成。</p><p>2.文件系统是操作系统中最重要的部分之一，文件系统管理者磁盘中文件的存储方式。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE1MjE1MzM1NTM1?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="文件在磁盘中的结构"></p><p>硬盘的结构介绍：</p><ul><li><p>硬盘基本存储单位为<strong>扇区（Sector）</strong>，每个扇区一般为512字节。一个磁盘往往有多个盘片，每个盘片分两面，每面按照同心圆划分为若干个磁道，每个磁道划分为若干个扇区。</p></li><li><p>如果按照每个磁道都拥有相同的数量的扇区，那么靠近盘面外围的磁道密度肯定比内圈更加稀疏。但如果不同的磁道扇区数又不同，计算起来就十分麻烦。现代硬盘为了屏蔽这些复杂的硬件细节，普遍使用<strong>LBA（Logical Block Address）</strong>的方式，即整个硬盘中所有的扇区从0开始编号，一直到最后一个扇区，这个扇区编号叫做<strong>逻辑扇区号</strong>。</p></li></ul><p><strong>* <em>下次的读书笔记将总结第一章剩下的内容，主要为内存及其分配机制、线程相关等内容。</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初来乍到，请多多指教</title>
    <link href="/2020/06/26/hello-world/"/>
    <url>/2020/06/26/hello-world/</url>
    
    <content type="html"><![CDATA[<h3 id="学习的日子"><a href="#学习的日子" class="headerlink" title="学习的日子"></a>学习的日子</h3><p>学习，是一个漫长的经历。期间的快乐和苦痛只有自己感受最深。</p><p>学习的路程——道阻且长，但在这路上最大的动力就是内心的信念和兴趣了。</p><p>学习也有一段时间了，其实内心一直反感诸如此类的博客，认为有这时间不如多看看几页书、多想想项目方案。但前天施老师的一句话让我重新思考了这个问题。没错，人也是一种遵循自然法则的生物。到了一定年龄，其实各机能就会到达顶峰，随后而来的就是下滑。这其中最可怕的就是记忆力下滑。换个说法，说哲学点儿，我追不上时间。时光匆匆，白驹过隙，时间的流逝不留下一丝痕迹，表象能确认的可能就是那钟表滴答滴答的声音了吧。但我有时间没有的能力，我可以将一切经历记录下来，让时间留在这些记录中。</p><p>路虽弥,不行不至；事虽小,不做不成。未来的路还很长，做最好的自己，尽最大的能力，不让自己后悔就好。</p><p>第一次写blog，没个主题，也不知道写了些什么，最后还是送给自己一句话吧：桃李不言，下自成蹊。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感想随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
