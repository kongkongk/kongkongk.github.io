<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>装载、链接与库——系统调用</title>
    <link href="/2020/06/29/system-call/"/>
    <url>/2020/06/29/system-call/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>昨天总结了main函数前世今生的问题，跟着源码一步步看。。。今天来看看系统调用是什么。。。→_→</em> *</strong></p><blockquote><p><strong>系统调用（System Call）是应用程序与操作系统与内核之间的接口</strong></p></blockquote><ol><li><p><strong>系统调用（System Call）</strong>的定义</p><ul><li><p><strong>现代操作系统将可能产生冲突的系统资源（包括文件、I/O等设备）保护起来，阻止应用程序直接访问</strong></p></li><li><p>为了让应用程序有能力访问系统资源，也为了让程序借助操作系统做一些必须由操作系统支持的行为，每个操作系统都提供一套接口，以供应用程序使用</p></li><li><p><strong>这些接口往往通过中断实现</strong>，比如<strong>Linux使用0x80号端口作为系统调用的入口</strong>，Windows采用0x2E号中断作为系统调用入口</p></li></ul></li><li><p><strong>系统调用的弊端</strong></p><ul><li><p><strong>使用不便</strong>：操作系统提供的系统调用接口过于原始，没有进行很好的包装，使用起来不方便</p></li><li><p>各个操作系统之间调用不兼容</p></li><li><p>解决方法：<strong>运行库作为系统调用与程序之间的抽象层，可以简化使用，统一形式</strong></p></li><li><p>运行时库将不同的操作系统的系统调用包装成统一固定的接口，使得同样的代码在不同的操作系统下都可以直接编译并产生一致的效果，即<strong>源代码级别上的可移植性</strong></p></li></ul></li><li><p><strong>系统调用的原理</strong></p><ul><li><p>现代操作系统中通常有两种特权级别：<strong>用户态（User Mode）和内核态（Kernel Mode）</strong>。操作系统根据不同的特权，<strong>使不同的代码运行在不同的模式上以限制其权利，提高稳定性和安全性</strong></p></li><li><p><strong>系统调用是运行在内核态的，而应用程序基本都是运行在用户态的</strong></p></li><li><p>操作系统一般通过<strong>中断（Interrupt）来从用户态切换到内核态</strong></p></li><li><p><strong>中断是一个硬件或软件发出的请求，要求CPU暂停当前的工作转手去处理更重要的事情</strong>。中断一般具有两个属性，一个称为<strong>中断号（从0开始）</strong>，一个称为<strong>中断处理程序（Interrupt Service Routine， ISR）</strong>。<strong>不同的中断具有不同的中断号，而中断处理程序又与中断号一一对应</strong>。在内核中，<strong>有一个数组称为中断向量表（Interrupt Vector Table）</strong>，<strong>这个数组的第n项包含了指向第n号中断的中断处理程序指针</strong>。</p></li><li><p><strong>当中断到来时，CPU会暂停执行当前执行的代码，根据中断的中断号，在中断向量表中找到对应的中断处理程序，并调用它。中断处理程序执行完成之后，CPU会继续执行之前的代码</strong></p><p>  <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI0MjIxOTE1MTY4?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="CPU中断过程"></p></li></ul></li></ol><ol start="4"><li><p><strong>Linux系统调用流程</strong></p><ul><li><p><strong>在x86下，系统调用由0x80中断完成，各个通用寄存器用于传递参数，EAX寄存器用于表示系统调用的接口号。当系统调用返回时，EAX寄存器又作为调用结果的返回值</strong></p></li><li><p><strong>每个系统调用都对应于内核源代码中的一个函数，他们都以“sys_”开头</strong>。（定义路径：linux-2.4.0\include\asm-i386\Unistd.h）</p></li><li><p>基于int的Linux经典系统调用实现</p><p>  <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI1MTEzODE1Njgz?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="Linux系统中断流程"></p></li></ul></li><li><p>Linux系统调用源码剖析</p><ul><li><p><strong>_syscall0宏函数</strong>:<strong>无参的系统调用的封装</strong>，<strong>第一个参数为系统调用的返回值类型，第二个参数是系统调用的的名称</strong>，其展开后形成一个与系统调用名称同名的函数</p>  <pre><code class="hljs fsharp"><span class="hljs-comment">//linux-2.4.0\include\asm-i386\Unistd.h </span>#define _syscall0(<span class="hljs-class"><span class="hljs-keyword">type</span>,<span class="hljs-title">name</span>) \</span><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">name</span></span>(<span class="hljs-keyword">void</span>) \&#123; \long __res; \__asm__ volatile (<span class="hljs-string">"int $0x80"</span> \<span class="hljs-comment">//volatile防止编译器对代码优化</span>: <span class="hljs-string">"=a"</span> (__res) \<span class="hljs-comment">//表示用EAX输出返回数据并存储在__res中</span>: <span class="hljs-string">"0"</span> (__NR_##name)); \<span class="hljs-comment">//表示和输出相同的寄存器EAX传递参数</span>__syscall_return(<span class="hljs-class"><span class="hljs-keyword">type</span>,<span class="hljs-title">__res</span>); \</span>&#125;</code></pre></li><li><p><strong>_syscall1宏函数</strong>：<strong>带有一个参数的系统调用的封装，通过EBX寄存器传入</strong>。x86下的Linux支持的系统调用参数至多有6个，<strong>分别使用6个寄存器来传递参数（EBX、ECX、EDX、ESI、EDI、EBP）</strong></p>  <pre><code class="hljs reasonml"><span class="hljs-comment">//linux-2.4.0\include\asm-i386\Unistd.h </span>#define <span class="hljs-constructor">_syscall1(<span class="hljs-params">type</span>,<span class="hljs-params">name</span>,<span class="hljs-params">type1</span>,<span class="hljs-params">arg1</span>)</span> \<span class="hljs-keyword">type</span> name(type1 arg1) \&#123; \long __res; \__asm__ volatile (<span class="hljs-string">"int $0x80"</span> \: <span class="hljs-string">"=a"</span> (__res) \<span class="hljs-comment">//把arg1强制转化为long，然后存放在EBX里作为输入。编译器也会生成相应的代码保护原来的EBX的值不被破坏</span>: <span class="hljs-string">"0"</span> (__NR_##name),<span class="hljs-string">"b"</span> ((long)(arg1))); \<span class="hljs-constructor">__syscall_return(<span class="hljs-params">type</span>,<span class="hljs-params">__res</span>)</span>; \&#125;</code></pre></li><li><p><strong>__syscall_return宏函数</strong>：用于<strong>检查系统调用返回值</strong>，并将其转化为C语言的errno错误码。在<strong>Linux中</strong>，<strong>系统调用使用返回值传递错误码，如果返回值为负数，表明调用失败，返回值的绝对值就是错误码</strong>。<strong>C语言中大多数函数以返回-1表示调用失败，将错误信息存储在名为errno的全局变量中</strong></p>  <pre><code class="hljs livescript"><span class="hljs-comment">#define __syscall_return(type, res)\</span><span class="hljs-keyword">do</span> &#123;<span class="hljs-string">\</span><span class="hljs-keyword">if</span> ((unsigned long)(res) &gt;= (unsigned long)(-<span class="hljs-number">125</span>)) &#123;<span class="hljs-string">\</span>errno = -(res);<span class="hljs-string">\</span>res = -<span class="hljs-number">1</span>;<span class="hljs-string">\</span>&#125;<span class="hljs-string">\</span><span class="hljs-keyword">return</span> (type) (res);<span class="hljs-string">\</span>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)</code></pre></li><li><p><strong>切换堆栈</strong>：在实际执行中断向量表中的第0x80号元素所对应的函数之前，<strong>CPU还要进行栈切换</strong>。在Linux中，<strong>用户态和内核态使用不同的栈，两者各自负责各自的函数调用</strong>。所谓<strong>当前栈即ESP所指的栈空间</strong>，<strong>寄存器SS保存当前栈所在的页</strong></p><p>  <strong>用户栈切换至内核栈</strong>步骤如下：</p><ul><li><strong>保存当前ESP、SS的值</strong></li><li><strong>将ESP、SS的值设置为内核栈的相应值</strong></li></ul><p>  <strong>内核栈切换至用户栈</strong>步骤如下：</p><ul><li><p><strong>恢复原来的ESP、SS的值</strong></p></li><li><p><strong>用户态的ESP和SS的值保存在内核栈上，由中断指令自动地由硬件完成</strong></p><p>CPU除了切入内核态之外，还自动完成：</p></li><li><p><strong>找到当前进程地内核栈（每一个进程都有自己的内核栈）</strong></p></li><li><p><strong>在内核栈中依次压入用户态的寄存去SS、ESP、EFLAGS、CS、EIP</strong></p></li></ul><p>  <strong>当内核从系统调用中返回时，需调用iret指令返回到用户态，iret指令会从内核栈中弹出寄存器SS、ESP、EFLAGS、CS、EIP的值，使栈恢复到用户态的状态</strong></p><p>  <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI1MjEyMzAyNzg3?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="中断时用户栈和内核栈切换"></p></li></ul></li></ol><ul><li><p><strong>中断处理程序</strong>：<strong>在int指令切换栈之后，程序流程就切换到了中断向量表中记录的0x80号中断处理程序</strong></p><pre><code>![Linux i386 中断服务流程](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI1MjEyNzQ0MzMz?x-oss-process=image/format,png)**初始化中断向量表**</code></pre>  <pre><code class="hljs reasonml"><span class="hljs-comment">//linux-2.4.0\arch\i386\kernel\Traps.c</span><span class="hljs-comment">//0-19号中断对应的中断处理程序包括算数异常（除零、溢出）、页缺失（page fault）、无效指令</span>void __init trap<span class="hljs-constructor">_init(<span class="hljs-params">void</span>)</span>&#123;......set<span class="hljs-constructor">_trap_gate(0,&amp;<span class="hljs-params">divide_error</span>)</span>;set<span class="hljs-constructor">_trap_gate(1,&amp;<span class="hljs-params">debug</span>)</span>;set<span class="hljs-constructor">_intr_gate(2,&amp;<span class="hljs-params">nmi</span>)</span>;set<span class="hljs-constructor">_system_gate(3,&amp;<span class="hljs-params">int3</span>)</span>;<span class="hljs-comment">/* int3-5 can be called from all */</span>set<span class="hljs-constructor">_system_gate(4,&amp;<span class="hljs-params">overflow</span>)</span>;set<span class="hljs-constructor">_system_gate(5,&amp;<span class="hljs-params">bounds</span>)</span>;set<span class="hljs-constructor">_trap_gate(6,&amp;<span class="hljs-params">invalid_op</span>)</span>;set<span class="hljs-constructor">_trap_gate(7,&amp;<span class="hljs-params">device_not_available</span>)</span>;set<span class="hljs-constructor">_trap_gate(8,&amp;<span class="hljs-params">double_fault</span>)</span>;set<span class="hljs-constructor">_trap_gate(9,&amp;<span class="hljs-params">coprocessor_segment_overrun</span>)</span>;set<span class="hljs-constructor">_trap_gate(10,&amp;<span class="hljs-params">invalid_TSS</span>)</span>;set<span class="hljs-constructor">_trap_gate(11,&amp;<span class="hljs-params">segment_not_present</span>)</span>;set<span class="hljs-constructor">_trap_gate(12,&amp;<span class="hljs-params">stack_segment</span>)</span>;set<span class="hljs-constructor">_trap_gate(13,&amp;<span class="hljs-params">general_protection</span>)</span>;set<span class="hljs-constructor">_trap_gate(14,&amp;<span class="hljs-params">page_fault</span>)</span>;set<span class="hljs-constructor">_trap_gate(15,&amp;<span class="hljs-params">spurious_interrupt_bug</span>)</span>;set<span class="hljs-constructor">_trap_gate(16,&amp;<span class="hljs-params">coprocessor_error</span>)</span>;set<span class="hljs-constructor">_trap_gate(17,&amp;<span class="hljs-params">alignment_check</span>)</span>;set<span class="hljs-constructor">_trap_gate(18,&amp;<span class="hljs-params">machine_check</span>)</span>;set<span class="hljs-constructor">_trap_gate(19,&amp;<span class="hljs-params">simd_coprocessor_error</span>)</span>;<span class="hljs-comment">//系统调用对应的中断号，在linux-2.4.0\include\asm-i386\Hw_irq.h中，SYSCALL_VECTOR定义0x80</span>set<span class="hljs-constructor">_system_gate(SYSCALL_VECTOR,&amp;<span class="hljs-params">system_call</span>)</span>;......&#125;</code></pre><pre><code>**调用int 0x80之后，最终执行system_call函数**<pre><code class="hljs lasso">ENTRY(system_call)<span class="hljs-params">...</span><span class="hljs-params">...</span>SAVE_ALL<span class="hljs-comment">//宏函数SAVE_ALL将各种寄存器压入栈中，即系统调用传入的参数</span><span class="hljs-params">...</span><span class="hljs-params">...</span>cmpl $(nr_syscalls), %eax<span class="hljs-comment">//比较EAX和nr_syscalls，nr_syscalls是比最大的调用号大1的值，如果eax（用户传入的系统调用号）大于等于nr_syscalls，则这个系统调用无效，则会跳转至syscall_badsys执行，反之执行syscall_call</span>jae syscall_badsyssyscall_call:call *sys_call_table(<span class="hljs-number">0</span>,%eax,<span class="hljs-number">4</span>)<span class="hljs-comment">//系统调用表中，每一个元素（long类型）都是一个系统调用函数的地址。因此调用的是sys_call_table上偏移量为0+%eax*4上的元素的值指向的函数</span><span class="hljs-params">...</span><span class="hljs-params">...</span>RESTORE_REGS<span class="hljs-comment">//执行结束后，使用宏函数恢复之前SAVE_ALL保存的的寄存器</span><span class="hljs-params">...</span><span class="hljs-params">...</span>iret<span class="hljs-comment">//最后通过指令iter从中断处理程序中返回</span></code></pre>![Linux系统调用流程](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjI1MjMxNDEzNzIy?x-oss-process=image/format,png)</code></pre></li></ul><p>综上所述，<strong>Linux系统调用流程为：main  -&gt;  function  -&gt;  _syscall  -&gt;  int 0x80  -&gt;  __init trap_init  -&gt;  system_call  -&gt;  __syscall_return</strong></p><p><strong>* <em>so happy…so tired…→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>装载、链接与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装载、链接与库——main函数的前世今生</title>
    <link href="/2020/06/29/the-past-and-present-of-the-main-function/"/>
    <url>/2020/06/29/the-past-and-present-of-the-main-function/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>当执行”Hello World“程序时，是从main函数开始执行的吗？答案当然是No，No，No！</em> *</strong></p><p>一个程序的运行步骤如下：</p><ul><li><p>操作系统在在创建进程后，把控制权交给了程序的入口，这个入口一般是<strong>运行库中的某个入口函数</strong></p></li><li><p>入口函数对<strong>运行库和程序运行环境进行初始化</strong>，包括堆、I/O、线程、全局变量构造等</p></li><li><p>入口函数完成初始化后，<strong>调用main函数，正式开始执行程序主体部分</strong></p></li><li><p><strong>main函数执行完毕后，返回到入口函数，入口函数进行清理工作</strong>，包括全局变量析构、堆销毁、关闭I/O等，<strong>然后进行系统调用结束进程</strong></p></li></ul><p><strong>接下来具体分析的是基于glibc 2.6.1中静态链接的、用于可执行文件的情况</strong></p><ol><li><p>第一步：glibc的程序入口为_start（这个入口是有ld链接器默认的链接脚本指定的，可以通过相关参数设定入口）</p><ul><li><p>_start由汇编实现且和平台相关</p>  <pre><code class="hljs reasonml"><span class="hljs-comment">//将汇编改写为伪代码</span>void start<span class="hljs-literal">()</span>&#123;%ebp = <span class="hljs-number">0</span>;<span class="hljs-comment">//使ebp为0，证明其是最外层函数</span><span class="hljs-built_in">int</span> argc = pop from stack;<span class="hljs-comment">//从栈中获取argc，隐含envp</span><span class="hljs-built_in">char</span> **argv = top from stack;<span class="hljs-comment">//从栈中获取argv</span><span class="hljs-comment">//调用_libc_start_main()函数</span><span class="hljs-constructor">_libc_start_main(<span class="hljs-params">main</span>, <span class="hljs-params">argc</span>, <span class="hljs-params">argv</span>, <span class="hljs-params">_libc_csu_init</span>, <span class="hljs-params">_libc_csu_fini</span>, <span class="hljs-params">edx</span>, <span class="hljs-params">top</span> <span class="hljs-params">of</span> <span class="hljs-params">stack</span>)</span>;&#125;</code></pre></li><li><p>栈分布情况<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjIxMTgxNjQ4OTA4?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="环境变量和参数数组"></p></li></ul></li><li><p>第二步：调用_libc_start_main()函数，下面对_libc_start_main()函数进行源码分析</p><ul><li>源码分析<pre><code class="hljs cpp"><span class="hljs-comment">//glibc-2.6.1\csu\Libc-start.c</span><span class="hljs-comment">//为使结构条理更加清晰，删减了部分代码</span><span class="hljs-comment">/*</span><span class="hljs-comment">_libc_start_main()参数说明</span><span class="hljs-comment">main</span><span class="hljs-comment">argc</span><span class="hljs-comment">ubp_av:包括argv和envp</span><span class="hljs-comment">函数指针init：main调用前的初始化工作</span><span class="hljs-comment">函数指针fini：main结束后的收尾工作</span><span class="hljs-comment">函数指针rtld_fini：动态加载有关的收尾工作（runtime loader）</span><span class="hljs-comment">stack_end：指明栈地址，即最高的栈地址</span><span class="hljs-comment">*/</span>STATIC <span class="hljs-keyword">int</span>LIBC_START_MAIN (<span class="hljs-keyword">int</span> (*main) (<span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span> **, <span class="hljs-keyword">char</span> ** MAIN_AUXVEC_DECL), <span class="hljs-keyword">int</span> argc,  <span class="hljs-keyword">char</span> *__unbounded *__unbounded ubp_av, __typeof (main) init, <span class="hljs-keyword">void</span> (*fini) (<span class="hljs-keyword">void</span>), <span class="hljs-keyword">void</span> (*rtld_fini) (<span class="hljs-keyword">void</span>),  <span class="hljs-keyword">void</span> *__unbounded stack_end)&#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __BOUNDED_POINTERS__</span>  <span class="hljs-keyword">char</span> **argv;<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> argv ubp_av</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>  <span class="hljs-comment">/* Result of the 'main' function.  */</span>  <span class="hljs-keyword">int</span> result;......<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SHARED</span>  <span class="hljs-keyword">char</span> *__unbounded *__unbounded ubp_ev = &amp;ubp_av[argc + <span class="hljs-number">1</span>];  INIT_ARGV_and_ENVIRON;<span class="hljs-comment">//将宏展开得到 __environ = ubp_ev，即让__environ指针指向envp</span>  <span class="hljs-comment">/* Store the lowest stack address.  This is done in ld.so if this is</span><span class="hljs-comment">     the code for the DSO.  */</span>  __libc_stack_end = stack_end;......<span class="hljs-meta"># <span class="hljs-meta-keyword">ifdef</span> DL_SYSDEP_OSCHECK</span>  <span class="hljs-keyword">if</span> (!__libc_multiple_libcs)    &#123;      <span class="hljs-comment">/* This needs to run to initiliaze _dl_osversion before TLS</span><span class="hljs-comment"> setup might check it.  */</span>      DL_SYSDEP_OSCHECK (__libc_fatal);<span class="hljs-comment">//检查操作系统版本</span>    &#125;<span class="hljs-meta"># <span class="hljs-meta-keyword">endif</span></span>......__pthread_initialize_minimal ();<span class="hljs-comment">//__cxa_atexit()为glibc内部函数，等同于atexit</span><span class="hljs-comment">//rtld_fini在main函数结束后调用</span>__cxa_atexit ((<span class="hljs-keyword">void</span> (*) (<span class="hljs-keyword">void</span> *)) rtld_fini, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);__libc_init_first (argc, argv, __environ);<span class="hljs-comment">//fini在main函数结束后调用</span>__cxa_atexit ((<span class="hljs-keyword">void</span> (*) (<span class="hljs-keyword">void</span> *)) fini, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);(*init) (argc, argv, __environ MAIN_AUXVEC_PARAM);......result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);<span class="hljs-comment">//开始执行main函数，result为退出码</span>......<span class="hljs-built_in">exit</span> (result);<span class="hljs-comment">//程序开始退出</span>&#125;</code></pre></li><li>栈分布情况<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjIxMjAyOTE4NjAw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="环境变量和参数数组(2)"></li></ul></li><li><p>第三步：调用exit()函数，下面对exit()函数进行源码分析</p> <pre><code class="hljs awk"><span class="hljs-regexp">//g</span>libc-<span class="hljs-number">2.6</span>.<span class="hljs-number">1</span>\stdlib\Exit.cvoid <span class="hljs-keyword">exit</span> (int status)&#123;<span class="hljs-regexp">//</span>__exit_funcs存储由cxa_atexit和atexit注册的函数链表<span class="hljs-regexp">//</span>遍历该链表并逐个调用注册函数<span class="hljs-keyword">while</span> (__exit_funcs != NULL)&#123;struct exit_function_list *old;......old = __exit_funcs;__exit_funcs = __exit_funcs-&gt;<span class="hljs-keyword">next</span>;<span class="hljs-regexp">//</span>依次指向节点<span class="hljs-keyword">if</span> (__exit_funcs != NULL)free (old);    &#125;......    _exit (status);&#125;</code></pre></li><li><p>第四步：调用_exit()函数，下面对_exit()函数进行源码分析</p> <pre><code class="hljs awk"><span class="hljs-regexp">//</span> glibc-<span class="hljs-number">2.6</span>.<span class="hljs-number">1</span>\sysdeps\mach\hurd\Dl-sysdep.c<span class="hljs-regexp">//</span>_exit函数调用后，进程就会直接结束<span class="hljs-regexp">//</span>程序正常结束的两种情况<span class="hljs-regexp">//</span><span class="hljs-number">1</span>.通过main函数正常返回<span class="hljs-regexp">//</span><span class="hljs-number">2</span>.程序代码中使用<span class="hljs-keyword">exit</span>void weak_function attribute_hidden _exit (int status)&#123;__proc_mark_exit (_dl_hurd_data-&gt;portarray[INIT_PORT_PROC], W_EXITCODE (status, <span class="hljs-number">0</span>), <span class="hljs-number">0</span>);<span class="hljs-keyword">while</span> (__task_terminate (__mach_task_self ()))__mach_task_self_ = (__mach_task_self) ();&#125;</code></pre></li></ol><p>经过对源代码的分析，可以肯定”Hello World“程序的确不是从main函数开始执行的！</p><blockquote><p><strong>综上所述，函数调用过程如下：</strong><br><strong><em>start -&gt;</em> libc_start_main -&gt; exit -&gt; _exit</strong></p></blockquote><p><strong>* <em>终于写完了。。。经历了源码找不到、源码看不懂之后，最后还是搞定了。。(●ˇ∀ˇ●)</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>装载、链接与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（31）整数中1出现的次数（从1到n整数中1出现的次数）</title>
    <link href="/2020/06/29/the-number-of-occurrences-of-1-in-the-integer/"/>
    <url>/2020/06/29/the-number-of-occurrences-of-1-in-the-integer/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>求出1<del>13的整数中1出现的次数,并算出100</del>1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">//方法一</span><span class="hljs-comment">//将所有的数遍历一次，对每一个数的每一位再进行是否为1的判断</span><span class="hljs-comment">//时间复杂度为O（n*logn）</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">private</span>:<span class="hljs-built_in">int</span> NumberOf1(unsigned <span class="hljs-built_in">int</span> n)&#123;        <span class="hljs-built_in">int</span> number = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(n)<span class="hljs-comment">//对此数字的每一位都进行判断</span>&#123;            <span class="hljs-keyword">if</span>(n % <span class="hljs-number">10</span> == <span class="hljs-number">1</span>)<span class="hljs-comment">//模10取余，判断是否为1</span>                number++;            n = n / <span class="hljs-number">10</span>;<span class="hljs-comment">//将最后一位舍弃</span>        &#125;        <span class="hljs-keyword">return</span> number;    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">int</span> NumberOf1Between1AndN(unsigned <span class="hljs-built_in">int</span> n)    &#123;        <span class="hljs-built_in">int</span> number = <span class="hljs-number">0</span>;<span class="hljs-comment">//计数器</span>        <span class="hljs-keyword">for</span>(unsigned <span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<span class="hljs-comment">//循环遍历所有的数</span>            number += NumberOf1(i);        <span class="hljs-keyword">return</span> number;    &#125;&#125;;</code></pre><pre><code class="hljs cpp"><span class="hljs-comment">//方法二</span><span class="hljs-comment">//时间复杂度为O(logn)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">PowerBase10</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> num)</span><span class="hljs-comment">//计算num与10次方的关系</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i)res *= <span class="hljs-number">10</span>;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//防御性动作，判断字符串是否存在、第一个数字是否合法、字符串是否为NULL</span><span class="hljs-keyword">if</span> (!str || *str &lt; <span class="hljs-string">'0'</span> || *str &gt; <span class="hljs-string">'9'</span> || *str == <span class="hljs-string">'\0'</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> first = *str - <span class="hljs-string">'0'</span>;<span class="hljs-comment">//取数字的最高位，将其转化为int</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> length = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">strlen</span>(str));<span class="hljs-comment">//计算数字的位数，将其转化为unsigned int</span><span class="hljs-keyword">if</span> (length == <span class="hljs-number">1</span> &amp;&amp; first == <span class="hljs-number">0</span>)<span class="hljs-comment">//如果是一位数且值为0，则直接返回0</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (length == <span class="hljs-number">1</span> &amp;&amp; first &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//如果是一位数且值大于0，则1只出现1次，直接返回1</span><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> numFirstDigit = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (first &gt; <span class="hljs-number">1</span>)<span class="hljs-comment">//如果第一位数大于1，则计算数字与10的次方关系</span>numFirstDigit = PowerBase10(length - <span class="hljs-number">1</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (first == <span class="hljs-number">1</span>)<span class="hljs-comment">//如果第一位数等于1，则1出现的次数为从最高位为1到最大值的差值再加一</span>numFirstDigit = atoi(str + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> numOtherDigits = first*(length - <span class="hljs-number">1</span>)*PowerBase10(length - <span class="hljs-number">2</span>);<span class="hljs-comment">//计算次高位开始的数出现1的次数</span><span class="hljs-keyword">int</span> numRecursive = NumberOf1(str + <span class="hljs-number">1</span>);<span class="hljs-comment">//递归计算从1开始到此数去掉最高位的数出现1的次数</span><span class="hljs-keyword">return</span> numFirstDigit + numOtherDigits + numRecursive;<span class="hljs-comment">//返回之和</span>&#125;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">NumberOf1Between1AndN_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>)<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">char</span> str[<span class="hljs-number">100</span>];<span class="hljs-built_in">sprintf</span>(str, <span class="hljs-string">"%d"</span>, n);<span class="hljs-comment">//将数字转化为字符串形式</span><span class="hljs-keyword">return</span> NumberOf1(str);&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络体系结构</title>
    <link href="/2020/06/29/computer-network-architecture/"/>
    <url>/2020/06/29/computer-network-architecture/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>这几天开始二刷希仁老师的著作。。。再一次开始感受网络的魅力。。。→_→</em> *</strong></p><blockquote><p><strong>当一个问题复杂且规模巨大时，可以将其转化为若干较小的局部问题。</strong></p></blockquote><p>网络世界的复杂性难以想象，<strong>不同的物理设备、不同的技术、采取不同的协议</strong>，这些因素都导致当今的网络结构异常复杂，因此对网络的处理办法采取<strong>层次划分</strong>的方法。</p><ol><li><p>层次划分的好处：</p><ul><li><p><strong>各层之间相互独立</strong>：每一层只实现一种相对独立的功能，它也不需要知道它的下一层如何实现，仅仅使用<strong>层间的接口</strong>所提供的服务</p></li><li><p><strong>灵活性好</strong>：当任何一层发生变化时，只要保证层间接口不变，则其余层均不会受到影响</p></li><li><p><strong>结构上可分割开</strong>：各层都可以采用最合适的技术实现</p></li><li><p><strong>易于实现和维护</strong></p></li><li><p><strong>促进标准化工作</strong></p></li></ul></li><li><p>计算机网络结构划分</p><ul><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE2MTQyMjIzNzg4?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="计算机网络体系结构"></p></li><li><p><strong>应用层（Application Layel）</strong>：通过应用进程间的交互来完成特定网络应用。<strong>应用层协议定义的是应用进程间通信和交互的规则。将应用层交互的数据单元称为报文</strong></p></li><li><p><strong>运输层（Transmission Layel）</strong>：<strong>负责向两个主机中进程之间通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文</strong>。其主要使用以下两种协议：</p><ul><li><p><strong>传输控制协议TCP（Transmission Control Protocol），其提供面向连接的、可靠的数据传输服务，其数据传输单位是报文段（Segment）</strong></p></li><li><p><strong>用户数据报协议UDP（User Datagram Protocol），其提供无连接的、尽最大努力交付的（Best-Effort）数据传输服务（不保证数据传输的可靠性），其数据传输的单位是用户数据报</strong></p></li></ul></li><li><p><strong>网络层（Network Layel）：</strong></p><ul><li><p>负责为分组交换网上的不同主机提供服务。<strong>网络层把运输层产生的报文段或用户数据报封装成分组或包（Packet）进行传送，一般称为IP数据报</strong></p></li><li><p><strong>选择合适的路由</strong>，使源主机运输层所传下来的分组能够通过网络中的路由器找到目的主机</p></li></ul></li><li><p><strong>数据链路层（Data Link Layel）</strong>：<strong>在两个节点之间传送数据时，数据链路层·将网络层交下来的IP数据报组装成帧（Frame），在两个相邻节点间的链路上传送帧</strong></p></li></ul></li></ol><ul><li><strong>物理层（Physical Layel）</strong>：在物理层上所传数据的单位时比特</li></ul><ol start="3"><li><p>网络中数据的传递方向</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE2MTU0NDUxMjUy?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="数据传递过程"><br> <strong>数据在协议的操作下，一层层封装，再一层层解封，每一层都认为自己和相同层在直接进行数据传递。层次划分很好的解决了复杂的网络问题。</strong></p></li></ol><p><strong>* <em>这次是对网络体系结构的总体说明，今后会对不同层的协议继续进行详细解释。。。</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（30）连续子数组的最大和</title>
    <link href="/2020/06/29/maximum-sum-of-consecutive-subarrays/"/>
    <url>/2020/06/29/maximum-sum-of-consecutive-subarrays/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">//求连续子段最大和时的过程中可能有两种情况</span><span class="hljs-comment">//1.计算到array[i]时，如果CurrentSum为负数，此时说明：</span><span class="hljs-comment">//(1)若加array[i]，则CurrentSum的值比array[i]还要小，所以应该放弃前面的子段，从array[i]开始重新计算子段和</span><span class="hljs-comment">//(2)否则将array[i]继续纳入此子段，且CurrentSum += array[i]</span><span class="hljs-comment">//2.比较当前子段和CurrentSum与历史最大子段和GreatestSum的大小，对GreatestSum进行更新</span><span class="hljs-comment">//注意判断arrry是否有效</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">int</span> FindGreatestSumOfSubArray(vector&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-built_in">array</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//防御性动作</span><span class="hljs-built_in">int</span> CurrentSum = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前最大子段和</span><span class="hljs-built_in">int</span> GreatestSum = <span class="hljs-number">0x80000000</span>;<span class="hljs-comment">//历史最大子段和，因为GreatestSum有可能为负数，所以其初始化为int类型的最小值</span><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">array</span>.size(); ++i)&#123;<span class="hljs-keyword">if</span> (CurrentSum &lt; <span class="hljs-number">0</span>)如果CurrentSum已经为负数，即从<span class="hljs-built_in">array</span>[i]开始重新计算子段和CurrentSum = <span class="hljs-built_in">array</span>[i];<span class="hljs-keyword">else</span><span class="hljs-comment">//否则将array[i]纳入当前子段</span>CurrentSum += <span class="hljs-built_in">array</span>[i];<span class="hljs-keyword">if</span> (GreatestSum &lt; CurrentSum)<span class="hljs-comment">//更新GreatestSum</span>GreatestSum = CurrentSum;&#125;<span class="hljs-keyword">return</span> GreatestSum;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（29）最小的k个数</title>
    <link href="/2020/06/29/the-smallest-k-number/"/>
    <url>/2020/06/29/the-smallest-k-number/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs arduino"><span class="hljs-comment">//测试用例中给出的返回值是有序的。。啧啧。。</span><span class="hljs-comment">//找到序列中最小的k个数，利用set，对数字进行insert或erase</span><span class="hljs-comment">//红黑树中查找、插入、删除操作都为 O（logk）</span><span class="hljs-comment">//最终将set中存储的值返回值vector中</span><span class="hljs-comment">//方法不改变原vector</span><span class="hljs-comment">//注意：</span><span class="hljs-comment">//1.判断传入的vector是否为空</span><span class="hljs-comment">//2.判断传入的k是否合法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; input, <span class="hljs-keyword">int</span> k)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; output;<span class="hljs-keyword">if</span> (input.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">0</span> || k &lt;= <span class="hljs-number">0</span> || k &gt; input.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> output;<span class="hljs-comment">//防御性动作</span><span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; se;<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; input.<span class="hljs-built_in">size</span>(); ++i)<span class="hljs-comment">//遍历原vector中的所有数</span>&#123;<span class="hljs-keyword">if</span> (i &lt; k)<span class="hljs-comment">//如果set中的个数小于k，则直接插入</span>se.insert(input[i]);<span class="hljs-keyword">else</span><span class="hljs-comment">//否则将set中的最大值和vector中第i个数比较</span>&#123;it = --se.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//取set中的最大值</span><span class="hljs-keyword">if</span> (*it &gt; input[i])<span class="hljs-comment">//若set中的最大值大于vector中第i个数</span>&#123;se.erase(it);<span class="hljs-comment">//删除set中的最大值</span>se.insert(input[i]);<span class="hljs-comment">//插入vector中第i个数</span>&#125;&#125;&#125;it = se.<span class="hljs-built_in">begin</span>();<span class="hljs-keyword">for</span> (; it != se.<span class="hljs-built_in">end</span>(); ++it)<span class="hljs-comment">//将set中的数以vector形式return</span>&#123;output.push_back(*it);&#125;<span class="hljs-keyword">return</span> output;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——进程的堆</title>
    <link href="/2020/06/29/process-heap/"/>
    <url>/2020/06/29/process-heap/</url>
    
    <content type="html"><![CDATA[<p> <strong>* <em>本次只是简要的总结堆的基本情况，具体的函数分析和堆算法分析今后会继续再学习。。。→_→</em> *</strong></p><blockquote><p><strong>程序在任意时刻都可能会发出请求，申请或释放一段内存资源，堆由此而生。</strong></p></blockquote><ol><li><strong>堆(Heap)</strong></li></ol><ul><li><p>堆是一块巨大的内存空间，占据虚拟空间的绝大部分。在这片空间里，<strong>程序可以请求一块连续内存并自由使用，这块内存在程序主动释放之前一直保持有效</strong></p></li><li><p><strong>程序向操作系统申请一块适当大小的堆空间，程序自己管理这块空间。管理堆空间分配的一般是程序的运行库，运行库向操作系统“批发”了一大块堆空间，然后“零售”给程序用。当全部“售完”或程序有已满足不了的更大内存需求时，再向操作系统“进货”</strong></p></li></ul><ol start="2"><li><strong>Linux进程堆管理</strong><br>Linux下的进程堆管理提供了两种堆空间分配方式（系统调用）：</li></ol><ul><li><p><strong><code>int brk(void *end_data_segment);</code></strong></p><pre><code>- **作用为设置进程数据段的结束地址，即扩大或缩小数据段重点内容**。将数据段的结束地址向高地址移动为扩大空间，反之亦然- **sbrk**与之类似，其**以一个增量（Increment）作为参数，表示需要增加或减少的空间大小，返回值为增加或减少后的数据段结束地址，实际上是对brk 系统调用的包装**</code></pre></li><li><p><strong><code>void* mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);</code></strong></p><ul><li><p>作用为<strong>向操作系统申请一段虚拟地址空间</strong>，这块虚拟地址空间也可以映射到文件，当其映射到文件时，称这块空间为<strong>匿名空间（Anonymous Space）</strong>，匿名空间就可以作为堆空间</p></li><li><p>第一、二个参数表示需要<strong>申请的空间的起始地址和长度</strong>，如果<strong>起始地址设置为0，那么Linux系统自动挑选合适的起始地址</strong></p></li><li><p>第三、四个参数表示<strong>申请空间的权限</strong>（可读、可写、可执行）和<strong>映射类型</strong>（文件映射、匿名空间）</p></li><li><p>第五、六个参数表示<strong>当文件映射时指定文件描述符和文件偏移</strong></p></li></ul><p><strong>glibc中的malloc函数</strong>处理请求方式如下</p><ul><li>当请求<strong>小于128KB</strong>时，在<strong>现有堆空间中</strong>，按照<strong>堆分配算法</strong>为其分配一块空间并返回</li><li>当请求<strong>大于128KB</strong>时，使用<strong>mmap()函数为其分配一块匿名空间</strong>，在这个匿名空间中为用户分配空间</li><li><strong>系统虚拟空间申请函数，申请的空间的起始地址和大小必须是系统页大小的整数倍</strong></li><li>影响malloc申请的最大空间大小的因素：<strong>系统资源限制（ulimit）</strong>、<strong>物理内存和交换空间的总和</strong>。因为<strong>mmap申请匿名空间时，系统会为它在内存或交换空间中预留地址，但申请空间的大小不能超过空闲内存和空闲交换空间的总和</strong></li></ul></li></ul><ol start="3"><li><strong>堆分配算法</strong>：管理一大块连续的内存空间，按照需求分配或释放其中的空间</li></ol><ul><li><p><strong>空闲链表（Free List）</strong>：<strong>把堆中各个空闲的块按照链表的方式连接起来，当用户请求一块空间时，遍历整个列表，直到找到合适大小的块并将它拆分；当用户释放空间时将它合并到空闲链表中</strong></p><pre><code>数据结构：在堆里的每一个**空闲空间的开头或结尾有一个头（header）**，头结构中记录了**上一个（prev）和下一个（next）空闲块的地址**，即所有的空闲块形成了一个空闲链表。</code></pre><p>  <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA0MTUwMzA1NjI1?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="空闲链表分配"></p><pre><code>具体分配算法：- **在空闲链表中查找足够容纳请求大小的一个空闲块，将其分成两块，一部分为程序请求的空间，另一部分为剩余的空闲空间**- **将空闲链表进行更新，若剩余的空闲块大小为0，则直接从空闲链表中删除**    ![空闲链表更新](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA0MTUyMzAyOTY1?x-oss-process=image/format,png)- 释放时需要知道资源大小，所以当**分配k个字节资源时，实际分配k+4个字节资源，这4个字节用于存储该分配资源的大小**，因此释放时查看这4个字节的值就能知道该内存块的大小再将其插入到空闲链表中</code></pre></li><li><p><strong>位图（Bitmap）</strong>：<strong>将整个堆划分为许多相同大小的块（block），当用户请求资源时，分配给用户整数个块空间</strong>。第一个块称为已分配区域的<strong>头（head）</strong>，其余的块称为已分配区域的<strong>主体（Body）</strong>。因此每个块只有<strong>头/主体/空闲三种状态，只需要两位二进制位即可表示一个块</strong>。</p><pre><code>数据结构：使用**整数数组记录块的使用情况****使用11表示H（Head），10表示主体（Body），00表示空闲（Free）**对应的位图为：（High）11-00-00-10-10-10-11-00-00-00-00-00-00-00-10-11![位图分配方式](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA0MTY1OTQ0NDI5?x-oss-process=image/format,png)分配算法特点：优点：- **速度快**：整个堆的空闲信息存储在一个数组中，因此访问该数组时cache容易命中- **稳定性好**：即使部分数据被破坏，也不会导致整个堆的无法工作- **块不需要额外信息，易于管理**缺点：- **分配内存时容易产生内存碎片**- 如**果堆很大或设置的块很小，那么位图将会很大，可能失去cache命中率高的优势而且会浪费空间**</code></pre></li><li><p><strong>对象池</strong>：<strong>把整个堆空间划分为大量小块每次请求时只需要找到一个小块</strong> </p><pre><code>- 数据结构：可采用空闲链表、位图等    区别在于，它**假定每次请求的都是一个固定大小，由于每次只请求一个单位的内存，因此请求得到满足的速度很快，无需查找一个足够大的空间**- 具体分配算法：    在现实应用中，堆的分配算法一般是多种算法复合而成的。**在Glibc中，当申请的空间资源小于64字节时，采用类似于对象池的方法；当大于64字节且小于512字节时，采用上述方法中的最佳折中策略；当大于512字节时，采用最佳适配算法；当大于128KB时，直接使用mmap向操作系统申请空间**</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——进程的栈</title>
    <link href="/2020/06/29/process-stack/"/>
    <url>/2020/06/29/process-stack/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>内存是承载程序的介质，是程序进行运算和表达的场所。</strong></p></blockquote><p><strong>未有特殊说明，则默认在32bit操作系统中。</strong></p><h2 id="1-程序的内存布局"><a href="#1-程序的内存布局" class="headerlink" title="1. 程序的内存布局"></a><strong>1. 程序的内存布局</strong></h2><p><strong>操作系统会将内存空间中的一部分分给内核使用，应用程序无法访问这段内存，这段内存被称为内核空间</strong>。Windows默认情况将高地址的2GB空间分配给内核，Linux默认情况将高地址的1GB空间分配给内核。<br>剩下的内存空间称为用户空间，用户空间中有许多默认区域。</p><ul><li><p><strong>栈</strong>：栈用于维护函数调用的上下文。<strong>栈通常在用户空间的最高地址处分配</strong>，一般大小位数兆字节</p></li><li><p><strong>堆</strong>：堆用来容纳应用程序动态分配的内存区域。<strong>堆通常在栈的下方（低地址方向）</strong>。堆一般比栈大可以有几十至数百兆字节的容量</p></li><li><p><strong>可执行文件映像</strong>：存储着可执行文件在内存里的映像。</p></li><li><p><strong>保留区</strong>：保留区不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称</p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAxMTA0MzM0MjM5?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="Linux地址空间布局"></p></li><li><p><strong>栈向低地址增长，堆向高地址增长</strong>。当栈或堆现有的大小不够用时，它们将按照增长方向扩大，直到预留的的空间被用完为止</p></li></ul><h2 id="2-栈（stack）"><a href="#2-栈（stack）" class="headerlink" title="2. 栈（stack）"></a><strong>2. 栈（stack）</strong></h2><ul><li><p><strong>将数据压入栈中（入栈，push），将已经压入栈中的数据弹出（出栈，pop），即先入栈的数据后出栈（First In Last Out，FIFO）</strong></p></li><li><p>压栈操作使栈增大，弹出操作使栈减小</p></li><li><p>栈总是向低地址增长的，栈顶由esp寄存器进行定位，栈底由ebp寄存器进行定位。压栈操作使栈顶地址减小，弹出操作使栈顶地址增大</p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAxMTEwNjE4NTU4?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="程序栈实例"></p></li><li><p><strong>栈保存了一个函数调用所需要的维护信息，其被称为栈帧（Stack Frame）或活动记录（Activate Record）</strong>，栈帧包含如下内容：</p><ul><li><p>函数的<strong>返回地址和参数</strong></p></li><li><p><strong>临时变量</strong>：包括<strong>函数的非静态局部变量</strong>、编译器自动生成的其他临时变量</p></li><li><p><strong>保存的上下文</strong>： 包括在<strong>函数调用前后需要保持不变的寄存器</strong></p></li></ul></li><li><p>一个函数的活动范围由ebp和esp寄存器划定范围。<strong>esp寄存器始终指向栈的顶部即当前函数的活动记录的顶部</strong>，ebp寄存器指向函数活动记录的底部，ebp寄存器也被称为帧指针（Frame Pointer）</p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAxMTExNzExMjgy?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="活动记录"></p></li><li><p>i386下的函数调用步骤如下</p><ul><li><p>把所有或一部分<strong>参数压入栈中</strong>，如果有其他参数没有入栈，那么使用某些特定的寄存器传递</p></li><li><p>把<strong>当前指令的下一条指令的地址压入栈中</strong></p></li><li><p><strong>跳转到函数体执行</strong></p></li><li><p>第二、三步由指令call一起执行</p></li></ul></li><li><p>i386下的函数体“标准”开头如下</p><ul><li><p><strong>push ebp（保存本栈帧的ebp）</strong></p></li><li><p><strong>mov ebp， esp（将ebp移动到栈顶）</strong></p></li><li><p><strong>sub esp， XXX（开辟新的栈帧）</strong></p></li><li><p><strong>push XXX（保存寄存器）</strong></p></li></ul></li><li><p>i386下的函数体“标准”结束如下</p><ul><li><p><strong>pop XXX（恢复寄存器）</strong></p></li><li><p><strong>mov esp， ebp（恢复成调用者所在栈帧的栈顶）</strong></p></li><li><p><strong>pop ebp（恢复成调用者所在栈帧的栈基址）</strong></p></li><li><p><strong>ret（从栈顶取得下一条指令的地址，并跳转）</strong></p></li></ul></li><li><p>示例如下</p><ul><li><p>测试代码<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTExNjQwMjg4?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="测试代码"></p></li><li><p>main函数反汇编<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTExODM5MDc5?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="main反汇编"></p></li><li><p>foo函数反汇编<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTEzMzU2Mjc0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="foo反汇编"></p></li><li><p>foo函数return之前时寄存器<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTEzNzQzMTIw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="foo函数返回之前时寄存器"></p></li><li><p>foo函数return之前时内存<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTE0MTI2NDk3?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="foo函数返回之前时内存"></p></li><li><p>foo函数反汇编代码解析<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTE0NjQxMTI2?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="foo函数反汇编代码解析"></p></li></ul></li><li><p><strong>某些场合，编译器生成函数的进入和退出指令序列不按照标准的方式进行</strong>，比如C函数满足：</p><ul><li><p><strong>函数被声明为static</strong>（不可在此编译单元之外访问）</p></li><li><p><strong>函数在本编译单元仅被直接调用，没有显示或隐式的取地址</strong>（即没有任何函数指针指向过这个函数）</p></li><li><p><strong>编译器确信满足这两条的函数不会在其他编译单元内被调用，因此可以修改指令，达到优化目的</strong></p></li></ul></li><li><p><strong>函数调用惯例（Calling Convention）</strong></p><ul><li><p><strong>函数参数的传递顺序和方式</strong>：规定函数调用方将参数压入栈的顺序（从左到右、从右至左）；规定函数参数的传递方式（通过栈传递，函数调用方将参数压入栈，自己在从栈中将参数取出、使用寄存器传递，提高性能）</p></li><li><p><strong>栈的维护</strong>：函数体执行完后，之前压入栈中的参数需要弹出，可以由函数调用方完成，也可以由函数体本身完成</p></li><li><p><strong>名字修饰（Name-mangling）策略</strong>：链接时区分调用惯例，不同的调用惯例有不同的名字修饰策略</p></li><li><p><strong>C语言默认调用惯例是cdecl</strong>，任何一个没有显式指定调用惯例的函数都默认是cdecl，比如：<code>int _cdecl foo(int a, int b, int c)</code></p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTIwODE1OTgy?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="函数调用惯例"></p></li></ul></li><li><p>函数返回值传递</p><ul><li>当返回值小于等于4字节时，函数将返回值存储在eax，调用者读取eax</li><li>当返回值大于4字节，小于等于8字节时，函数使用eax和edx联合返回的方式。eax存储低4字节，edx高4字节</li><li>当返回值大于8字节时，函数会使用一个临时的栈上内存空间（临时对象）作为中转，返回值对象会被拷贝两次</li><li>当返回值大于8字节时，函数返回值传递示例如下：<ul><li>函数返回值传递测试代码<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTMwNzIzMDcx?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="函数返回值传递测试代码"></li><li>main函数返回值反汇代码<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTMxMzIyMTgw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="main返回值反汇编"></li><li>return_test函数反汇编代码<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTMxNTE1NjY3?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="return_test反汇编"></li><li>main函数中n的地址<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTMyMzU3MjI1?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="main中n的地址"></li><li>临时对象给main函数中的n赋值<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTMyNDQzNzEx?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="临时对象给n赋值"></li></ul></li><li>首先调用者在栈上将一部分空间作为传递返回值的临时对象</li><li>将临时对象的地址作为隐藏参数传递给函数</li><li>函数将数据拷贝给临时对象，并将临时对象的地址用eax传出</li><li>函数返回后，调用者将eax指向临时对象的内容拷贝给局部变量</li><li>返回值传递流程<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjAyMTMzMTI1ODYx?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="返回值传递流程"></li><li>需要注意的是返回对象的拷贝情况完全不具备可移植性，不同的编译器产生的结果可能不同。函数传递大尺寸的返回值所使用的方法不是可移植的，不同编译器、不同平台、不同调用惯例、不同编译参数可能采用不同的实现方法</li><li>在C++中要使用返回值优化技术（Return Value Optimization， RVO），直接将对象构造在临时对象上，减少一次从函数内局部变量对临时对象的拷贝构造步骤<pre><code class="hljs aspectj">cpp_obj return_test()&#123;<span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">cpp_obj</span><span class="hljs-params">()</span></span>;&#125;</code></pre></li></ul></li></ul><p><strong>* <em>码字好累。。。→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——静态链接</title>
    <link href="/2020/06/29/static-link/"/>
    <url>/2020/06/29/static-link/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>赶紧结束这本书的总结。。太拖了。。→_→</em> *</strong></p><h1 id="第四章-静态链接"><a href="#第四章-静态链接" class="headerlink" title="第四章 静态链接"></a><strong>第四章 静态链接</strong></h1><h2 id="1-链接器的空间与地址分配"><a href="#1-链接器的空间与地址分配" class="headerlink" title="1.链接器的空间与地址分配"></a><strong>1.链接器的空间与地址分配</strong></h2><blockquote><p><strong>链接器为目标文件分配地址和空间</strong><br><strong>可执行文件中的代码段和数据段由输入的目标文件中合并而来。</strong></p></blockquote><ul><li><p><strong>按序叠加：直接将各个目标文件依次合并</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTMwMjAzODU2MTY2?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="简单的分配策略"><br>缺点：若有多个目标文件，则可能造成输出文件中有很多<strong>零散的段</strong>。每个段都有空间对齐要求，可能<strong>造成内存空间的大量内部碎片</strong>。</p></li><li><p><strong>相似段合并：将相同性质的段合并到一起</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTMwMjA0NjE2MDI2?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="实际的内存分配"></p></li></ul><ul><li><p>“.bss”段在目标文件和可执行文件中并不占用文件的空间（此空间指实际的<strong>物理数据空间</strong>），但其在装载时占用地址空间（此空间指<strong>虚拟地址空间</strong>）。</p></li><li><p>使用此策略的链接器一般都是<strong>两步链接（Two-pass Linking）</strong><br>第一步：<strong>空间地址分配</strong>。扫描所有的输入目标文件，获取各段长度、属性和位置，将它们合并，计算出输出文件中各段合并后的长度和位置，并<strong>建立映射关系</strong>（此时为合并之后的各段分配虚拟地址）。<strong>将符号表中的符号定义和符号引用收集，统一放到一个全局符号表</strong>。<br>第二步：<strong>符号解析与重定位</strong>。读取输入文件中段的数据、重定位信息，<strong>进行符号的解析与重定位、调整代码中的地址</strong>。</p></li></ul><h2 id="2-链接器的符号解析与重定位"><a href="#2-链接器的符号解析与重定位" class="headerlink" title="2.链接器的符号解析与重定位"></a><strong>2.链接器的符号解析与重定位</strong></h2><ul><li><p><strong>重定位</strong>：<strong>目标文件在链接的空间分配之前，代码段中的起始地址为0x00000000。</strong>编译器在<strong>编译阶段</strong>使用<strong>临时的假地址表示未知符号的地址</strong>，而将真正的地址计算工作留给链接器。链接器完成空间与地址分配后，<strong>根据符号的虚拟地址对每个需要重定位的指令进行修正</strong>。</p></li><li><p><strong>重定位表（Relocation Table）</strong>：保存与重定位相关的信息，用来描述如何修改相应的指令。<strong>每个要被重定位的ELF段都有一个对应的重定位表（或叫重定位段）</strong>。比如：“.rel.text”、“.rel.data”。</p></li><li><pre><code>//重定位表结构typedef struct{      //被重定位的地方叫**重定位入口（Relocation Entry）**      //表示重定位入口的**偏移**      //对于可重定位文件，即**所要修正的位置的第一个字节相对段起始的偏移**      //对于可执行文件或共享对象文件，即**所要修正的位置的第一个字节的虚拟地址**      Elf32_Addr r_offset;      //**重定位入口的类型和符号**，低8位表示重定位入口的类型，高24位表示重定位入口的符号在符号表中的下标       Elf32_Word r_info;}Elf32_Rel;</code></pre></li><li><p><strong>符号解析</strong>：重定位的过程中，<strong>每个重定位的入口都是一个符号的引用</strong>，当链接器对某个符号的引用进行重定位时，链接器会去<strong>查找由所有输入目标问价的符号表组成的全局符号表</strong>，找到相应的符号后进行重定位。</p></li></ul><h2 id="3-C-与静态链接的问题"><a href="#3-C-与静态链接的问题" class="headerlink" title="3.C++与静态链接的问题"></a><strong>3.C++与静态链接的问题</strong></h2><ul><li><p><strong>C++编译器可能在不同的编译单元中生成相同的代码</strong>（模板（Templates）、外部内联函数（Extern Function）、虚函数表（Virtual Function Table））。<br>若不消除重复代码，可能造成<strong>空间浪费、地址出错（两个函数指针不相等）、指令运行效率低（CPU对指令和数据进行缓存，副本过多造成指令Cache命中率低）</strong></p></li><li><p>解决方法：<strong>将每个模板的实例代码都单独存放在一个段里，每个段只包含一个模板实例</strong>。这样链接器在最终链接时可以区分相同的模板实例段，将它们合并入代码段。</p></li><li><p>GCC中叫做“<strong>Link Once</strong>”，将此类段命名为“.gun.linkonce.name”，“<strong>name”是该模板函数实例的修饰后名称</strong></p></li><li><p>当用到某个目标文件中的一个函数或变量时，需要将其整个链接，随着文件数量地增多，造成输出文件越来越大。<br>Visual C++中使用<strong>函数级别链接（Function-Level Linking）</strong>选项，其作用就是让<strong>所有的函数都单独保存到一个中，当链接器用到它时，就将其合并到输出文件中，抛弃没有用到的函数</strong>。<br>这种方减少了输出文件地大小，减少了空间浪费。但会减慢编译和链接过程，因为链接器要计算个函数之间的依赖关系，且目标函数段数量增大，重定位过程也会变得复杂。</p></li></ul><h2 id="4-静态库链接"><a href="#4-静态库链接" class="headerlink" title="4.静态库链接"></a><strong>4.静态库链接</strong></h2><ul><li><strong>静态库是一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件</strong></li><li><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTMxMTE1NzQ1OTE3?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="静态库链接"></li><li>链接器自动寻找所有需要的符号及其所在的目标文件从静态库中“解压”出来</li><li><strong>静态库中的一个目标文件只包含一个函数</strong>，每个函数独立的存放在一个目标文件中可以尽量减少空间浪费</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（28）数组中出现次数超过一半的数字</title>
    <link href="/2020/06/29/more-than-half-of-the-occurrences-in-the-array/"/>
    <url>/2020/06/29/more-than-half-of-the-occurrences-in-the-array/</url>
    
    <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p><strong>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</strong></p></blockquote><p>实现如下：</p><pre><code class="hljs swift"><span class="hljs-comment">//方法一</span><span class="hljs-comment">//原理：数组中出现次数超过一半的数字，在其有序序列中就是中位数</span><span class="hljs-comment">//利用partition的作用：将某个数字，放到它应该在的位置，而将其他数分类摆放，比它小的放它前面，比它大的放它后面</span><span class="hljs-comment">//注意：</span><span class="hljs-comment">//1.测试用例中可能存在重复的数，所以必须在判断条件的上注意稳定性</span><span class="hljs-comment">//2.防御性动作</span><span class="hljs-comment">//3.测试用例中有可能不存在满足条件的数，即出现次数最多的数都没有超过一半</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">public</span>:int <span class="hljs-built_in">partition</span>(vector&lt;int&gt;arr, int <span class="hljs-keyword">left</span>, int <span class="hljs-keyword">right</span>)&#123;int tmp = arr[<span class="hljs-keyword">left</span>];<span class="hljs-keyword">while</span> (<span class="hljs-keyword">left</span> &lt; <span class="hljs-keyword">right</span>)<span class="hljs-comment">//直到left和right重合，此时合适位置找到</span>&#123;<span class="hljs-keyword">while</span> (arr[<span class="hljs-keyword">right</span>] &gt;= tmp &amp;&amp; <span class="hljs-keyword">left</span> &lt; <span class="hljs-keyword">right</span>)<span class="hljs-comment">//等于号考虑稳定性</span>&#123;<span class="hljs-keyword">right</span>--;&#125;arr[<span class="hljs-keyword">left</span>] = arr[<span class="hljs-keyword">right</span>];<span class="hljs-keyword">while</span> (arr[<span class="hljs-keyword">left</span>] &lt;= tmp &amp;&amp; <span class="hljs-keyword">left</span> &lt; <span class="hljs-keyword">right</span>)<span class="hljs-comment">//等于号考虑稳定性</span>&#123;<span class="hljs-keyword">left</span>++;&#125;arr[<span class="hljs-keyword">right</span>] = arr[<span class="hljs-keyword">left</span>];&#125;arr[<span class="hljs-keyword">left</span>] = tmp;<span class="hljs-comment">//将tmp放在它应该在的位置</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">left</span>;&#125;bool checkNumber(vector&lt;int&gt; numbers, int number)<span class="hljs-comment">//检查结果是否满足条件</span>&#123;int time = <span class="hljs-number">0</span>;<span class="hljs-comment">//计数器</span><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; numbers.size(); ++i)&#123;<span class="hljs-keyword">if</span> (numbers[i] == number)++time;&#125;<span class="hljs-keyword">if</span> (time*<span class="hljs-number">2</span> &lt;= numbers.size())<span class="hljs-comment">//判断出现的次数是否超过一半</span><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;int <span class="hljs-type">MoreThanHalfNum_Solution</span>(vector&lt;int&gt; numbers)&#123;<span class="hljs-keyword">if</span> (numbers.empty())<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;int middle = numbers.size() / <span class="hljs-number">2</span>;int <span class="hljs-keyword">left</span> = <span class="hljs-number">0</span>;int <span class="hljs-keyword">right</span> = numbers.size() - <span class="hljs-number">1</span>;int pa = <span class="hljs-built_in">partition</span>(numbers, <span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span>);<span class="hljs-comment">//先进行一次partition</span><span class="hljs-keyword">while</span> (middle != pa)<span class="hljs-comment">//判断是否为中位数</span>&#123;<span class="hljs-keyword">if</span> (pa &lt; middle)<span class="hljs-comment">//如果位置小于中位数，则对pa的右边partition</span>&#123;<span class="hljs-keyword">left</span> = pa + <span class="hljs-number">1</span>;pa = <span class="hljs-built_in">partition</span>(numbers, <span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pa &gt; middle)<span class="hljs-comment">//如果位置大于中位数，则对pa的左边partition</span>&#123;<span class="hljs-keyword">right</span> = pa - <span class="hljs-number">1</span>;pa = <span class="hljs-built_in">partition</span>(numbers, <span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span>);&#125;&#125;<span class="hljs-keyword">if</span> (checkNumber(numbers, numbers[middle]))<span class="hljs-comment">//判断结果是否满足条件</span><span class="hljs-keyword">return</span> numbers[middle];<span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;&#125;;</code></pre><pre><code class="hljs angelscript"><span class="hljs-comment">//方法二</span><span class="hljs-comment">//方法二可以不用改变vector</span><span class="hljs-comment">//数组中出现次数超过一半的数字，其出现的次数一定比其他数出现次数总和还要多</span><span class="hljs-comment">//设置一个计数器time，等于res，++time；不等于res，若time==0，则替换res,计数器置1，否则--time</span><span class="hljs-comment">//注意：</span><span class="hljs-comment">//1.防御性动作</span><span class="hljs-comment">//2.判断结果是否满足条件</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">bool</span> checkNumber(vector&lt;<span class="hljs-built_in">int</span>&gt; numbers, <span class="hljs-built_in">int</span> number)<span class="hljs-comment">//判断结果是否满足条件</span>&#123;<span class="hljs-built_in">int</span> time = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.size(); ++i)&#123;<span class="hljs-keyword">if</span> (numbers[i] == number)++time;&#125;<span class="hljs-keyword">if</span> (time * <span class="hljs-number">2</span> &lt;= numbers.size())<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-built_in">int</span> MoreThanHalfNum_Solution(vector&lt;<span class="hljs-built_in">int</span>&gt; numbers) &#123;<span class="hljs-keyword">if</span> (numbers.empty())<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> time = <span class="hljs-number">0</span>;<span class="hljs-comment">//计数器初始化为0</span><span class="hljs-built_in">int</span> res = numbers[<span class="hljs-number">0</span>];<span class="hljs-comment">//记录结果</span><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.size(); ++i)&#123;<span class="hljs-keyword">if</span> (res == numbers[i])<span class="hljs-comment">//若与结果相同，计数器自加</span>++time;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (time == <span class="hljs-number">0</span>)<span class="hljs-comment">//此时res进行替换，将新res的time置为1</span>&#123;res = numbers[i];++time;&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//否则，计数自减</span>--time;&#125;&#125;<span class="hljs-keyword">if</span> (checkNumber(numbers, res))<span class="hljs-comment">//判断结果是否满足条件</span><span class="hljs-keyword">return</span> res;<span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——符号、引用、COMMON块</title>
    <link href="/2020/06/29/symbols-references-COMMON-blocks/"/>
    <url>/2020/06/29/symbols-references-COMMON-blocks/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>好久都没更这个了。。。请叫我拖更大魔王。。。→_→</em> *</strong></p><p><strong>* <em>这一篇看下来，对符号的理解更深了。。。</em> *</strong></p><blockquote><p><strong>在链接过程中，目标文件之间相互拼合实际上是目标文件之间对函数和变量的地址的引用。</strong></p><p><strong>在链接中，将函数和变量称为符号（Symbol），函数名和变量名为符号名（Symbol Name）。</strong> </p></blockquote><ol><li><p><strong>符号表（Symbol Table）</strong><br>每一个目标文件都有一个<strong>符号表（Symbol Table）</strong>，表中<strong>记录目标文件中所用到的所有符号</strong>。每个定义的符号有一个对应的<strong>符号值（Symbol Value）</strong>，对函数和变量来说，<strong>符号值就是其地址</strong>。<br>符号表中的所有符号分类：</p><ul><li><p>定义在<strong>本目标文件的全局变量，可以被其他目标文件引用</strong></p></li><li><p>在<strong>本目标文件中引用的全局符号，没有定义在本目标文件，称为外部符号（External Symbol）</strong></p></li><li><p>段名，由编译器产生，其值为该段的起始地址</p></li><li><p>局部符号，其只在编译单元内部可见</p></li><li><p>行号信息，可选</p></li></ul></li><li><p><strong>ELF符号表结构</strong><br>ELf文件的<strong>符号表是文件中的”.symtab“段</strong>。其结构是一个<strong>Elf32_Sym结构的数组，每一个元素对应一个符号。这个数组下标为0的元素为无效的“未定义”符号。</strong></p> <pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>Elf32_Word st_name;<span class="hljs-comment">//符号名。即该符号名在字符串表中的下标。</span>Elf32_Addr st_value;<span class="hljs-comment">//符号相对应的值。不同符号对应的值不一样。</span>Elf32_Word st_size;<span class="hljs-comment">//符号大小。包含数据的符号，该值为该数据类型大小。若该值为0，表示该符号大小为0或未知。</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> st_info;<span class="hljs-comment">//符号类型和绑定信息。低4位表示符号类型（Symbol Type），高28位表示符号绑定信息（Symbol Binding）。</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> st_other;<span class="hljs-comment">//目前为0，没用</span><span class="hljs-comment">//符号所在的段。如果符号定义在本目标文件中，其表示符号所在段在段表中的下标。若为0，表示在本目标文件中被引用，定义在其他目标文件中。</span>Elf32_Half at_shndx;&#125;Elf32_Sym;</code></pre></li></ol><p><strong>符号值（st_value）</strong>分类：</p><ul><li>在目标文件中，如果符号定义<strong>不是“COMMON块”</strong>类型，则符号值表示<strong>该符号在段中的偏移</strong>。</li><li>在目标文件中，如果符号<strong>是“COMMON块”类型</strong>，则符号值表示<strong>该符号的对其属性</strong>。</li><li><strong>在可执行文件中，符号值表示符号的虚拟地址</strong>。</li></ul><ol start="3"><li><strong>符号修饰与函数签名</strong></li></ol><p><strong>UNIX下的C语言规定，C语言代码源文件中的所有全局变量和函数经过编译后，相对应的符号名前加上下划线</strong>。<br>eg.Windows下的Visual C++编译器，C语言函数“foo”，编译后的符号名是“_foo”。<strong>Linux下的GCC编译器默认情况已经去掉了此方式</strong>。<br><strong>C++中增加了名称空间（Namespace）解决多模块的符号冲突问题</strong>。</p><ul><li><p><strong>符号修饰（Name Decoration）</strong> /<strong>符号改编（Name Mangling）</strong><br>C++中允许多个<strong>不同的参数类型</strong>的函数拥有<strong>相同的名字</strong>，即<strong>函数重载</strong>。<br>C++在语言级别支持<strong>名称空间</strong>，即允许在<strong>不同的名称空间</strong>中有多个<strong>同样名字的符号</strong>。</p></li><li><p><strong>函数签名（Function Signature）</strong><br>其包含了一个函数的信息，包括<strong>函数名、参数类型、所在的类和名称空间</strong>及其他信息。</p></li></ul><p><strong>函数签名用于识别不同的函数</strong>，函数的名字是函数签名的一部分。<br>在编译器及链接器处理符号时，它们使用某种<strong>名称修饰</strong>方法，使的每个函数签名对应一个<strong>修饰后名称（Decorated Name）</strong>。即<strong>目标文件中的符号名是函数和变量的修饰后名称</strong>。</p><ul><li>名称修饰机制也用在C++中的<strong>全局变量和静态变量</strong>。<strong>变量的类型并没有被加入到修饰后名称中</strong>。</li></ul><ol start="4"><li><p><strong>extern “C”</strong><br>C++为了与C兼容，在符号管理上，有一个用来声明或定义一个C的符号的“<strong>extern “C”</strong>”关键字。</p> <pre><code class="hljs cpp"><span class="hljs-comment">//大括号内部的代码当作C语言代码处理，C++的名称修饰机制将不起作用</span><span class="hljs-keyword">extern</span> “C”&#123;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-keyword">int</span> var;&#125;<span class="hljs-comment">//单独声明某个函数或变量为C语言的符号</span><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-keyword">int</span> var;<span class="hljs-comment">//C语言函数库中的string.h中的memset()如何在.c或.cpp中正确使用</span><span class="hljs-comment">//C++中必须使用extern "C"</span><span class="hljs-comment">//但C中不支持extern "C"语法</span><span class="hljs-comment">//因此利用C++中的宏”__cplusplus“，C++编译器在编译时默认定义这个宏</span><span class="hljs-comment">//使用条件宏自动判断选择哪种环境</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span>&#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">size_t</span>)</span></span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span>&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre></li><li><p><strong>强符号与弱符号</strong><br>多个目标文件中含有相同名字全局符号的定义，那么这些目标文件链接时将会出现<strong>符号重复定义</strong>错误。</p></li></ol><ul><li><p>C/C++语言中，编译器默认<strong>函数和初始化了的全局变量为强符号（Strong Symbol）</strong>，<strong>未初始化的全局变量为弱符号（Weak Symbol）</strong>。</p></li><li><p>通过GCC的”<strong>_ attribute _ ((weak))</strong>“<strong>定义任何一个强符号为弱符号</strong>。</p></li><li><p><strong>强符号和弱符号针对定义，不是针对符号的引用。</strong></p><p>链接器按照如下规则处理与选择被多次定义的全局符号</p><ul><li><p>不允许强符号被多次定义（<strong>不同目标文件中不能有同名的强符号</strong>）。</p></li><li><p>如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么<strong>选择强符号</strong>。</p></li><li><p>如果一个符号在所有目标文件中都是弱符号，那么<strong>选择其中占用内存空间最大的一个</strong>。</p></li></ul></li></ul><ol start="6"><li><strong>强引用和若引用</strong></li></ol><ul><li><p>链接时，如果<strong>没有找到引用符号的定义</strong>，链接器报符号<strong>未定义错误</strong>，这种被称为<strong>强引用（Strong Reference）</strong>。</p></li><li><p>如果<strong>声明为弱引用（Weak Reference）</strong>，若引用的符号<strong>有定义</strong>，则链接器将<strong>该符号引用决议</strong>；若引用的符号<strong>未定义</strong>，链接器<strong>不报错</strong>，<strong>默认其为0或是一个特殊值</strong>。</p></li><li><p>在GCC中，使用”<strong>_ attribute _ ((weakref))”</strong>声明一个外部函数的引用为弱引用。</p>  <pre><code class="hljs cpp"><span class="hljs-comment">//GCC在链接时不会报错，但在运行可执行文件时，发生运行错误</span><span class="hljs-comment">//因为当要调用foo()时，其地址为0，发生非法地址访问的错误</span>__attribute__ ((weakref)) <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;foo();<span class="hljs-comment">//改成if(foo) foo();</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul><ol start="7"><li><strong>COMMON块</strong><br>弱符号机制允许同一个符号的定义存在于多个文件中。<strong>链接器本身不支持符号类型，只知道符号的名字</strong>。但当<strong>一个弱符号以不同的类型定义在多个目标文件中</strong>时，链接器如何区分？<br>多个符号有多个类型定义时：</li></ol><ul><li><p><strong>两个或两个以上强符号</strong>类型不一致。（<strong>非法。符号重定义</strong>）。</p></li><li><p>有<strong>一个强符号</strong>，<strong>其他都是弱符号</strong>，出现类型不一致。</p></li><li><p><strong>两个或两个以上弱符号</strong>类型不一致。</p><p>现在的编译器和链接器支持<strong>COMMON块（Common Block）机制</strong>。<strong>COMMON类型的链接规则是针对符号都是弱符号的情况</strong>。如果其中有<strong>一个强符号，最终符号所占空间欲强符号相同</strong>。如果<strong>有弱符号大小大于强符号，链接器报警告</strong>。</p><p>问题：为什么编译器<strong>把未初始化的全局变量标记为一个COMMON类型的变量</strong>，而<strong>不</strong>直接把它当作<strong>未初始化的局部静态变量，为其在BSS段分配空间。</strong></p><p>答：</p><ol><li><p><strong>编译时</strong>，若目标文件中含有弱符号（比如未定义的全局变量），则<strong>该弱符号最终所占内存空间大小无法确定</strong>，因为有<strong>可能其他目标文件中该弱符号所占内存空间比本单元弱符号所占内存空间大</strong>，所以此时无法在.BSS段为该弱符号分配空间。</p></li><li><p><strong>链接时</strong>，读取了所有目标文件，<strong>确定了任意一个弱符号的大小</strong>。这时<strong>才在最终输出文件的.BSS段中为其分配空间</strong>。</p></li><li><p>总体看来，<strong>未初始化的全局变量最终还是被放在.BSS段。</strong></p></li></ol><p>在GCC中使用”<strong>-fno-commom</strong>“或”<strong>_ <em>attribute</em> _((nocommom))</strong>“，使未初始化的全局变量不以COMMOM块的形式处理。即相当于一个<strong>强符号</strong>。</p></li></ul><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> global <span class="hljs-constructor">__attribute__((<span class="hljs-params">nocommom</span>)</span>)；</code></pre><p><strong>* <em>码字好累。。。下次再见喽。。。</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（27）字符串的排列</title>
    <link href="/2020/06/29/arrangement-of-strings/"/>
    <url>/2020/06/29/arrangement-of-strings/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</strong>                                                                                                                                                                                                     </p></blockquote><p><strong>输入描述：</strong></p><blockquote><p><strong>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</strong></p></blockquote><p><strong>其实之前已经写过全排列问题了。。。请戳传送门<a href="http://blog.csdn.net/kongkongkkk/article/details/71629690" target="_blank" rel="noopener" title="optional title">全排列问题算法分析与实现（递归、非递归）</a>。这次仅仅是更改了接口，算法思想不变。</strong></p><p><strong>实现如下：</strong></p><pre><code class="hljs arduino"><span class="hljs-comment">//使用STL中的next_permutation，判断是否存在下一个字典序列</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class">&#123;</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; strVec;<span class="hljs-comment">//存储排列情况</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">Permutation</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> strVec;<span class="hljs-comment">//防御性动作</span>        sort(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//先将字符串有序化</span><span class="hljs-keyword">do</span>&#123;strVec.push_back(str);<span class="hljs-comment">//第一种情况直接添加</span>&#125; <span class="hljs-keyword">while</span> (next_permutation(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>()));<span class="hljs-comment">//判断是否存在下个字典系列</span><span class="hljs-keyword">return</span> strVec;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（26）二叉搜索树与双向链表</title>
    <link href="/2020/06/29/binary-search-tree-and-doubly-linked-list/"/>
    <url>/2020/06/29/binary-search-tree-and-doubly-linked-list/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs php"><span class="hljs-comment">//二叉搜索树的结构特点：根的左子树的节点值都小于根节点值，右子树的节点值都大于根节点值</span><span class="hljs-comment">//构建一个有序的双向链表可以利用left作为前驱、right作为后继</span><span class="hljs-comment">//       5</span><span class="hljs-comment">//   4      7</span><span class="hljs-comment">// 2   3  6    8</span><span class="hljs-comment">//2⇿3⇿4⇿5⇿6⇿7⇿8⇿</span><span class="hljs-comment">//root-&gt;left链接到已构建双向链表的最后一个节点</span><span class="hljs-comment">//root-&gt;right链接到右子树的最小值节点</span><span class="hljs-comment">//递归方式处理每一个root</span><span class="hljs-comment">//注意：</span><span class="hljs-comment">//1.因为最后要返回构建的双向链表的head，所以一开始就找到最小值节点。O(logn)</span><span class="hljs-comment">//2.在线测试用例为无头链表</span><span class="hljs-comment">//3.仔细思考指针赋值变化</span><span class="hljs-comment">/*节点结构体定义</span><span class="hljs-comment">struct TreeNode</span><span class="hljs-comment">&#123;</span><span class="hljs-comment">int val;</span><span class="hljs-comment">struct TreeNode *left;</span><span class="hljs-comment">struct TreeNode *right;</span><span class="hljs-comment">TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class"></span>&#123;TreeNode *lastNode = <span class="hljs-keyword">NULL</span>;<span class="hljs-comment">//记录构建的双向链表的最后一个节点</span>TreeNode *linkListHead = <span class="hljs-keyword">NULL</span>;<span class="hljs-comment">//记录所构建的双向链表的head</span><span class="hljs-keyword">public</span>:void findMinNode(TreeNode* pRootOfTree)<span class="hljs-comment">//寻找双向链表的head</span>&#123;<span class="hljs-keyword">if</span> (pRootOfTree == <span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">while</span> (pRootOfTree != <span class="hljs-keyword">NULL</span>)&#123;linkListHead = pRootOfTree;pRootOfTree = pRootOfTree-&gt;left;&#125;&#125;void BSTToOrderTwoWayLinkList(TreeNode* pRootOfTree)&#123;<span class="hljs-keyword">if</span> (pRootOfTree-&gt;left != <span class="hljs-keyword">NULL</span>)<span class="hljs-comment">//如果左子树不为空，则继续递归</span>BSTToOrderTwoWayLinkList(pRootOfTree-&gt;left);pRootOfTree-&gt;left = lastNode;<span class="hljs-comment">//将root-&gt;left链接到链表的最后一个节点</span><span class="hljs-keyword">if</span> (lastNode != <span class="hljs-keyword">NULL</span>)<span class="hljs-comment">//如果前驱不为空，则将前驱的right链接到root</span>lastNode-&gt;right = pRootOfTree;lastNode = pRootOfTree;<span class="hljs-comment">//root变为链表的最后一个节点</span><span class="hljs-keyword">if</span> (pRootOfTree-&gt;right != <span class="hljs-keyword">NULL</span>)<span class="hljs-comment">//如果右子树不为空，则继续递归</span>BSTToOrderTwoWayLinkList(pRootOfTree-&gt;right);&#125;TreeNode* Convert(TreeNode* pRootOfTree)&#123;<span class="hljs-keyword">if</span> (pRootOfTree == <span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span> linkListHead;<span class="hljs-comment">//防御性动作</span>findMinNode(pRootOfTree);<span class="hljs-comment">//寻找双向链表head</span>BSTToOrderTwoWayLinkList(pRootOfTree);<span class="hljs-comment">//开始递归调用</span><span class="hljs-keyword">return</span> linkListHead;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（25）复杂链表的复制</title>
    <link href="/2020/06/29/complex-linked-list-replication/"/>
    <url>/2020/06/29/complex-linked-list-replication/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs xl"><span class="hljs-comment">//老样子，在线测试用例依旧是无头链表。。。→_→</span><span class="hljs-comment">//本题可以利用辅助内存以空间换取时间</span><span class="hljs-comment">//第一次遍历：在原链表的每一个节点之后添加一个与它值相同的新节点，此时完成next指针域的构建</span><span class="hljs-comment">//第二次遍历：每一个newNode的随机指针域为它前一个节点的随机指针域的next，此时完成随机指针域的构建</span><span class="hljs-comment">//第三次遍历：将链表拆分成两个独立链表，一个为原链表，一个为复制链表</span><span class="hljs-comment">//注意：</span><span class="hljs-comment">//1.特殊情况判断：链表为空</span><span class="hljs-comment">//2.仔细思考指针的操作！</span><span class="hljs-comment">//3.在线测试用例必须保证原链表完整！在这被坑了好久。。。</span><span class="hljs-comment">//4.这道题的在线测试，就不用释放内存了。。。</span><span class="hljs-comment">/*</span><span class="hljs-comment">struct RandomListNode </span><span class="hljs-comment">&#123;</span><span class="hljs-comment">int label;//值域</span><span class="hljs-comment">struct RandomListNode *next, *random;//next指针域和随机指针域</span><span class="hljs-comment">RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span>class Solution &#123;public:RandomListNode *cloneHead = NULL;<span class="hljs-comment">//保存复制链表head</span>RandomListNode* createNode(int label)<span class="hljs-comment">//创建新节点</span>&#123;RandomListNode *p = (RandomListNode*)malloc(sizeof(RandomListNode));assert(p != NULL);memset(p, <span class="hljs-number">0</span>, sizeof(RandomListNode));<span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>label = label;return p;&#125;void freeNode(RandomListNode *p)<span class="hljs-comment">//虽然用不到但还写出来</span>&#123;free(p);&#125;void cloneLinkList(RandomListNode* pHead)<span class="hljs-comment">//第一次遍历：构建next</span>&#123;RandomListNode *newNode = NULL;<span class="hljs-keyword">while</span> (pHead != NULL)&#123;<span class="hljs-function"><span class="hljs-title">newNode</span> = createNode(pHead-&gt;</span>label);<span class="hljs-function"><span class="hljs-title">newNode</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span> = pHead-&gt;</span>next;<span class="hljs-function"><span class="hljs-title">pHead</span>-&gt;</span>next = newNode;<span class="hljs-function"><span class="hljs-title">pHead</span> = newNode-&gt;</span>next;&#125;&#125;void perfectLinkList(RandomListNode *pHead)<span class="hljs-comment">//第二次遍历：构建随机指针域</span>&#123;<span class="hljs-keyword">while</span> (pHead != NULL)&#123;<span class="hljs-function"><span class="hljs-title">if</span> (pHead-&gt;</span>random != NULL)<span class="hljs-comment">//有可能这个节点的随机指针域为NULL</span><span class="hljs-function"><span class="hljs-title">pHead</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">random</span> = pHead-&gt;</span><span class="hljs-function"><span class="hljs-title">random</span>-&gt;</span>next;<span class="hljs-comment">//新节点的随机指针域为其前一个节点的随机指针域的next</span><span class="hljs-function"><span class="hljs-title">pHead</span> = pHead-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>next;&#125;&#125;void divisionLinkList(RandomListNode* pHead)<span class="hljs-comment">//第三次遍历：拆分链表为两个自链表</span>&#123;RandomListNode *tmp = pHead;<span class="hljs-function"><span class="hljs-title">cloneHead</span> = pHead-&gt;</span>next;<span class="hljs-comment">//记录复制链表head</span><span class="hljs-function"><span class="hljs-title">pHead</span> = cloneHead-&gt;</span>next;<span class="hljs-keyword">while</span> (pHead != NULL)&#123;<span class="hljs-function"><span class="hljs-title">tmp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span> = pHead-&gt;</span>next;<span class="hljs-function"><span class="hljs-title">tmp</span>-&gt;</span>next = pHead;tmp = pHead;<span class="hljs-function"><span class="hljs-title">pHead</span> = pHead-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>next;&#125;<span class="hljs-function"><span class="hljs-title">tmp</span>-&gt;</span>next = NULL;<span class="hljs-comment">//最后要将原链表的最后一个节点的next置为NULL</span>&#125;RandomListNode* Clone(RandomListNode* pHead)&#123;<span class="hljs-keyword">if</span> (pHead == NULL) return cloneHead;<span class="hljs-comment">//防御性动作</span>cloneLinkList(pHead);perfectLinkList(pHead);divisionLinkList(pHead);return cloneHead;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（24）二叉树中和为某一值的路径</title>
    <link href="/2020/06/29/binary-tree-path-with-a-certain-value/"/>
    <url>/2020/06/29/binary-tree-path-with-a-certain-value/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs cpp"><span class="hljs-comment">//路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径</span><span class="hljs-comment">//所以必须是root到叶节点的和</span><span class="hljs-comment">//模拟一个栈，但在线用例要求将路径以vector的形式存储，所以只能使用vetor的push_back和pop模拟</span><span class="hljs-comment">//注意：</span><span class="hljs-comment">//1.父节点将自己的子节点递归调用判断完毕后，此时返回到自己的函数栈帧时。最后需要将自己也pop</span><span class="hljs-comment">//2.叶节点也需要将自己pop</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; valueVec;<span class="hljs-comment">//保存一路径中的元素值</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; allPathVec;<span class="hljs-comment">//保存符合某值的路径</span><span class="hljs-keyword">int</span> currentNumber = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前累计值</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Path</span><span class="hljs-params">(TreeNode *root, <span class="hljs-keyword">int</span> expectNumber, <span class="hljs-keyword">int</span> &amp;currentNumber)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//防御性动作</span>valueVec.push_back(root-&gt;val);<span class="hljs-comment">//将此节点的值存入路径</span>currentNumber += root-&gt;val;<span class="hljs-comment">//累计值累加</span><span class="hljs-keyword">if</span> (currentNumber == expectNumber &amp;&amp; root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//判断当前值和某值是否相等且此节点必须为叶节点</span>&#123;allPathVec.push_back(valueVec);<span class="hljs-comment">//将路径存储</span><span class="hljs-keyword">return</span>;<span class="hljs-comment">//结束本次调用</span>&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//否则递归调用传入left与right</span>&#123;Path(root-&gt;left, expectNumber, currentNumber);Path(root-&gt;right, expectNumber, currentNumber);currentNumber -= valueVec.back();<span class="hljs-comment">//此时将本节点pop</span>valueVec.pop_back();<span class="hljs-comment">//减去本节点的值</span>&#125;<span class="hljs-keyword">if</span> (root-&gt;left != <span class="hljs-literal">NULL</span> || root-&gt;right != <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//判断这是否为父节点</span>&#123;<span class="hljs-comment">//若为父节点，则将本节点从路径中删除且从累计值中减去</span>currentNumber -= valueVec.back();valueVec.pop_back();&#125;&#125;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-title">FindPath</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> expectNumber)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> allPathVec;<span class="hljs-comment">//防御性动作</span>Path(root, expectNumber, currentNumber);<span class="hljs-comment">//递归调用</span><span class="hljs-keyword">return</span> allPathVec;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（23）二叉搜索树的后序遍历序列</title>
    <link href="/2020/06/29/postorder-traversal-sequence-of-binary-search-tree/"/>
    <url>/2020/06/29/postorder-traversal-sequence-of-binary-search-tree/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>最近几天被推荐参加互联网+比赛，一直忙着团队前期工作。。拖更了。。</em> *</strong><br><strong>题目描述：</strong></p><blockquote><p><strong>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs reasonml"><span class="hljs-comment">//找规律</span><span class="hljs-comment">//      8</span><span class="hljs-comment">//  6      10</span><span class="hljs-comment">//5   7  9    11</span><span class="hljs-comment">//&#123;5，7，6，9，11，10，8&#125;</span><span class="hljs-comment">//最后一个为树的root</span><span class="hljs-comment">//&#123;5，6，7&#125;为左子树、&#123;9，11，10&#125;为右子树</span><span class="hljs-comment">//递归判断</span><span class="hljs-comment">//假定&#123;7，4，6，5&#125;</span><span class="hljs-comment">//7大于root，所以7之后的数为右子树，但又出现了比root小的数，所以次遍历结果false</span><span class="hljs-keyword">class</span> Solution &#123;public:<span class="hljs-comment">//传入root下标和此子树最小元素的下标</span><span class="hljs-built_in">bool</span> <span class="hljs-constructor">Verify(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt; <span class="hljs-params">sequence</span>, <span class="hljs-params">int</span> <span class="hljs-params">rootIndex</span>, <span class="hljs-params">int</span> <span class="hljs-params">minIndex</span>)</span>&#123;<span class="hljs-keyword">if</span> (minIndex - rootIndex &gt;= <span class="hljs-number">0</span>) return <span class="hljs-literal">true</span>;<span class="hljs-comment">//判断此子树是否为空或只有1个元素</span><span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">int</span> leftIndex = minIndex;<span class="hljs-comment">//保存左子树的root下标</span><span class="hljs-keyword">while</span> (leftIndex &lt; rootIndex<span class="hljs-operator"> &amp;&amp; </span>sequence<span class="hljs-literal">[<span class="hljs-identifier">leftIndex</span>]</span> &lt; sequence<span class="hljs-literal">[<span class="hljs-identifier">rootIndex</span>]</span>)<span class="hljs-comment">//寻找第一个大于root值的元素的下标</span>&#123;++leftIndex;&#125;<span class="hljs-built_in">int</span> rightIndex = leftIndex;<span class="hljs-keyword">while</span> (rightIndex &lt; rootIndex)<span class="hljs-comment">//判断右子树中是否有小于root的元素</span>&#123;<span class="hljs-keyword">if</span> (sequence<span class="hljs-literal">[<span class="hljs-identifier">rightIndex</span>]</span> &lt; sequence<span class="hljs-literal">[<span class="hljs-identifier">rootIndex</span>]</span>)<span class="hljs-comment">//若有直接return</span>return <span class="hljs-literal">false</span>;++rightIndex;&#125;return <span class="hljs-constructor">Verify(<span class="hljs-params">sequence</span>, <span class="hljs-params">leftIndex</span> - 1, <span class="hljs-params">minIndex</span>)</span><span class="hljs-operator"> &amp;&amp; </span><span class="hljs-constructor">Verify(<span class="hljs-params">sequence</span>, <span class="hljs-params">rootIndex</span> - 1, <span class="hljs-params">leftIndex</span>)</span>;<span class="hljs-comment">//对左子树和右子树继续递归</span>&#125;&#125;<span class="hljs-built_in">bool</span> <span class="hljs-constructor">VerifySquenceOfBST(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt; <span class="hljs-params">sequence</span>)</span> &#123;<span class="hljs-comment">//统一使用下标</span><span class="hljs-built_in">int</span> maxIndex = sequence.size<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (maxIndex &lt; <span class="hljs-number">0</span>) return <span class="hljs-literal">false</span>;<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (maxIndex<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) return <span class="hljs-literal">true</span>;<span class="hljs-comment">//只有一个元素时直接return</span><span class="hljs-keyword">else</span>return <span class="hljs-constructor">Verify(<span class="hljs-params">sequence</span>, <span class="hljs-params">maxIndex</span>, 0)</span>;<span class="hljs-comment">//将此树的root和最小数的下标传入</span>&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>棋盘覆盖问题算法分析与实现（递归）</title>
    <link href="/2020/06/29/algorithm-analysis-and-implementation-of-checkerboard-covering-problem/"/>
    <url>/2020/06/29/algorithm-analysis-and-implementation-of-checkerboard-covering-problem/</url>
    
    <content type="html"><![CDATA[<p><strong><strong>昨天上传的代码，经过再次测试发现有问题，其中对边界、终止条件的判断都有错误。。。→_→，今天重新改正，对之前看过代码的童鞋表示sorry。。。（2017.5.13 16：24）</strong></strong></p><p><strong>问题描述：</strong></p><blockquote><p><strong>在一个2^k×2^k （k≥0）个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为特殊方格。显然，特殊方格在棋盘中可能出现的位置有4^k种，因而有4^k种不同的棋盘。棋盘覆盖问题（chess cover problem）要求使用4种不同形状的L型骨牌覆盖给定棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。</strong></p></blockquote><p>关于棋盘划分的更多概念请戳传送门：<a href="http://baike.baidu.com/link?url=NRSk5y5ZEQJoMB1IOahHh0_C9EXAXz1jiNP2RwTjkV8HGonNBXiq7dxXZ8sZq5OotITXsl24E48V5IC5RLbbWfzHGoHnZuobWrdKwH4StaeryBS7LoiLZgxSm9Ivji5seRhr-062OJCwOYDsL7Y2oK" target="_blank" rel="noopener">棋盘覆盖问题</a></p><p><strong>实现如下：</strong></p><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution&#123;public:<span class="hljs-built_in">int</span> num = <span class="hljs-number">0</span>;<span class="hljs-comment">//累计计算</span><span class="hljs-built_in">int</span> **board = NULL;<span class="hljs-comment">//动态二维数组指针</span>void print<span class="hljs-constructor">Board(<span class="hljs-params">int</span> <span class="hljs-operator">**</span><span class="hljs-params">board</span>, <span class="hljs-params">int</span> <span class="hljs-params">row</span>, <span class="hljs-params">int</span> <span class="hljs-params">col</span>)</span><span class="hljs-comment">//输出函数</span>&#123;for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i)&#123;for (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j)cout &lt;&lt; setw(<span class="hljs-number">3</span>) &lt;&lt;board<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;cout &lt;&lt; endl;&#125;cout &lt;&lt; endl;&#125;void create<span class="hljs-constructor">Board(<span class="hljs-params">int</span> <span class="hljs-params">chessboardSize</span>, <span class="hljs-params">int</span> <span class="hljs-params">dr</span>, <span class="hljs-params">int</span> <span class="hljs-params">dc</span>)</span><span class="hljs-comment">//动态申请内存函数</span>&#123;board = (<span class="hljs-built_in">int</span> **)malloc(chessboardSize<span class="hljs-operator"> * </span>sizeof(<span class="hljs-built_in">int</span>*));<span class="hljs-keyword">assert</span>(board != NULL);for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; chessboardSize; ++i)&#123;board<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = (<span class="hljs-built_in">int</span>*)malloc(chessboardSize<span class="hljs-operator"> * </span>sizeof(<span class="hljs-built_in">int</span>));<span class="hljs-keyword">assert</span>(board<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> != NULL);memset(board<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>, <span class="hljs-number">0</span>, sizeof(<span class="hljs-built_in">int</span>)*chessboardSize);&#125;board<span class="hljs-literal">[<span class="hljs-identifier">dr</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">dc</span>]</span> = -<span class="hljs-number">1</span>;<span class="hljs-comment">//将特殊点设置为-1</span>&#125;void free<span class="hljs-constructor">Board(<span class="hljs-params">int</span> <span class="hljs-params">row</span>)</span><span class="hljs-comment">//释放动态内存空间，防止内存泄漏</span>&#123;for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i)free(board<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>);free(board);&#125;<span class="hljs-comment">//chessboardSize表示此时范围的n*n，n的值</span><span class="hljs-comment">//dr表示特殊点的行下标</span><span class="hljs-comment">//dc表示特殊点的列下标</span><span class="hljs-comment">//tr表示此时范围的左上角在数组中的行下标</span><span class="hljs-comment">//tc表示此时范围的左上角在数组中的列下标</span>void <span class="hljs-constructor">Coverage(<span class="hljs-params">int</span> <span class="hljs-params">chessboardSize</span>, <span class="hljs-params">int</span> <span class="hljs-params">dr</span>, <span class="hljs-params">int</span> <span class="hljs-params">dc</span>, <span class="hljs-params">int</span> <span class="hljs-params">tr</span>, <span class="hljs-params">int</span> <span class="hljs-params">tc</span>)</span>&#123;<span class="hljs-keyword">if</span> (chessboardSize<span class="hljs-operator"> == </span><span class="hljs-number">1</span>) return;<span class="hljs-comment">//当范围为1时，表示只有一个元素，return</span><span class="hljs-built_in">int</span> tmp = ++num;<span class="hljs-comment">//每进入一个范围内，num累加</span><span class="hljs-built_in">int</span> s = chessboardSize<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<span class="hljs-comment">//获取此时范围内的下一个小范围的n大小</span><span class="hljs-comment">//判断特殊点是否在范围内的第一象限</span><span class="hljs-keyword">if</span> (dr &lt; tr + s<span class="hljs-operator"> &amp;&amp; </span>dr &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>dc &lt; tc + s<span class="hljs-operator"> &amp;&amp; </span>dc &gt;= <span class="hljs-number">0</span>)<span class="hljs-constructor">Coverage(<span class="hljs-params">s</span>, <span class="hljs-params">dr</span>, <span class="hljs-params">dc</span>, <span class="hljs-params">tr</span>, <span class="hljs-params">tc</span>)</span>;<span class="hljs-keyword">else</span><span class="hljs-comment">//否则，将此第一象限的右下角设置为相对特殊点</span>&#123;board<span class="hljs-literal">[<span class="hljs-identifier">tr</span> + <span class="hljs-identifier">s</span> - <span class="hljs-number">1</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">tc</span> + <span class="hljs-identifier">s</span> - <span class="hljs-number">1</span>]</span> = tmp;<span class="hljs-constructor">Coverage(<span class="hljs-params">s</span>, <span class="hljs-params">tr</span> + <span class="hljs-params">s</span> - 1, <span class="hljs-params">tc</span> + <span class="hljs-params">s</span> - 1, <span class="hljs-params">tr</span>, <span class="hljs-params">tc</span>)</span>;&#125;<span class="hljs-comment">//判断特殊点是否在范围内的第四象限</span><span class="hljs-keyword">if</span> (dr &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>dr &lt; tr + s<span class="hljs-operator"> &amp;&amp; </span>dc &gt;= tc + s<span class="hljs-operator"> &amp;&amp; </span>dc &lt; tc + <span class="hljs-number">2</span><span class="hljs-operator"> * </span>s)<span class="hljs-constructor">Coverage(<span class="hljs-params">s</span>, <span class="hljs-params">dr</span>, <span class="hljs-params">dc</span>, <span class="hljs-params">tr</span>, <span class="hljs-params">tc</span> + <span class="hljs-params">s</span>)</span>;<span class="hljs-keyword">else</span><span class="hljs-comment">//否则，将此第四象限的右下角设置为相对特殊点</span>&#123;board<span class="hljs-literal">[<span class="hljs-identifier">tr</span> + <span class="hljs-identifier">s</span> - <span class="hljs-number">1</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">tc</span> + <span class="hljs-identifier">s</span>]</span> = tmp;<span class="hljs-constructor">Coverage(<span class="hljs-params">s</span>, <span class="hljs-params">tr</span> + <span class="hljs-params">s</span> - 1, <span class="hljs-params">tc</span> + <span class="hljs-params">s</span>, <span class="hljs-params">tr</span>, <span class="hljs-params">tc</span> + <span class="hljs-params">s</span>)</span>;&#125;<span class="hljs-comment">//判断特殊点是否在范围内的第二象限</span><span class="hljs-keyword">if</span> (dr &gt;= tr + s<span class="hljs-operator"> &amp;&amp; </span>dr &lt; tr + <span class="hljs-number">2</span><span class="hljs-operator"> * </span>s<span class="hljs-operator"> &amp;&amp; </span>dc &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>dc &lt; tc + s)<span class="hljs-constructor">Coverage(<span class="hljs-params">s</span>, <span class="hljs-params">dr</span>, <span class="hljs-params">dc</span>, <span class="hljs-params">tr</span> + <span class="hljs-params">s</span>, <span class="hljs-params">tc</span>)</span>;<span class="hljs-keyword">else</span><span class="hljs-comment">//否则，将此第二象限的右下角设置为相对特殊点</span>&#123;board<span class="hljs-literal">[<span class="hljs-identifier">tr</span> + <span class="hljs-identifier">s</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">tc</span> + <span class="hljs-identifier">s</span> - <span class="hljs-number">1</span>]</span> = tmp;<span class="hljs-constructor">Coverage(<span class="hljs-params">s</span>, <span class="hljs-params">tr</span> + <span class="hljs-params">s</span>, <span class="hljs-params">tc</span> + <span class="hljs-params">s</span> - 1, <span class="hljs-params">tr</span> + <span class="hljs-params">s</span>, <span class="hljs-params">tc</span>)</span>;&#125;<span class="hljs-comment">//判断特殊点是否在范围内的第三象限</span><span class="hljs-keyword">if</span> (dr &gt;= tr + s<span class="hljs-operator"> &amp;&amp; </span>dr &lt; tr + <span class="hljs-number">2</span><span class="hljs-operator"> * </span>s<span class="hljs-operator"> &amp;&amp; </span>dc &gt;= tc + s<span class="hljs-operator"> &amp;&amp; </span>dc &lt; tc + <span class="hljs-number">2</span><span class="hljs-operator"> * </span>s)<span class="hljs-constructor">Coverage(<span class="hljs-params">s</span>, <span class="hljs-params">dr</span>, <span class="hljs-params">dc</span>, <span class="hljs-params">tr</span> + <span class="hljs-params">s</span>, <span class="hljs-params">tc</span> + <span class="hljs-params">s</span>)</span>;<span class="hljs-keyword">else</span><span class="hljs-comment">//否则，将此第三象限的右下角设置为相对特殊点</span>&#123;board<span class="hljs-literal">[<span class="hljs-identifier">tr</span> + <span class="hljs-identifier">s</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">tc</span> + <span class="hljs-identifier">s</span>]</span> = tmp;<span class="hljs-constructor">Coverage(<span class="hljs-params">s</span>, <span class="hljs-params">tr</span> + <span class="hljs-params">s</span>, <span class="hljs-params">tc</span> + <span class="hljs-params">s</span>, <span class="hljs-params">tr</span> + <span class="hljs-params">s</span>, <span class="hljs-params">tc</span> + <span class="hljs-params">s</span>)</span>;&#125;<span class="hljs-comment">//printBoard(board, 8, 8);</span>&#125;void <span class="hljs-constructor">ChessboardCoverage(<span class="hljs-params">int</span> <span class="hljs-params">chessboardSize</span>, <span class="hljs-params">int</span> <span class="hljs-params">dr</span>, <span class="hljs-params">int</span> <span class="hljs-params">dc</span>)</span>&#123;<span class="hljs-keyword">if</span> (chessboardSize &lt; <span class="hljs-number">1</span><span class="hljs-operator"> || </span>dr &lt; <span class="hljs-number">0</span><span class="hljs-operator"> || </span>dc &lt; <span class="hljs-number">0</span><span class="hljs-operator"> || </span>dr &gt;= chessboardSize<span class="hljs-operator"> || </span>dc &gt;= chessboardSize) return;<span class="hljs-comment">//防御性动作</span>create<span class="hljs-constructor">Board(<span class="hljs-params">chessboardSize</span>, <span class="hljs-params">dr</span>, <span class="hljs-params">dc</span>)</span>;<span class="hljs-comment">//动态生成二维数组</span><span class="hljs-constructor">Coverage(<span class="hljs-params">chessboardSize</span>, <span class="hljs-params">dr</span>, <span class="hljs-params">dc</span>, 0, 0)</span>;<span class="hljs-comment">//开始覆盖</span>print<span class="hljs-constructor">Board(<span class="hljs-params">board</span>, <span class="hljs-params">chessboardSize</span>, <span class="hljs-params">chessboardSize</span>)</span>;<span class="hljs-comment">//输出</span>free<span class="hljs-constructor">Board(<span class="hljs-params">chessboardSize</span>)</span>;<span class="hljs-comment">//释放动态空间</span>&#125;&#125;;</code></pre><p><strong>测试用例：</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTEzMTYyNjI5OTkz?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="棋盘覆盖算法"></p>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整数划分问题算法分析与实现（递归）</title>
    <link href="/2020/06/29/algorithm-analysis-and-implementation-of-integer-partition-problem/"/>
    <url>/2020/06/29/algorithm-analysis-and-implementation-of-integer-partition-problem/</url>
    
    <content type="html"><![CDATA[<p><strong>问题描述：</strong></p><blockquote><p><strong>把一个正整数n写成多个大于等于1且小于等于其本身的整数的和，则其中各加数所构成的集合为n的一个划分。</strong><br><strong>把一个正整数n写成为 n=m1+m2+…+mi。其中，mi为正整数，并且1≤mi≤n；{m1，m2，…，mi}为n的一个划分。</strong><br><strong>如{m1，m2，…，mi}果中的最大值不超过m，即max(m1，m2，…，mi)≤m，则称它属于n的一个m划分。</strong></p></blockquote><p>关于整数划分和生成函数的具体概念请戳传送门：<a href="https://en.wikipedia.org/wiki/Partition_(number_theory)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Partition_(number_theory)</a></p><p><strong>实现如下：</strong></p><ol><li><p>当n = 1时，无论m为何值，只有{1}一种划分</p></li><li><p>当m = 1时，无论n为何值，只有{n}一种划分</p></li><li><p>当n &lt; m时，因为m为正整数，所以不可能出现负数情况，所以相当于IntegerPartition(n, n)</p></li><li><p>当n == m时，细分为划分中是否包含n的情况</p><ul><li><p>当划分中包含n时，划分为{n}，一种情况</p></li><li><p>当划分中不包含n时，划分中mi最大值一定小于n，则划分为IntegerPartition(n, m-1)</p></li><li><p>此时IntegerPartition(n, m) = 1 + IntegerPartition(n, m-1)</p></li></ul></li><li><p>当n &gt; m时，细分为划分中是否包含m的情况</p><ul><li>当划分中包含m时，划分为{m，{x1，x2，…，xi}}，此时划分为IntegerPartition(n-m, m)</li><li>当划分中不包含m时，此时划分中的max一定小于m，此时划分为IntegerPartition(n, m-1)</li><li>此时IntegerPartition(n, m) = IntegerPartition(n-m, m) + IntegerPartition(n, m-1)</li></ul></li></ol><pre><code class="hljs angelscript"><span class="hljs-comment">//注意输入值的判断</span><span class="hljs-comment">//保证所有路径都有返回值</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">int</span> IntegerPartition(<span class="hljs-built_in">int</span> n, <span class="hljs-built_in">int</span> m)&#123;<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span> || m &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || m == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt; m) <span class="hljs-keyword">return</span> IntegerPartition(n, n);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == m) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + IntegerPartition(n, m - <span class="hljs-number">1</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt; m) <span class="hljs-keyword">return</span> IntegerPartition(n - m, m) + IntegerPartition(n, m - <span class="hljs-number">1</span>);&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求子集问题算法分析与实现（递归、非递归）</title>
    <link href="/2020/06/29/algorithm-analysis-and-Implementation-of-seeking-subset-problem/"/>
    <url>/2020/06/29/algorithm-analysis-and-Implementation-of-seeking-subset-problem/</url>
    
    <content type="html"><![CDATA[<p><strong>问题描述：</strong></p><blockquote><p><strong>若有数字集合{1，2，3}，则其子集为NULL、{1}、{2}、{3}、{1，2}、{1，3}、{2，3}、{1，2，3}。现给定数组，求其的全部子集。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs arduino"><span class="hljs-comment">//非递归</span><span class="hljs-comment">//&#123;1，2，3&#125;</span><span class="hljs-comment">// 0  0  0</span><span class="hljs-comment">// 0  0  1</span><span class="hljs-comment">// 0  1  0</span><span class="hljs-comment">// 0  1  1</span><span class="hljs-comment">// 1  0  0</span><span class="hljs-comment">// 1  0  1</span><span class="hljs-comment">// 1  1  0</span><span class="hljs-comment">// 1  1  1</span><span class="hljs-comment">//计算子集的个数，即2的元素个数次方</span><span class="hljs-comment">//一次规律</span><span class="hljs-comment">//空集需要特殊输出</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *value, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (value == <span class="hljs-literal">NULL</span> || <span class="hljs-built_in">size</span> &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">int</span> *tmp = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">size</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<span class="hljs-comment">//开辟空间存放输出标志</span>assert(tmp != <span class="hljs-literal">NULL</span>);<span class="hljs-built_in">memset</span>(tmp, <span class="hljs-number">0</span>, <span class="hljs-built_in">size</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<span class="hljs-keyword">int</span> num = (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">pow</span>((<span class="hljs-keyword">double</span>)<span class="hljs-number">2</span>, (<span class="hljs-keyword">double</span>)<span class="hljs-built_in">size</span>);<span class="hljs-comment">//计算子集个数</span><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"NULL"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; num; ++i)&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">size</span>; ++j)<span class="hljs-comment">//给输出标志赋值，二进制计算</span>&#123;<span class="hljs-keyword">if</span> (tmp[j] == <span class="hljs-number">1</span>) tmp[j] = <span class="hljs-number">0</span>;<span class="hljs-comment">//逢二进一</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp[j] == <span class="hljs-number">0</span>)&#123;tmp[j] = <span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">size</span>; ++j)<span class="hljs-comment">//比较输出标志，得出子集所包含元素</span>&#123;<span class="hljs-keyword">if</span> (tmp[j] == <span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span> &lt;&lt; value[j] &lt;&lt; <span class="hljs-string">" "</span>;&#125;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">delete</span> tmp;<span class="hljs-comment">//释放内存空间</span>&#125;&#125;;<span class="hljs-comment">//递归</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-keyword">int</span> *tmp;<span class="hljs-comment">//指向动态数组的指针</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span><span class="hljs-comment">//创建动态数组</span></span><span class="hljs-function"></span>&#123;tmp = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">size</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));assert(tmp != <span class="hljs-literal">NULL</span>);<span class="hljs-built_in">memset</span>(tmp, <span class="hljs-number">0</span>, <span class="hljs-built_in">size</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteArray</span><span class="hljs-params">()</span><span class="hljs-comment">//释放内存空间</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">free</span>(tmp);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subsetRecursive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *value, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (m == <span class="hljs-number">-1</span>)<span class="hljs-comment">//此时标志位都已赋值，进行统计输出</span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)&#123;<span class="hljs-keyword">if</span> (tmp[i] == <span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span> &lt;&lt; value[i] &lt;&lt; <span class="hljs-string">" "</span>;<span class="hljs-comment">//为1输出</span>&#125;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">else</span>&#123;tmp[m] = <span class="hljs-number">0</span>;<span class="hljs-comment">//先将此标志位赋值为0，即不输出</span>subsetRecursive(value, m - <span class="hljs-number">1</span>, <span class="hljs-built_in">size</span>);<span class="hljs-comment">//递归到下一位</span>tmp[m] = <span class="hljs-number">1</span>;<span class="hljs-comment">//再将此标志位赋值为1，即输出</span>subsetRecursive(value, m - <span class="hljs-number">1</span>, <span class="hljs-built_in">size</span>);<span class="hljs-comment">//递归到下一位</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *value, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (value == <span class="hljs-literal">NULL</span> || <span class="hljs-built_in">size</span> &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//防御性动作</span>createArray(<span class="hljs-built_in">size</span>);subsetRecursive(value, <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>, <span class="hljs-built_in">size</span>);<span class="hljs-comment">//从最高位开始</span>deleteArray();&#125;&#125;;</code></pre><p><strong>结果如图：</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTE0MTUwMjA0OTk0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="求子集算法结果"></p>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全排列问题算法分析与实现（递归、非递归）</title>
    <link href="/2020/06/29/algorithm-analysis-and-implementation-of-full-classification-problem/"/>
    <url>/2020/06/29/algorithm-analysis-and-implementation-of-full-classification-problem/</url>
    
    <content type="html"><![CDATA[<p><strong>问题描述：</strong></p><blockquote><p><strong>若有数字集合{1，2，3}，则其全排列为123、132、213、231、321、312。现给定字符数组，求其字符的全排列。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs axapta"><span class="hljs-comment">//1.递归方法</span><span class="hljs-comment">//如例，其全排列可以分成</span><span class="hljs-comment">//1-&gt;&#123;2,3&#125;</span><span class="hljs-comment">//2-&gt;&#123;1,3&#125;</span><span class="hljs-comment">//3-&gt;&#123;2,1&#125;</span><span class="hljs-comment">//再递归求其剩余字符的全排列</span><span class="hljs-comment">//重点在于如何交换字符</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-keyword">void</span> swap(<span class="hljs-keyword">char</span> &amp;ch1, <span class="hljs-keyword">char</span> &amp;ch2)<span class="hljs-comment">//交换元素值</span>&#123;<span class="hljs-keyword">char</span> tmp = ch1;ch1 = ch2;ch2 = tmp;&#125;<span class="hljs-keyword">void</span> fullPermutation(<span class="hljs-keyword">char</span> *<span class="hljs-keyword">str</span>, <span class="hljs-keyword">int</span> beginIndex, <span class="hljs-keyword">int</span> endIndex)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">str</span> == NULL) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">if</span> (beginIndex == endIndex)<span class="hljs-comment">//当起点下标等于终点下标时，说明已没有待排元素，输出此排列情况</span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= endIndex; ++i)cout &lt;&lt; <span class="hljs-keyword">str</span>[i] &lt;&lt; <span class="hljs-string">" "</span>;cout &lt;&lt; endl;&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//否则说明还有未排元素</span>&#123;<span class="hljs-comment">//j代表目前需要排列的元素</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = beginIndex; j &lt;= endIndex; ++j)&#123;<span class="hljs-comment">//其和beginIndex下标的元素swap，保证它是这个排列子序列中的第一个元素</span>swap(<span class="hljs-keyword">str</span>[beginIndex], <span class="hljs-keyword">str</span>[j]);<span class="hljs-comment">//接着进行递归，此时传参beginIndex需要加1，保证起点下标后移</span>fullParrangement(<span class="hljs-keyword">str</span>, beginIndex + <span class="hljs-number">1</span>, endIndex);<span class="hljs-comment">//此时须将之前交换过的值换回来，保证后序的排列顺序</span>swap(<span class="hljs-keyword">str</span>[beginIndex], <span class="hljs-keyword">str</span>[j]);&#125;&#125;&#125;&#125;;</code></pre><p><strong>方法2中使用STL中的next_permutation()函数，具体说明参见<a href="http://www.cplusplus.com/reference/algorithm/next_permutation/" target="_blank" rel="noopener" title="optional title">next_permutation</a>或参考我自己实现的my_next_permutation()。</strong></p><pre><code class="hljs cpp"><span class="hljs-comment">//2.非递归方法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>：<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fullPermutation</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">int</span> <span class="hljs-built_in">strlen</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (str == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//防御性动作</span>sort(str, str + <span class="hljs-built_in">strlen</span>);<span class="hljs-comment">//首先将str排序</span><span class="hljs-comment">//第一次直接输出</span><span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-built_in">strlen</span>; ++i)<span class="hljs-built_in">cout</span> &lt;&lt; str[i];<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125; <span class="hljs-keyword">while</span> (my_next_permutation(str, str + <span class="hljs-built_in">strlen</span>));<span class="hljs-comment">//若下一个字典序存在，则继续输出，否则结束</span>&#125;&#125;;<span class="hljs-comment">//my_next_permutation()实现如下</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *ch1, <span class="hljs-keyword">char</span> *ch2)</span><span class="hljs-comment">//交换元素值</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">char</span> tmp = *ch1;*ch1 = *ch2;*ch2 = tmp;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">my_next_permutation</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *strBegin, <span class="hljs-keyword">char</span> *strEnd)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (strBegin == <span class="hljs-literal">NULL</span> || strEnd == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//防御性动作</span><span class="hljs-keyword">if</span> (strEnd - strBegin &lt;= <span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//当元素数小于等于1个时，无须排列</span><span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<span class="hljs-comment">//条件标志判断是否存在下一个字典序列，初始值为假</span><span class="hljs-keyword">char</span> *i = strEnd - <span class="hljs-number">2</span>;<span class="hljs-comment">//i与ii表示相邻两个元素</span><span class="hljs-keyword">char</span> *ii = strEnd - <span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> *j = strEnd - <span class="hljs-number">1</span>;<span class="hljs-comment">//j表示第一个大于i元素的元素</span><span class="hljs-keyword">for</span> (; i &gt;= strBegin &amp;&amp; ii &gt; strBegin; --i,--ii)&#123;<span class="hljs-keyword">if</span> (*i &lt; *ii)<span class="hljs-comment">//寻找第一对i小于ii的相邻元素</span>&#123;flag = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (flag)<span class="hljs-comment">//如果没找到则表示不存在下一个字典序列，反之继续</span>&#123;flag = <span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span> (; j &gt; strBegin; --j)&#123;<span class="hljs-keyword">if</span> (*j &gt; *i)<span class="hljs-comment">//从末尾开始寻找第一个大于i元素的元素</span>&#123;flag = <span class="hljs-literal">true</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">if</span> (flag)<span class="hljs-comment">//如果没找到则表示不存在下一个字典序列，反之继续</span>&#123;swap(i, j);将两者元素的值交换sort(ii, strEnd);<span class="hljs-comment">//将ii之后的所有元素排序</span>&#125;&#125; <span class="hljs-keyword">return</span> flag；&#125;</code></pre><p><strong>next_permutation实现效果：</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNTExMTgyNjI0MTQ5?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="next_permutation"></p><p><strong>* <em>啊。。码字真累。。→_→</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（22）从上往下打印二叉树&amp;&amp;层次遍历</title>
    <link href="/2020/06/28/print-binary-tree-and-level-traversal-from-top-to-bottom/"/>
    <url>/2020/06/28/print-binary-tree-and-level-traversal-from-top-to-bottom/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs reasonml"><span class="hljs-comment">//层次遍历时使用队列容器，保证先进先出</span><span class="hljs-comment">//分别判断节点的左右孩子是否为空</span><span class="hljs-comment">//非空就将孩子节点尾插</span><span class="hljs-comment">//每次都从队头获取打印值、头删出队</span><span class="hljs-comment">//队列为空时说明遍历结束</span><span class="hljs-comment">//注意判断root是否合法</span><span class="hljs-keyword">class</span> Solution &#123;public:deque&lt;TreeNode*&gt; q;<span class="hljs-comment">//存放层次遍历时的节点顺序</span>vector&lt;<span class="hljs-built_in">int</span>&gt; vec;vector&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-constructor">PrintFromTopToBottom(TreeNode<span class="hljs-operator">*</span> <span class="hljs-params">root</span>)</span> &#123;<span class="hljs-keyword">if</span> (root<span class="hljs-operator"> == </span>NULL) return vec;<span class="hljs-comment">//root为空时，直接return</span>q.push<span class="hljs-constructor">_back(<span class="hljs-params">root</span>)</span>;<span class="hljs-comment">//root非空时，首先尾插</span><span class="hljs-keyword">while</span> (!q.empty<span class="hljs-literal">()</span>)<span class="hljs-comment">//判断是否遍历结束</span>&#123;TreeNode *tmp = q.front<span class="hljs-literal">()</span>;<span class="hljs-comment">//队头获取该打印的节点</span>q.pop<span class="hljs-constructor">_front()</span>;<span class="hljs-comment">//分别判断左右孩子是否为空，非空时队列尾插</span><span class="hljs-keyword">if</span> (tmp-&gt;left != NULL)q.push<span class="hljs-constructor">_back(<span class="hljs-params">tmp</span>-&gt;<span class="hljs-params">left</span>)</span>;<span class="hljs-keyword">if</span> (tmp-&gt;right != NULL)q.push<span class="hljs-constructor">_back(<span class="hljs-params">tmp</span>-&gt;<span class="hljs-params">right</span>)</span>;vec.push<span class="hljs-constructor">_back(<span class="hljs-params">tmp</span>-&gt;<span class="hljs-params">val</span>)</span>;<span class="hljs-comment">//将val添加</span>&#125;return vec;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（21）栈的压入、弹出序列</title>
    <link href="/2020/06/28/stack-push-and-pop-sequence/"/>
    <url>/2020/06/28/stack-push-and-pop-sequence/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs arduino"><span class="hljs-comment">//模拟栈的push与pop，利用辅助栈</span><span class="hljs-comment">//在线测试用例中给出了pushV&#123;1&#125;，popV&#123;2&#125;的情况V，万恶→_→</span><span class="hljs-comment">//判断一个出栈序列是否合法，需要在已知的入栈序列情况下判断</span><span class="hljs-comment">//出栈序列中的数pop时，必须保证此数在入栈序列中位置之前的数全部入过栈</span><span class="hljs-comment">//特殊情况：</span><span class="hljs-comment">//1.序列为空</span><span class="hljs-comment">//2.序列中的数字值不一致</span><span class="hljs-comment">//3.出栈顺序不合法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; assistStack;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsPopOrder</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; pushV, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; popV)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//判断是否为空</span><span class="hljs-keyword">if</span> (pushV.empty() || popV.empty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<span class="hljs-comment">//j作为pushV的下标记录</span><span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; popV.<span class="hljs-built_in">size</span>(); ++i)&#123;<span class="hljs-comment">//如果辅助栈不为空且其top不等于该出栈的数且数已全部入过栈，此时出栈顺序不合法</span><span class="hljs-keyword">if</span> (!assistStack.empty() &amp;&amp; assistStack.top() != popV[i] &amp;&amp; j &gt;= pushV.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果辅助栈为空或辅助栈top不等于该出栈的数且还有数字未入过栈</span><span class="hljs-keyword">if</span> (assistStack.empty() || (assistStack.top() != popV[i] &amp;&amp; j &lt; popV.<span class="hljs-built_in">size</span>()))&#123;<span class="hljs-comment">//直至在pushV中找到与该出栈的数相同值的位置</span><span class="hljs-keyword">while</span> ((j &lt; pushV.<span class="hljs-built_in">size</span>()) &amp;&amp; pushV[j] != popV[i])assistStack.push(pushV[j++]);<span class="hljs-comment">//此时j自加1，是因为此循环有可能因为pushV[j] == popV[i]，所以模拟push操作(其实没往assistStack中push)，跳过此数</span>++j;<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (assistStack.top() == popV[i])<span class="hljs-comment">//当pushV栈顶元素等于该出栈的数，正常出栈</span>&#123;assistStack.pop();<span class="hljs-keyword">continue</span>;&#125;&#125;&#125;<span class="hljs-comment">//此条件判断有可能两序列中的数字值不一致情况</span><span class="hljs-keyword">if</span> (assistStack.empty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（20）包含min函数的栈</title>
    <link href="/2020/06/28/the-stack-containing-the-min-function/"/>
    <url>/2020/06/28/the-stack-containing-the-min-function/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs cs"><span class="hljs-comment">//利用一个辅助栈，用来存放和数据栈相对应的每层之下的最小值</span><span class="hljs-comment">//利用minValue存储当前最小值，O(1)</span><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-keyword">int</span> minValue = <span class="hljs-number">0</span>;stack&lt;<span class="hljs-keyword">int</span>&gt; assistStack;stack&lt;<span class="hljs-keyword">int</span>&gt; dataStack;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span></span>) </span><span class="hljs-function"></span>&#123;dataStack.push(<span class="hljs-keyword">value</span>);<span class="hljs-keyword">if</span> (dataStack.size() == <span class="hljs-number">1</span>)<span class="hljs-comment">//此时value为第一个元素，直接将value push进辅助栈，及当前最小值</span>&#123;assistStack.push(<span class="hljs-keyword">value</span>);minValue = <span class="hljs-keyword">value</span>;&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//否则用minValue与value比较，小的push进辅助栈，且更新minValue</span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> &lt; minValue)minValue = <span class="hljs-keyword">value</span>;assistStack.push(minValue);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span>(<span class="hljs-params"></span>) </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (!dataStack.empty())<span class="hljs-comment">//非空时操作</span>&#123;dataStack.pop();assistStack.pop();<span class="hljs-comment">//更新辅助栈，保证每层之下的最小值不变</span>minValue = assistStack.top();<span class="hljs-comment">//将minValue更新为这层之下的最小值</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span>(<span class="hljs-params"></span>) </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(!dataStack.empty())<span class="hljs-comment">//非空时进行</span><span class="hljs-keyword">return</span> dataStack.top();<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span>(<span class="hljs-params"></span>) </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> minValue;<span class="hljs-comment">//直接返回minValue</span>&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（19）顺时针打印矩阵</title>
    <link href="/2020/06/28/print-matrix-clockwise/"/>
    <url>/2020/06/28/print-matrix-clockwise/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">/*</span><span class="hljs-comment">1 -&gt; 2 -&gt; 3  -&gt;   4</span><span class="hljs-comment">                  ↓</span><span class="hljs-comment">5 -&gt; 6 -&gt; 7       8</span><span class="hljs-comment">↑        ↓       ↓</span><span class="hljs-comment">9   10  &lt;-  11    12</span><span class="hljs-comment">↑                 ↓</span><span class="hljs-comment">13 &lt;- 14 &lt;- 15 &lt;- 16</span><span class="hljs-comment">*/</span><span class="hljs-comment">//将问题分解成若干子问题</span><span class="hljs-comment">//1.控制按圈打印</span><span class="hljs-comment">//2.一圈之内如何打印</span><span class="hljs-comment">//每一圈的起始坐标都在矩阵主对角线上，判断何时结束绕圈</span><span class="hljs-comment">//圈内打印时注意判断特殊情况，最少都有一行</span><span class="hljs-comment">//1.只有一行</span><span class="hljs-comment">//2.只有一列</span><span class="hljs-comment">//3.2*2大小</span><span class="hljs-comment">//4.3*3大小及以上</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:vector&lt;<span class="hljs-built_in">int</span>&gt; printMatrix(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt; &gt; matrix) &#123;vector&lt;<span class="hljs-built_in">int</span>&gt; vec;<span class="hljs-built_in">int</span> row = matrix.size();<span class="hljs-keyword">if</span> (row &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> vec;<span class="hljs-comment">//判断vector是否为空</span><span class="hljs-built_in">int</span> col = matrix[<span class="hljs-number">0</span>].size();<span class="hljs-built_in">int</span> startRow = <span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> startCol = <span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> endRow = matrix.size() - <span class="hljs-number">1</span>;<span class="hljs-built_in">int</span> endCol = matrix[<span class="hljs-number">0</span>].size() - <span class="hljs-number">1</span>;<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (row &gt; startRow * <span class="hljs-number">2</span> &amp;&amp; col &gt; startCol * <span class="hljs-number">2</span>)<span class="hljs-comment">//判断起始点是否真实存在</span>&#123;<span class="hljs-keyword">for</span> (i = startCol; i &lt;= endCol; ++i)<span class="hljs-comment">//无论如何，最少都会有一行</span>&#123;vec.push_back(matrix[startRow][i]);&#125;<span class="hljs-comment">//如果进行第二步打印，必须满足endRow-startRow&gt;=1,排除只有一行的情况</span><span class="hljs-keyword">if</span> (endRow - startRow &gt;= <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">for</span> (i = startRow + <span class="hljs-number">1</span>; i &lt;= endRow; ++i)&#123;vec.push_back(matrix[i][endCol]);&#125;&#125;<span class="hljs-comment">//如果进行第三步打印，要在第二步条件的基础上满足endCol-startCol&gt;=1,排除只有一列的情况</span><span class="hljs-keyword">if</span> (endCol - startCol &gt;= <span class="hljs-number">1</span> &amp;&amp; endRow - startRow &gt;= <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">for</span> (i = endCol - <span class="hljs-number">1</span>; i &gt;= startCol; --i)&#123;vec.push_back(matrix[endRow][i]);&#125;&#125;<span class="hljs-comment">//如果进行第四步打印，要在第三步条件的基础上满足endRow-startRow&gt;=2,排除2*2的情况</span><span class="hljs-keyword">if</span> (endRow - startRow &gt;= <span class="hljs-number">2</span> &amp;&amp; endCol - startCol &gt;= <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">for</span> (i = endRow - <span class="hljs-number">1</span>; i &gt; startRow; --i)&#123;vec.push_back(matrix[i][startCol]);&#125;&#125;<span class="hljs-comment">//调整边界范围，进行下一圈打印</span>startRow += <span class="hljs-number">1</span>;startCol += <span class="hljs-number">1</span>;endRow -= <span class="hljs-number">1</span>;endCol -= <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> vec;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（18）二叉树的镜像</title>
    <link href="/2020/06/28/mirror-of-the-binary-tree/"/>
    <url>/2020/06/28/mirror-of-the-binary-tree/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>操作给定的二叉树，将其变换为源二叉树的镜像。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs xl"><span class="hljs-comment">//每一个节点都是每一棵子树的根节点，只须交换左右孩子节点即可</span><span class="hljs-comment">//注意输入空指针防御</span><span class="hljs-comment">/*输入样例</span><span class="hljs-comment">二叉树的镜像定义：源二叉树 </span><span class="hljs-comment">        8</span><span class="hljs-comment">       /  \</span><span class="hljs-comment">      6   10</span><span class="hljs-comment">     / \  / \</span><span class="hljs-comment">    5  7 9 11</span><span class="hljs-comment">    镜像二叉树</span><span class="hljs-comment">        8</span><span class="hljs-comment">       /  \</span><span class="hljs-comment">      10   6</span><span class="hljs-comment">     / \  / \</span><span class="hljs-comment">    11 9 7  5</span><span class="hljs-comment">*/</span><span class="hljs-comment">/*节点结构体定义</span><span class="hljs-comment">struct TreeNode </span><span class="hljs-comment">&#123;</span><span class="hljs-comment">int val;</span><span class="hljs-comment">struct TreeNode *left;</span><span class="hljs-comment">struct TreeNode *right;</span><span class="hljs-comment">TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span>class Solution &#123;public:void Mirror(TreeNode *pRoot) &#123;<span class="hljs-keyword">if</span> (pRoot == NULL) return;<span class="hljs-comment">//判断是否为空指针</span>T<span class="hljs-function"><span class="hljs-title">reeNode</span> *tmp = pRoot-&gt;</span>left;<span class="hljs-comment">//否则交换左右孩子的指向</span><span class="hljs-function"><span class="hljs-title">pRoot</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span> = pRoot-&gt;</span>right;<span class="hljs-function"><span class="hljs-title">pRoot</span>-&gt;</span>right = tmp;M<span class="hljs-function"><span class="hljs-title">irror</span>(pRoot-&gt;</span>left);<span class="hljs-comment">//递归调用对左孩子镜像处理</span>M<span class="hljs-function"><span class="hljs-title">irror</span>(pRoot-&gt;</span>right);<span class="hljs-comment">//递归调用对右孩子镜像处理</span>&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（17）树的子结构</title>
    <link href="/2020/06/28/tree-substructure/"/>
    <url>/2020/06/28/tree-substructure/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs zephir"><span class="hljs-comment">//分两步</span><span class="hljs-comment">//第一步：寻找与B树根节点val相等的A树节点。如果找到进入第二步，否则继续寻找，直到找完A树</span><span class="hljs-comment">//第二步：以找的节点作为A树子树的根节点，同时遍历两棵树，判断是否所有节点都相同</span><span class="hljs-comment">//特殊情况：</span><span class="hljs-comment">//1.进行第二步时注意有可能存在B树大小等于A的子树、B树大小小于A的子树、B树大小大于A的子树</span><span class="hljs-comment">//2.注意对无效值的防御</span><span class="hljs-comment">//3.减少递归此数，及时判断return</span><span class="hljs-comment">/*</span><span class="hljs-comment">struct TreeNode </span><span class="hljs-comment">&#123;</span><span class="hljs-comment">int val;</span><span class="hljs-comment">struct TreeNode *left;</span><span class="hljs-comment">struct TreeNode *right;</span><span class="hljs-comment">TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-comment">//第二步</span><span class="hljs-keyword">bool</span> Subtree(TreeNode* pRoot1, TreeNode* pRoot2)&#123;<span class="hljs-keyword">if</span> (pRoot1 == <span class="hljs-keyword">NULL</span> &amp;&amp; pRoot2 == <span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<span class="hljs-comment">//B树大小等于A的子树</span><span class="hljs-keyword">if</span> (pRoot1 != <span class="hljs-keyword">NULL</span> &amp;&amp; pRoot2 == <span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<span class="hljs-comment">//B树大小小于A的子树</span><span class="hljs-keyword">if</span> (pRoot1 == <span class="hljs-keyword">NULL</span> &amp;&amp; pRoot2 != <span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<span class="hljs-comment">//B树大小大于A的子树</span><span class="hljs-keyword">if</span> (pRoot1-&gt;val == pRoot2-&gt;val)<span class="hljs-comment">//如果val相等则进行进一步比较</span><span class="hljs-keyword">return</span> Subtree(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; Subtree(pRoot1-&gt;right, pRoot2-&gt;right);<span class="hljs-keyword">else</span><span class="hljs-comment">//否则直接return</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-comment">//第一步</span><span class="hljs-keyword">bool</span> HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)&#123;<span class="hljs-comment">//对空指针防御</span><span class="hljs-keyword">if</span> (pRoot1 == <span class="hljs-keyword">NULL</span> || pRoot2 == <span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;TreeNode *p1 = pRoot1;<span class="hljs-keyword">bool</span> flag = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//是否相等标志</span><span class="hljs-keyword">if</span> (p1-&gt;val == pRoot2-&gt;val)<span class="hljs-comment">//若A树有节点val等于B树根节点val，进入第二步</span>&#123;flag = Subtree(p1, pRoot2);<span class="hljs-comment">//开始第二步递归调用</span><span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> flag;<span class="hljs-comment">//如果是子结构，直接return</span>&#125;<span class="hljs-comment">//否则继续第一步</span>flag = HasSubtree(p1-&gt;left, pRoot2);<span class="hljs-comment">//对左子树进行第一步</span><span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> flag;flag = HasSubtree(p1-&gt;right, pRoot2);<span class="hljs-comment">//对右子树进行第一步</span><span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> flag;<span class="hljs-keyword">return</span> flag;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（16）合并两个排序的链表</title>
    <link href="/2020/06/28/merge-two-sorted-linked-lists/"/>
    <url>/2020/06/28/merge-two-sorted-linked-lists/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs php"><span class="hljs-comment">//本题在线测试用例怎么还是无头节点链表→_→，啊...</span><span class="hljs-comment">//比较value谁小谁添加到新链表中</span><span class="hljs-comment">//新链表的头节点指针为newHead，由s指针负责添加信节点</span><span class="hljs-comment">//特殊情况：</span><span class="hljs-comment">//1.传入空指针</span><span class="hljs-comment">//2.任意一个链表添加完毕</span><span class="hljs-comment">//3.传入的一个链表为空，另一个不为空</span><span class="hljs-comment">//节点结构体定义</span><span class="hljs-comment">/*</span><span class="hljs-comment">struct ListNode </span><span class="hljs-comment">&#123;</span><span class="hljs-comment">int val;</span><span class="hljs-comment">struct ListNode *next;</span><span class="hljs-comment">ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">public</span>:ListNode* Merge(ListNode* pHead1, ListNode* pHead2)&#123;<span class="hljs-comment">//判断传入参数是否为空</span><span class="hljs-keyword">if</span> (pHead1 == <span class="hljs-keyword">NULL</span> &amp;&amp; pHead2 == <span class="hljs-keyword">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">NULL</span>;ListNode *newHead = <span class="hljs-keyword">NULL</span>;<span class="hljs-comment">//新链表的头指针</span>ListNode *s = <span class="hljs-keyword">NULL</span>;<span class="hljs-comment">//负责给新链表添加心节点</span><span class="hljs-keyword">while</span> (pHead1 != <span class="hljs-keyword">NULL</span> &amp;&amp; pHead2 != <span class="hljs-keyword">NULL</span>)<span class="hljs-comment">//直到将一个链表添加完</span>&#123;<span class="hljs-keyword">if</span> (pHead1-&gt;val &lt;= pHead2-&gt;val)<span class="hljs-comment">//谁小谁添加</span>&#123;<span class="hljs-keyword">if</span> (newHead == s &amp;&amp; newHead == <span class="hljs-keyword">NULL</span>)<span class="hljs-comment">//第一次添加节点</span>&#123;newHead = pHead1;s = pHead1;&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//除第一次以外添加节点</span>&#123;s-&gt;next = pHead1;s = s-&gt;next;&#125;pHead1 = pHead1-&gt;next;<span class="hljs-comment">//使pHead1指向为排序节点</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (newHead == s &amp;&amp; newHead == <span class="hljs-keyword">NULL</span>)<span class="hljs-comment">//第一次添加节点情况</span>&#123;newHead = pHead2;s = pHead2;&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//除第一次情况以外</span>&#123;s-&gt;next = pHead2;s = s-&gt;next;&#125;pHead2 = pHead2-&gt;next;&#125;&#125;<span class="hljs-comment">//判断是否为一个为空另一个不为空的情况</span><span class="hljs-keyword">if</span> (newHead == <span class="hljs-keyword">NULL</span> &amp;&amp; pHead1 != <span class="hljs-keyword">NULL</span>) newHead = pHead1;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newHead == <span class="hljs-keyword">NULL</span> &amp;&amp; pHead2 != <span class="hljs-keyword">NULL</span>) newHead = pHead2;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pHead1 != <span class="hljs-keyword">NULL</span>) s-&gt;next = pHead1;<span class="hljs-comment">//判断是否还有链表未添加完</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pHead2 != <span class="hljs-keyword">NULL</span>)s-&gt;next = pHead2;<span class="hljs-keyword">return</span> newHead;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（15）反转链表</title>
    <link href="/2020/06/28/reverse-linked-list/"/>
    <url>/2020/06/28/reverse-linked-list/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一个链表，反转链表后，输出链表的所有元素。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs php"><span class="hljs-comment">//此题在线用例还是无头链表→_→</span><span class="hljs-comment">//1&lt;-2&lt;-3 4-&gt;5</span><span class="hljs-comment">//   p  s q</span><span class="hljs-comment">//保证三个指针指向相邻的三个节点</span><span class="hljs-comment">//健壮性：</span><span class="hljs-comment">//1.传入空指针</span><span class="hljs-comment">//2.链表中只有一个节点</span><span class="hljs-comment">/*节点结构体定义</span><span class="hljs-comment">struct ListNode </span><span class="hljs-comment">&#123;</span><span class="hljs-comment">int val;</span><span class="hljs-comment">struct ListNode *next;</span><span class="hljs-comment">ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">public</span>:ListNode* ReverseList(ListNode* pHead) &#123;<span class="hljs-keyword">if</span> (pHead == <span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">NULL</span>;<span class="hljs-comment">//放置传入空指针</span>ListNode *p = pHead;ListNode *s = pHead-&gt;next;ListNode *q = pHead;p-&gt;next = <span class="hljs-keyword">NULL</span>;<span class="hljs-comment">//首先将第一个节点的next赋值为NULL</span><span class="hljs-keyword">while</span> (s != <span class="hljs-keyword">NULL</span>)<span class="hljs-comment">//判断是否还有为反转节点</span>&#123;q = s-&gt;next;<span class="hljs-comment">//预先保存s的next</span>s-&gt;next = p;<span class="hljs-comment">//连到已反转链表</span>p = s;<span class="hljs-comment">//指向已反转链表的第一个节点</span>s = q;<span class="hljs-comment">//指向未反转链表的第一个节点</span>&#125;<span class="hljs-keyword">return</span> p;&#125;&#125;;<span class="hljs-comment">//使用两个指针，用pHead代替上面方法的p的作用</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">public</span>:ListNode* ReverseList(ListNode* pHead)&#123;<span class="hljs-keyword">if</span> (pHead == <span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">NULL</span>;ListNode *p = pHead;ListNode *s = pHead-&gt;next;pHead-&gt;next = <span class="hljs-keyword">NULL</span>;<span class="hljs-keyword">while</span> (s != <span class="hljs-keyword">NULL</span>)&#123;p = s;s = s-&gt;next;<span class="hljs-comment">//保存下一个未反转节点</span>p-&gt;next = pHead;pHead = p;&#125;<span class="hljs-keyword">return</span> pHead;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（14）链表中倒数第k个结点</title>
    <link href="/2020/06/28/the-last-k-th-node-in-the-list/"/>
    <url>/2020/06/28/the-last-k-th-node-in-the-list/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一个链表，输出该链表中倒数第k个结点。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs zephir"><span class="hljs-comment">//在线测试用例依旧是无头链表→_→</span><span class="hljs-comment">//最后一个节点定义为倒数第一个节点</span><span class="hljs-comment">//1-&gt;2-&gt;3-&gt;4-&gt;5</span><span class="hljs-comment">//p     s</span><span class="hljs-comment">//      p     s</span><span class="hljs-comment">//eg.寻找倒数第3个节点 k-1=2</span><span class="hljs-comment">//要想一次遍历找到倒数第k个节点，关键在于最后一个节点与倒数第k个节点之间相差k-1个节点</span><span class="hljs-comment">//所以要保证两个指针之间一直保持k-1个节点差</span><span class="hljs-comment">//健壮性：</span><span class="hljs-comment">//1.传入空指针</span><span class="hljs-comment">//2.k为无符号正数，k&lt;1</span><span class="hljs-comment">//3.不存在倒数第k个节点</span><span class="hljs-comment">/*节点结构体定义</span><span class="hljs-comment">struct ListNode &#123;</span><span class="hljs-comment">int val;</span><span class="hljs-comment">struct ListNode *next;</span><span class="hljs-comment">ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class"></span>&#123;<span class="hljs-keyword">public</span>:ListNode* FindKthToTail(ListNode* pListHead, unsigned <span class="hljs-keyword">int</span> k) &#123;<span class="hljs-keyword">if</span> (pListHead == <span class="hljs-keyword">NULL</span> || k &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">NULL</span>;<span class="hljs-comment">//传入空指针、k无效</span>ListNode *p = pListHead;ListNode *s = pListHead;<span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录s指针移动的次数</span><span class="hljs-keyword">while</span> (s-&gt;next != <span class="hljs-keyword">NULL</span>)<span class="hljs-comment">//直到遍历完此链表</span>&#123;s = s-&gt;next;++num;<span class="hljs-comment">//当s移动次数大于等于k时，才能让p开始移动，此时两指针保持k-1距离</span><span class="hljs-keyword">if</span> (num &gt;= k) p = p-&gt;next;&#125;<span class="hljs-comment">//如果s移动次数都小于两者必须的间距，说明不存在倒数第k个节点</span><span class="hljs-keyword">if</span> (num &lt; k - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">NULL</span>;<span class="hljs-keyword">return</span> p;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（13）调整数组顺序使奇数位于偶数前面</title>
    <link href="/2020/06/28/adjust-the-array-order-so-that-odd-numbers-are-in-front-of-even-numbers/"/>
    <url>/2020/06/28/adjust-the-array-order-so-that-odd-numbers-are-in-front-of-even-numbers/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs arduino"><span class="hljs-comment">//很奇怪，竟然加了“保证奇数和奇数，偶数和偶数之间的相对位置不变。”这个条件→_→</span><span class="hljs-comment">//如果加了这个条件，目前想到的是开辟一个新的vector从array中遍历</span><span class="hljs-comment">//第一次遍历，将奇数push，第二次遍历再将偶数push</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reOrderArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;<span class="hljs-built_in">array</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">array</span>.<span class="hljs-built_in">size</span>(); ++i)<span class="hljs-comment">//array为空直接跳出</span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i] &amp; <span class="hljs-number">0x1</span>)res.push_back(<span class="hljs-built_in">array</span>[i]);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">array</span>.<span class="hljs-built_in">size</span>(); i++)<span class="hljs-comment">//array为空直接跳出</span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)res.push_back(<span class="hljs-built_in">array</span>[i]);&#125;<span class="hljs-built_in">array</span> = res;&#125;&#125;;<span class="hljs-comment">//如果不考虑“保证奇数和奇数，偶数和偶数之间的相对位置不变。”这个条件</span><span class="hljs-comment">//维护两个指针/迭代器，itp寻找下一个最近的偶数，its寻找前一个最近的奇数</span><span class="hljs-comment">//当itp &gt; its时，说明全部奇数都在偶数前面</span><span class="hljs-comment">//特殊情况：</span><span class="hljs-comment">//当its - itp == 1时，不需要再交换</span><span class="hljs-comment">//全部为奇数</span><span class="hljs-comment">//全部为偶数</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reOrderArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;<span class="hljs-built_in">array</span>)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = <span class="hljs-built_in">array</span>.<span class="hljs-built_in">size</span>();<span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> == <span class="hljs-number">0</span> || <span class="hljs-built_in">size</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//为空或只有一个元素时</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator itp = <span class="hljs-built_in">array</span>.<span class="hljs-built_in">begin</span>();<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator its = <span class="hljs-built_in">array</span>.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (itp &lt; its)<span class="hljs-comment">//保证还有数字未调整</span>&#123;<span class="hljs-comment">//寻找下一个偶数，</span><span class="hljs-keyword">while</span> (itp != <span class="hljs-built_in">array</span>.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span> &amp;&amp; *itp &amp; <span class="hljs-number">0x1</span>) ++itp;<span class="hljs-comment">//寻找下一个奇数</span><span class="hljs-keyword">while</span> (its != <span class="hljs-built_in">array</span>.<span class="hljs-built_in">begin</span>() &amp;&amp; !(*its &amp; <span class="hljs-number">0x1</span>)) --its;<span class="hljs-comment">//判断是否itp剩下的全为奇数或its剩下的全为偶数</span><span class="hljs-keyword">if</span> (itp == <span class="hljs-built_in">array</span>.<span class="hljs-built_in">end</span>() || its == <span class="hljs-built_in">array</span>.<span class="hljs-built_in">begin</span>()) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(itp &lt; its)<span class="hljs-comment">//保证非its - itp == 1的情况</span>&#123;tmp = *itp;*itp = *its;*its = tmp;&#125;&#125;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（12）数值的整数次方</title>
    <link href="/2020/06/28/numerical-integer-power/"/>
    <url>/2020/06/28/numerical-integer-power/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">//方法一：循环</span><span class="hljs-comment">//此题不需要考虑计算后值溢出的情况，即不存在大数情况</span><span class="hljs-comment">//异常情况：</span><span class="hljs-comment">//底数为0时-&gt;0.0</span><span class="hljs-comment">//指数为0时-&gt;1.0(数学定义)</span><span class="hljs-comment">//指数为负数时，需要考虑先计算指数绝对值的结果，再取倒数</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">double</span> Power(<span class="hljs-built_in">double</span> base, <span class="hljs-built_in">int</span> exponent)&#123;<span class="hljs-comment">//底数为0时，因为base为double类型，所以需要进行范围判断</span><span class="hljs-keyword">if</span> (base - <span class="hljs-number">0</span> &lt;= <span class="hljs-number">0.0000001</span> &amp;&amp; base - <span class="hljs-number">0</span> &gt;= <span class="hljs-number">-0.0000001</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<span class="hljs-keyword">if</span> (exponent == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<span class="hljs-comment">//指数为0，return</span><span class="hljs-built_in">double</span> res = base;<span class="hljs-built_in">int</span> unsigned_exponent = abs(exponent);<span class="hljs-comment">//先取绝对值，考虑exp为负</span><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">2</span>; i &lt;= unsigned_exponent; ++i)&#123;res *= base;&#125;<span class="hljs-keyword">if</span> (exponent &lt; <span class="hljs-number">0</span>) res = <span class="hljs-number">1.0</span> / res;<span class="hljs-comment">//exp为负数时，取res的倒数</span><span class="hljs-keyword">return</span> res;&#125;&#125;;<span class="hljs-comment">//方法二：递归</span><span class="hljs-comment">//计算的指数若为n，则只需计算指数为(n/2)时的值，用这个值再平方就可以得到指数为n的值</span><span class="hljs-comment">//注意：</span><span class="hljs-comment">//n为奇数时。需要再乘以一个base，因为(n/2)向下取整</span><span class="hljs-comment">//exponent还是先计算为正数的情况，之后再判断是否求倒数</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">double</span> unsignedPower(<span class="hljs-built_in">double</span> base, <span class="hljs-built_in">int</span> exponent)&#123;<span class="hljs-keyword">if</span> (exponent == <span class="hljs-number">1</span>)<span class="hljs-comment">//指数为1，return base</span><span class="hljs-keyword">return</span> base;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exponent == <span class="hljs-number">0</span>)<span class="hljs-comment">//指数为0，return 1</span><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-built_in">double</span> res = unsignedPower(base, exponent &gt;&gt; <span class="hljs-number">1</span>);<span class="hljs-comment">//右移一位-&gt;除2</span>res *= res;<span class="hljs-comment">//再平方，减少运算次数</span><span class="hljs-keyword">if</span> (exponent &amp; <span class="hljs-number">0x1</span>) res *= base;<span class="hljs-comment">//判断指数是否为奇数，与1异或-&gt;模2</span><span class="hljs-keyword">return</span> res;&#125;<span class="hljs-built_in">double</span> Power(<span class="hljs-built_in">double</span> base, <span class="hljs-built_in">int</span> exponent)&#123;<span class="hljs-comment">//判断底数是否为0</span><span class="hljs-keyword">if</span> (base - <span class="hljs-number">0</span> &lt;= <span class="hljs-number">0.0000001</span> &amp;&amp; base - <span class="hljs-number">0</span> &gt;= <span class="hljs-number">-0.0000001</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<span class="hljs-keyword">if</span> (exponent == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>; <span class="hljs-comment">//判断指数是否为0</span><span class="hljs-keyword">if</span> (exponent &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / unsignedPower(base, abs(exponent));<span class="hljs-comment">//负指数应求倒数</span><span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> unsignedPower(base, abs(exponent));&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（11）二进制中1的个数</title>
    <link href="/2020/06/28/the-number-of-1s-in-binary/"/>
    <url>/2020/06/28/the-number-of-1s-in-binary/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">//方法一</span><span class="hljs-comment">//使测试数据x中只有一个1，逐步右移，使这个1从数值最低位到数值最高位与n依次比较</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">int</span> NumberOf1(<span class="hljs-built_in">int</span> n) &#123;<span class="hljs-built_in">int</span> x = <span class="hljs-number">1</span>;<span class="hljs-built_in">int</span> num = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; sizeof(<span class="hljs-built_in">int</span>)*<span class="hljs-number">8</span>; ++i)<span class="hljs-comment">//计算x的位数</span>&#123;<span class="hljs-keyword">if</span> (n &amp; x) ++num;<span class="hljs-comment">//n与x进行位与运算</span>x = x &lt;&lt; <span class="hljs-number">1</span>;<span class="hljs-comment">//x右移1位</span>&#125;<span class="hljs-keyword">return</span> num;&#125;&#125;;<span class="hljs-comment">//方法二</span><span class="hljs-comment">//数字0中没有1</span><span class="hljs-comment">//非0数字中一定有1</span><span class="hljs-comment">//将n = n-1使其最低位的1变零，此位之前的位不受影响，此位之后的位全从0变1</span><span class="hljs-comment">//如果n此时不为0，说明还有1存在，重复上步骤。</span><span class="hljs-comment">//如果n = 0时，1的个数计算完毕，return。</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">int</span> NumberOf1(<span class="hljs-built_in">int</span> n)&#123;<span class="hljs-built_in">int</span> num = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>)<span class="hljs-comment">//n中还有1存在</span>&#123;++num;n = n &amp; (n - <span class="hljs-number">1</span>);<span class="hljs-comment">//进行位与计算，使此位的1变0</span>&#125;<span class="hljs-keyword">return</span> num;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（10）矩形覆盖</title>
    <link href="/2020/06/28/rectangle-cover/"/>
    <url>/2020/06/28/rectangle-cover/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">//有两种放置方法</span><span class="hljs-comment">//1.左边竖着放一个，则还剩下2*(n-1)</span><span class="hljs-comment">//2.左上角横着放一个，相应左下角也横着放一个，则还剩下2*(n-2)</span><span class="hljs-comment">//f(n) = f(n-1) + f(n-2)</span><span class="hljs-comment">//特殊情况：不存在时返回0；2*1时只有竖着放一种情况；2*2时两种情况</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">int</span> rectCover(<span class="hljs-built_in">int</span> number)&#123;<span class="hljs-keyword">if</span> (number &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//特殊情况</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(number == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (number == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>, tmp = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">3</span>; i &lt;= number; ++i)&#123;tmp = a + b;a = b;b = tmp;&#125;<span class="hljs-keyword">return</span> tmp;&#125;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（9）变态跳台阶</title>
    <link href="/2020/06/28/abnormal-jump-step/"/>
    <url>/2020/06/28/abnormal-jump-step/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">//有n级台阶</span><span class="hljs-comment">//若跳1级则剩下n-1级，跳法f(n-1)</span><span class="hljs-comment">//若跳2级则剩下n-2级，跳法f(n-2)</span><span class="hljs-comment">//若跳3级则剩下n-3级，跳法f(n-3)</span><span class="hljs-comment">//若跳n-级则剩下1级，跳法f(n-(n-1))，即剩下一个台阶</span><span class="hljs-comment">//若跳n级则剩下0级，跳法f(0)，即为1种方法</span><span class="hljs-comment">//f(n) = 1 + f(n-1) + f(n-2) + ... +f (1)</span><span class="hljs-comment">//f(1) = 1</span><span class="hljs-comment">//f(2) = 1 + f(1) = 2；</span><span class="hljs-comment">//f(3) = 1 + f(2) + f(1) = 4...</span><span class="hljs-comment">//以此类推</span><span class="hljs-comment">//f(n) = 2^(n-1)</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">int</span> jumpFloorII(<span class="hljs-built_in">int</span> number)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &lt;&lt; --number;<span class="hljs-comment">//左移n-1位</span>&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（8）跳台阶</title>
    <link href="/2020/06/28/jump-the-stairs/"/>
    <url>/2020/06/28/jump-the-stairs/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">//两种跳跃方式：跳1级或跳2级</span><span class="hljs-comment">//假设有n级台阶，跳1级还剩余n-1级，跳2级还剩余n-2级，那剩余台阶继续选择跳法</span><span class="hljs-comment">//f(n) = f(n-1) + f(n-2) -&gt; 斐波那契数列</span><span class="hljs-comment">//n = 1时，1</span><span class="hljs-comment">//n = 2时，2</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">int</span> jumpFloor(<span class="hljs-built_in">int</span> n)&#123;        <span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>, tmp = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//特殊情况只有1级台阶</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-comment">//特殊情况只有2级台阶</span><span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; ++i)&#123;tmp = a + b;a = b;b = tmp;&#125;<span class="hljs-keyword">return</span> b;&#125;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（7）斐波那契数列</title>
    <link href="/2020/06/28/fibonacci-sequence/"/>
    <url>/2020/06/28/fibonacci-sequence/</url>
    
    <content type="html"><![CDATA[<p><strong>题目说明：</strong></p><blockquote><p><strong>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">//0 1 1 2 3 5 8 13 21...</span><span class="hljs-comment">//简洁的递归，但是注意消除重复计算项，采用map存储已计算的n的value</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:map&lt;<span class="hljs-built_in">int</span>, long long&gt; m;long long num;<span class="hljs-built_in">int</span> Fibonacci(<span class="hljs-built_in">int</span> n) &#123;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span>&#123;map&lt;<span class="hljs-built_in">int</span>, long long&gt;::iterator it = m.find(n);<span class="hljs-comment">//查找是否已计算过</span><span class="hljs-keyword">if</span> (m.end() == it)<span class="hljs-comment">//之前没算过，进行计算，再insert</span>&#123;num = Fibonacci(n - <span class="hljs-number">1</span>) + Fibonacci(n - <span class="hljs-number">2</span>);m.insert(pair&lt;<span class="hljs-built_in">int</span>, long long&gt;(n, num));<span class="hljs-keyword">return</span> num;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> it-&gt;second;<span class="hljs-comment">//若之前算过，直接get second</span>&#125;&#125;&#125;;<span class="hljs-comment">//O(n)的循环方法，没有什么好解释的...→_→</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">int</span> Fibonacci(<span class="hljs-built_in">int</span> n) &#123;long long res[<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span> &#125;;long long tmp = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)&#123;<span class="hljs-comment">//空瓶子swap</span>tmp = res[<span class="hljs-number">0</span>] + res[<span class="hljs-number">1</span>];res[<span class="hljs-number">0</span>] = res[<span class="hljs-number">1</span>];res[<span class="hljs-number">1</span>] = tmp;&#125;<span class="hljs-keyword">return</span> res[<span class="hljs-number">1</span>];&#125;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（6）旋转数组的最小数字</title>
    <link href="/2020/06/28/rotate-the-smallest-number-of-an-array/"/>
    <url>/2020/06/28/rotate-the-smallest-number-of-an-array/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</strong><br>   <strong>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。</strong><br>   <strong>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。</strong><br>   <strong>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs arduino"><span class="hljs-comment">//&#123;3,4,5,1,2&#125;</span><span class="hljs-comment">// l   m   r</span><span class="hljs-comment">//规律：一般前旋转区的数大于等于后旋转区的数</span><span class="hljs-comment">//注意特殊情况</span><span class="hljs-comment">//1.旋转数为0个，即未旋转，此时rotateArray[0]为min</span><span class="hljs-comment">//2.&#123;0,1,1,1,1&#125;-&gt;&#123;1,1,1,0,1&#125;</span><span class="hljs-comment">//                l   m   r 此时无法判断middle在前旋转区还是后旋转区</span><span class="hljs-comment">//O(logn)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-comment">//遍历vector</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">searchInRotateArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; rotateArray)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = rotateArray.<span class="hljs-built_in">begin</span>();<span class="hljs-keyword">int</span> <span class="hljs-built_in">min</span> = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (; it != rotateArray.<span class="hljs-built_in">end</span>(); ++it)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span> &gt; *it) <span class="hljs-built_in">min</span> = *it;&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minNumberInRotateArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; rotateArray)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (rotateArray.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//数组异常</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator itleft = rotateArray.<span class="hljs-built_in">begin</span>();<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator itright = rotateArray.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator itmiddle = itleft;<span class="hljs-comment">//防止未旋转情况</span><span class="hljs-comment">//第一次循环条件不满足时，即为未旋转情况，直接return</span><span class="hljs-keyword">while</span> (*itleft &gt;= *itright)&#123;itmiddle = itleft + (itright - itleft)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> (itright - itleft == <span class="hljs-number">1</span>)<span class="hljs-comment">//相邻时itright即为min</span>&#123;itmiddle = itright;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-comment">//当l==m==r时，只能采取遍历方式寻找min</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*itleft == *itright &amp;&amp; *itleft == *itmiddle)<span class="hljs-keyword">return</span> searchInRotateArray(rotateArray);<span class="hljs-comment">//此时min在后旋转区</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*itleft &lt;= *itmiddle) itleft = itmiddle;<span class="hljs-comment">//此时min在前旋转区</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*itright &gt;= *itmiddle) itright = itmiddle;&#125;<span class="hljs-keyword">return</span> *itmiddle;&#125;&#125;;<span class="hljs-comment">//嘿嘿...直接sort，费这老鼻子劲→_→</span><span class="hljs-comment">//O(n)</span><span class="hljs-comment">/*</span><span class="hljs-comment">#include &lt;algorithm&gt;</span><span class="hljs-comment">class Solution &#123;</span><span class="hljs-comment">public:</span><span class="hljs-comment">int minNumberInRotateArray(vector&lt;int&gt; rotateArray)</span><span class="hljs-comment">&#123;</span><span class="hljs-comment">sort(rotateArray.begin(), rotateArray.end());</span><span class="hljs-comment">return rotateArray[0];</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（5）用两个栈实现队列</title>
    <link href="/2020/06/28/implement-queue-with-two-stacks/"/>
    <url>/2020/06/28/implement-queue-with-two-stacks/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs arduino"><span class="hljs-comment">//栈：先进后出 队列：先进先出</span><span class="hljs-comment">//注意最后一个元素的转移优化</span><span class="hljs-comment">//两个队列实现一个栈</span><span class="hljs-comment">//stack1负责入栈，stack2负责出栈</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span> </span><span class="hljs-function"></span>&#123;stack1.push(node);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (!stack2.empty())<span class="hljs-comment">//stack2不为空，说明有数据，可以直接pop</span>&#123;x = stack2.top();stack2.pop();&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//否则将stack1中的除最后一个的其余数据先pop再依次push到stack2中</span><span class="hljs-keyword">while</span> (!stack1.empty())&#123;x = stack1.top();<span class="hljs-keyword">if</span> (stack1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)&#123;stack1.pop();<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">else</span>&#123;stack1.pop();stack2.push(x);&#125;&#125;&#125;<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-keyword">private</span>:<span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; stack1;<span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; stack2;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（4）重建二叉树</title>
    <link href="/2020/06/28/rebuild-binary-tree/"/>
    <url>/2020/06/28/rebuild-binary-tree/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs reasonml"><span class="hljs-comment">//前序中序、后序中序都可以重建二叉树，但前序后序不可以，因为只有中序可以区分左子树与右子树</span><span class="hljs-comment">/*</span><span class="hljs-comment">pre:&#123;1,2,4,7,3,5,6,8&#125;</span><span class="hljs-comment">vin:&#123;4,7,2,1,5,3,8,6&#125;</span><span class="hljs-comment">*/</span><span class="hljs-comment">//Definition for binary tree</span><span class="hljs-comment">/*</span><span class="hljs-comment">struct TreeNode</span><span class="hljs-comment">&#123;</span><span class="hljs-comment">    int val;</span><span class="hljs-comment">    TreeNode *left;</span><span class="hljs-comment">    TreeNode *right;</span><span class="hljs-comment">    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-keyword">class</span> Solution&#123;public:    TreeNode* re<span class="hljs-constructor">ConstructBinaryTree(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt; <span class="hljs-params">pre</span>, <span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt; <span class="hljs-params">vin</span>)</span>    &#123;    <span class="hljs-comment">//判断异常情况：前序为空或后序为空或两者个数不同</span>        <span class="hljs-keyword">if</span> (pre.size<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> || </span>vin.size<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> || </span>pre.size<span class="hljs-literal">()</span> != vin.size<span class="hljs-literal">()</span>)         return NULL;        <span class="hljs-keyword">else</span> <span class="hljs-comment">//调用递归函数</span>        return <span class="hljs-constructor">ConstructBinaryTree(<span class="hljs-params">pre</span>.<span class="hljs-params">begin</span>()</span>, vin.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>, pre.size<span class="hljs-literal">()</span>);    &#125;     TreeNode* <span class="hljs-constructor">ConstructBinaryTree(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;::<span class="hljs-params">iterator</span> <span class="hljs-params">itp</span>, <span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;::<span class="hljs-params">iterator</span> <span class="hljs-params">itv</span>, <span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span>    &#123;        TreeNode *s = NULL;        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)        &#123;            s = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-operator">*</span><span class="hljs-params">itp</span>)</span>;            <span class="hljs-comment">//在中序序列中寻找根结点的对应下标</span>            <span class="hljs-built_in">int</span> index = <span class="hljs-constructor">FindIndex(<span class="hljs-params">itv</span>, <span class="hljs-params">n</span>, <span class="hljs-operator">*</span><span class="hljs-params">itp</span>)</span>;            <span class="hljs-keyword">if</span> (index<span class="hljs-operator"> == </span>-<span class="hljs-number">1</span>) exit<span class="hljs-number">(-1)</span>;<span class="hljs-comment">//未找到数字，序列错误</span>            <span class="hljs-comment">//缩小节点的范围，仅限s的左子树，注意下标和个数的变化</span>            s-&gt;left = <span class="hljs-constructor">ConstructBinaryTree(<span class="hljs-params">itp</span> + 1, <span class="hljs-params">itv</span>, <span class="hljs-params">index</span>)</span>;            <span class="hljs-comment">//缩小节点的范围，仅限s的右子树</span>            s-&gt;right = <span class="hljs-constructor">ConstructBinaryTree(<span class="hljs-params">itp</span> + <span class="hljs-params">index</span> + 1, <span class="hljs-params">itv</span> + <span class="hljs-params">index</span> + 1, <span class="hljs-params">n</span> - <span class="hljs-params">index</span> - 1)</span>;        &#125;        return s;    &#125;    <span class="hljs-built_in">int</span> <span class="hljs-constructor">FindIndex(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;::<span class="hljs-params">iterator</span> <span class="hljs-params">itv</span>, <span class="hljs-params">int</span> <span class="hljs-params">n</span>, <span class="hljs-params">int</span> <span class="hljs-params">x</span>)</span>    &#123;        for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i, ++itv)        &#123;            <span class="hljs-keyword">if</span> (*itv<span class="hljs-operator"> == </span>x) return i;        &#125;        return -<span class="hljs-number">1</span>;<span class="hljs-comment">//未找到返回-1</span>    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（3）从尾到头打印链表</title>
    <link href="/2020/06/28/print-a-linked-list-from-end-to-end/"/>
    <url>/2020/06/28/print-a-linked-list-from-end-to-end/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>输入一个链表，从尾到头打印链表每个节点的值。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs reasonml"><span class="hljs-comment">//可以使用stack的先进后出，也可以使用递归，因为已给定函数所以使用递归</span><span class="hljs-comment">//本题的在线测试用例是无头链表→_→</span><span class="hljs-comment">/*节点结构体</span><span class="hljs-comment">struct ListNode </span><span class="hljs-comment">&#123;</span><span class="hljs-comment">int val;</span><span class="hljs-comment">    struct ListNode *next;</span><span class="hljs-comment">    ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-keyword">class</span> Solution&#123;public:vector&lt;<span class="hljs-built_in">int</span>&gt; print<span class="hljs-constructor">ListFromTailToHead(ListNode<span class="hljs-operator">*</span> <span class="hljs-params">head</span>)</span>&#123;vector&lt;<span class="hljs-built_in">int</span>&gt; v;<span class="hljs-comment">//判断是否为空，不为空调用递归函数</span><span class="hljs-keyword">if</span> (head != NULL) <span class="hljs-constructor">ListFromTailToHead(<span class="hljs-params">head</span>, <span class="hljs-params">v</span>)</span>;return v;&#125;<span class="hljs-comment">//递归函数传参为指向当前结点的指针和存储value的vector引用，因为vector需要共同使用</span>void <span class="hljs-constructor">ListFromTailToHead(ListNode <span class="hljs-operator">*</span><span class="hljs-params">p</span>, <span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt; &amp;<span class="hljs-params">vec</span>)</span>&#123;<span class="hljs-comment">//当前指针不为空时说明节点存在</span><span class="hljs-keyword">if</span> (p != NULL)&#123;<span class="hljs-constructor">ListFromTailToHead(<span class="hljs-params">p</span>-&gt;<span class="hljs-params">next</span>, <span class="hljs-params">vec</span>)</span>;<span class="hljs-comment">//先递归后压value</span>vec.push<span class="hljs-constructor">_back(<span class="hljs-params">p</span>-&gt;<span class="hljs-params">val</span>)</span>;&#125;&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（2）替换空格</title>
    <link href="/2020/06/27/replace-spaces/"/>
    <url>/2020/06/27/replace-spaces/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。在此字符串上完成替换，空间保证足够。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs hsp"><span class="hljs-comment">//"We Are Happy"</span><span class="hljs-comment">//" helloworld"</span><span class="hljs-comment">//""</span><span class="hljs-comment">//"  "</span>class Solution &#123;public:void replaceSpace(char *<span class="hljs-keyword">str</span>, <span class="hljs-keyword">int</span> <span class="hljs-keyword">length</span>) &#123;<span class="hljs-comment">//判断异常情况</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">str</span> == NULL || *<span class="hljs-keyword">str</span> == NULL || <span class="hljs-keyword">length</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span><span class="hljs-comment">;</span><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span><span class="hljs-comment">;</span><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span><span class="hljs-comment">;</span><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-keyword">length</span>)<span class="hljs-comment">//遍历统计' '个数</span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">str</span>[i] == <span class="hljs-string">' '</span>) ++num<span class="hljs-comment">;</span>++i<span class="hljs-comment">;</span>&#125;i = <span class="hljs-keyword">length</span> - <span class="hljs-number">1</span><span class="hljs-comment">;//将i移动到str最后一个字符位置</span><span class="hljs-keyword">length</span> = <span class="hljs-keyword">length</span> + num * <span class="hljs-number">2</span> - <span class="hljs-number">1</span><span class="hljs-comment">;//将length移动到替换后最后一个字符位置</span><span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">str</span>[i] != <span class="hljs-string">' '</span>)<span class="hljs-comment">//非' '时正常移动</span>&#123;<span class="hljs-keyword">str</span>[<span class="hljs-keyword">length</span>] = <span class="hljs-keyword">str</span>[i]<span class="hljs-comment">;</span>--<span class="hljs-keyword">length</span><span class="hljs-comment">;</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">length</span> -= <span class="hljs-number">3</span><span class="hljs-comment">;//否则将length先前移动三个字节完成替换</span><span class="hljs-keyword">str</span>[<span class="hljs-keyword">length</span> + <span class="hljs-number">1</span>] = <span class="hljs-string">'%'</span><span class="hljs-comment">;</span><span class="hljs-keyword">str</span>[<span class="hljs-keyword">length</span> + <span class="hljs-number">2</span>] = <span class="hljs-string">'2'</span><span class="hljs-comment">;</span><span class="hljs-keyword">str</span>[<span class="hljs-keyword">length</span> + <span class="hljs-number">3</span>] = <span class="hljs-string">'0'</span><span class="hljs-comment">;</span>&#125;--i<span class="hljs-comment">;</span>&#125;&#125;&#125;<span class="hljs-comment">;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer——（1）二维数组中的查找</title>
    <link href="/2020/06/27/find-in-a-two-dimensional-array/"/>
    <url>/2020/06/27/find-in-a-two-dimensional-array/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><blockquote><p><strong>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</strong></p></blockquote><p><strong>实现如下：</strong></p><pre><code class="hljs angelscript"><span class="hljs-comment">/*</span><span class="hljs-comment">1 2 8  9</span><span class="hljs-comment">2 4 9  12</span><span class="hljs-comment">4 7 10 13</span><span class="hljs-comment">6 8 11 15</span><span class="hljs-comment">*/</span><span class="hljs-comment">//从右上角或左下角突破，时间复杂度O(n)</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">bool</span> Find(<span class="hljs-built_in">int</span> target, vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; <span class="hljs-built_in">array</span>)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>.empty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//为空结束</span><span class="hljs-comment">//获取行、列数</span><span class="hljs-built_in">int</span> row = <span class="hljs-built_in">array</span>.size();<span class="hljs-built_in">int</span> col = <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>].size()；<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> j = col - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> ((i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; row) &amp;&amp; (j &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; col))<span class="hljs-comment">//防止越界</span>&#123;<span class="hljs-comment">//说明array[i][y]此行右边和此列下方的数都大于target</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i][j] &gt; target)--j;<span class="hljs-comment">//找到返回true</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i][j] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//说明array[i][j]此行左边的数和此列上方的数都小于target</span><span class="hljs-keyword">else</span>++i;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//没找到返回false</span>&#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指Offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节序</title>
    <link href="/2020/06/27/endianness/"/>
    <url>/2020/06/27/endianness/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>字节序是何物。。。？</em> *</strong></p><blockquote><p><strong>小人国的内战源于吃水煮鸡蛋时究竟是从大头敲开还是从小头敲开，因此曾发生过6次叛乱，其中一个皇帝送了命，另一个丢了王位。</strong></p></blockquote><p>不同的计算机体系结构中，可能采用不同的存储和传输机制，通常采用的<strong>字节存储机制</strong>主要有两种：<strong>大端（Big-endian）</strong>和<strong>小端（Little-endian）</strong>。</p><ul><li><p><strong>最重要的位或最重要的字节（MSB，Most Significant Bit/Byte）</strong>，表明在一个bit序列或一个byte序列中对整个序列取值影响最大的那个bit/byte。</p></li><li><p><strong>最不重要的位或最不重要的字节（LSB，Least Significant Bit/Byte）</strong>，表明在一个bit序列或一个byte序列中对整个序列取值影响最小的那个bit/byte。</p></li></ul><p>Big-endian规定<strong>MSB在存储时放在低地址，在传输时MSB放在流的开始</strong>。<strong>LSB存储时放在高地址，在传输时放在流的末尾</strong>。目前的PowerPC系列处理器、<strong>TCP/IP网络</strong>及<strong>Java虚拟机</strong>的字节序为Big-endian。<br>Little-endian规定与之相反。目前的Intel的<strong>x86系列</strong>及衍生CPU的字节序为Little-endian。</p><pre><code class="hljs cpp"><span class="hljs-comment">//判断机器采用何种存储机制</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> i = <span class="hljs-number">0x12345678</span>;<span class="hljs-keyword">if</span> (<span class="hljs-number">0x78</span> == (<span class="hljs-keyword">char</span>)i)<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Little-endian"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Big-endian"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDI3MTkxNjA4OTUy?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="监视"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDI3MTkxNjQxNDM3?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="内存"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDI3MTkxNzA0OTYz?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="Little-endian"></p><p><strong>* <em>鉴定完毕。。。牙膏厂果然是Little-endian。。。</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——目标文件（3）</title>
    <link href="/2020/06/27/object-file-3/"/>
    <url>/2020/06/27/object-file-3/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>总结的速度，追不上看书的速度了。。。</em> *</strong></p><h1 id="第三章-目标文件里面有什么"><a href="#第三章-目标文件里面有什么" class="headerlink" title="第三章 目标文件里面有什么"></a>第三章 目标文件里面有什么</h1><blockquote><p><strong>ELF文件的基本结构是什么样子？</strong></p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDI2MTg0NTQzNzgx?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="图3.6 ELF文件结构"></p><p>ELF目标文件的最前部是ELF <strong>文件头（ELF Header）</strong>，其包含<strong>描述整个文件的基本属性</strong>，如ELF文件版本、目标机器型号、程序入口地址等。接着是各段。之后为<strong>段表（Section Header Table）</strong>，该表<strong>描述了ELF文件包含的所有段的信息</strong>，如短的段名、段的长度、在文件中的偏移、读写权限及段的其他属性。</p><ol><li><p>ELF文件头中定义了<strong>ELF魔数</strong>、<strong>文件机器字节长度</strong>、<strong>数据存储方式</strong>、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、<strong>入口地址</strong>、<strong>程序头入口和长度</strong>、<strong>段表的位置和长度及段的数量</strong>。ELF文件头结构及相关常数被定义在“<strong>/usr/include/elf.h</strong>”。</p><pre><code class="hljs cpp"><span class="hljs-comment">//32位文件结构头</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> e_ident[<span class="hljs-number">16</span>];<span class="hljs-comment">//魔数</span> ELF32_Half e_type;<span class="hljs-comment">//文件类型</span> ELF32_Half e_machine;<span class="hljs-comment">//平台属性</span> ELF32_Word e_version;<span class="hljs-comment">//版本号</span> ELF32_Addr e_entry;<span class="hljs-comment">//入口虚拟地址</span> ELF32_Off e_phoff; ELF32_Off e_shoff;<span class="hljs-comment">//段表在文件中的偏移</span> ELF32_Word e_flags; ELF32_Half e_ehsize; ELF32_Half e_phentsize; ELF32_Half e_phnum; ELF32_Half e_shentsize;<span class="hljs-comment">//段表描述符大小，一般为sizeof(Elf32_Shdr)</span> ELF32_Half e_shnum;<span class="hljs-comment">//段描述符数量，等于文件中拥有段的数量</span> <span class="hljs-comment">//Seciton header sting table index</span> ELF32_Half e_shstrndx;<span class="hljs-comment">//段表字符串表所在的段在段表中的下标</span>&#125;ELF32_Ehdr;</code></pre></li></ol><ul><li>ELF文件头最前面的“<strong>Magic</strong>”的16个字节对应“ELF32_Ehdr“的e_ident成员，用来标识ELF文件的平台属性。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDI3MTE0MDU2NzUy?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="ELF魔数"></li><li>前四个字节为ELF文件<strong>统一标识码</strong>，为0x7F、0x45、0x4c、0x46.分别对应ASCII字符中的DEL控制符、E、L、F。第五个字节用来标识<strong>ELF文件类</strong>。第六个字节规定ELF文件<strong>大小端</strong>。第七个字节规定ELF文件主版本号。后九个未定义，填0。</li></ul><ol start="2"><li><p><strong>段表（Section Header Table）</strong>保存着段的基本属性的结构，它描述了各段的信息，如段的段名、段的长度、在文件中的偏、读写权限及段的其他属性。<strong>段结构由段表决定，编译器、连接器依靠段表定位和访问各段的属性。段表的位置由文件头的”e_shoff“决定。</strong></p><pre><code class="hljs cpp"><span class="hljs-comment">//段描述符结构</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span><span class="hljs-comment">//段名是一个字符串，位于.shstrtab字符串表。sh_name是段名字符串在.shstrtab中的偏移</span>Elf32_Word sh_name;Elf32_Word sh_type;<span class="hljs-comment">//段的类型</span>Elf32_Word sh_flags;<span class="hljs-comment">//段的标志位</span><span class="hljs-comment">//段虚拟地址，若该段可以被加载则sh_addr为该段被加载后在进程地址空间中的虚拟的地址；否则为0</span>Elf32_Addr sh_addr;<span class="hljs-comment">//段偏移，如果该段存在于文件中，则表示该段在文件中的偏移，否则无意义如.bss段</span>Elf32_Off sh_offset;Elf32_Word sh_size;<span class="hljs-comment">//段的长度</span>Elf32_Word sh_link;<span class="hljs-comment">//段链接信息</span>Elf32_Word sh_info;<span class="hljs-comment">//段链接信息</span><span class="hljs-comment">//段地址对齐，地址对齐的数量都是2的指数倍，sh_addralign表示地址对齐数量中的指数</span>Elf32_Word sh_addralign;<span class="hljs-comment">//项的长度，有些段包含固定大小的项，如符号表所包含的每个符号大小一样；若不包含固定大小的项，则为0</span>Elf32_Word sh_entsize;&#125;Elf32_Shdr;</code></pre><ul><li>段表是一个以”<strong>Elf32_Shdr</strong>“ ——<strong>段描述符（Section Description）</strong>结构体为元素的<strong>数组</strong>。<strong>数组元素的个数等于段的个数</strong>，每个”Elf32_Shdr“结构体对应一个段。<strong>ELF段表的数组的第一个元素是无效的段描述符，其类型为NULL。</strong>Elf32_Shdr被定义在”/usr/include/elf.h“中</li></ul><p>更复杂的ELF文件结构：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDI3MTQ1MTQwOTg0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="更复杂的ELF文件结构">    </p></li><li><p><strong>重定位表（Relocation Table）</strong>，类型（sh_type）为”<strong>SHT_REL</strong>“。链接器在处理目标文件时，须要对目标文件中的某些部位进行重定位，即代码段和数据段中对绝对地址引用的位置<strong>。重定位信息都记录在重定位表中，每个须要重定位的段都会有一个相应的重定位表。</strong>一个重定位表同时也是ELF的一个段。</p></li><li><p>因为字符串的长度是不固定的，所以常见的表示方法是<strong>把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串</strong>。在ELF文件中<strong>引用字符串只须给出一个数字下标即可，不用考虑字符串长度的问题</strong>。<br>一般字符串表在ELF文件中以段的形式保存，常见段<strong>字符串表（String Table）”.strtab“</strong>和<strong>段表字符串表（Section Header String Table）”.shstrtab“</strong>。字符串表保存<strong>普通的字符串</strong>，如<strong>符号的名字</strong>；段表字符串表保存<strong>段表中用到的字符串</strong>，如<strong>段名（sh_name）</strong>。</p></li></ol><blockquote><p><strong>分析ELF文件头，得到段表和段表字符串表的位置，继而解析整个ELF文件</strong></p></blockquote><p><strong>* <em>下次就是静态链接了。。。Link！</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——目标文件（2）</title>
    <link href="/2020/06/27/object-file-2/"/>
    <url>/2020/06/27/object-file-2/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>逐个分析各段。。。</em> *</strong></p><h1 id="第三章-目标文件里面有什么"><a href="#第三章-目标文件里面有什么" class="headerlink" title="第三章 目标文件里面有什么"></a>第三章 目标文件里面有什么</h1><blockquote><p><strong>真正了不起的程序员对自己的程序的每一个字节都了如指掌。</strong> </p></blockquote><pre><code class="hljs cpp"><span class="hljs-comment">//Test.c</span><span class="hljs-keyword">int</span> global_init_var = <span class="hljs-number">84</span>;<span class="hljs-keyword">int</span> global_uninit_var;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, i);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> static_var = <span class="hljs-number">85</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> static_var2;<span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> bfunc1(static_var + static_var2 + a + b);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>示例程序中包括代码段、数据段、BSS段、只读数据段（.rodata）、注释信息段（.comment）。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDI2MTUwMzA1NzAw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="图3.4 目标文件组成"></p><ol><li><p><strong>代码段</strong>：</p><ul><li><strong>.text</strong>段中存放的是Test.c中函数func()和main()的<strong>指令</strong>。</li></ul></li><li><p><strong>数据段</strong>和<strong>只读数据段</strong>：</p><ul><li><strong>.data</strong>段保存<strong>初始化了的全局变量和局部静态变量</strong>（上述代码中的global_init_var和static_var）。</li></ul></li></ol><ul><li><p><strong>.rodata</strong>段存放<strong>只读数据</strong>，一般是程序的<strong>只读变量（const修饰的变量）</strong>和<strong>字符串常量</strong>（上述代码中”<strong>%d\n</strong>“是一种只读数据）。单独设立.rodata段从<strong>语义上支持C++的const关键字</strong>，也在加载时<strong>将属性映射成只读</strong>，保证安全性。有时编译器会把字符串常量放到.data段，而不会单独放在.rodata段。</p><ol start="3"><li><strong>BSS段</strong>：</li></ol></li><li><p><strong>.bss</strong>段中存放的是<strong>未初始化的全局变量和局部静态变量</strong>（上述代码中的global_uninit_var和static_var2），准确的说是.bss段为他们<strong>预留了空间</strong>。</p></li><li><p>有些编译器将未初始化的全局变量存放在目标文件.bss段，有些不存放只是<strong>预留一个未定义的全局变量符号”COMMON 符号“，到最终链接成可执行文件的时候再在.bss段·分配空间。</strong></p></li><li><p>但编译单元<strong>内部可见的静态变量</strong>（如·global_uninit_var加上static修饰），是存放在.bss段。</p></li><li><p><strong><code>static int x1 = 0;</code></strong></p></li></ul><p><strong>x1被放在.bss段，因为可以认为是未初始化的，所以被优化放在.bss段。</strong></p><ul><li><strong><code>static int x2 = 1;</code></strong></li></ul><p><strong>x2被放在.data段，因为初始化值为1，所以放在.data段。</strong></p><ol start="4"><li><p>其他段：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDI2MTgwNzEzMzI0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="图3.5 其他段"></p></li><li><p>自定义段：</p><ul><li><strong><code>_attribute_((section(&quot;FOO&quot;))) int global = 42;</code></strong></li></ul></li></ol><ul><li><strong><code>_attribute_((section(&quot;BAR&quot;))) void foo()</code></strong><br>在全局变量和函数之前加上<code>_attribute_((section(&quot;name&quot;)))</code>属性可以把相应的变量或函数放到以”name“作为的段中。</li></ul><p><strong>* <em>以上为主要段，下一次总结ELF文件结构，包括文件头、段表。。。</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——目标文件（1）</title>
    <link href="/2020/06/27/object-file-1/"/>
    <url>/2020/06/27/object-file-1/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>一直被催更。。。</em> *</strong></p><h1 id="第三章-目标文件里面有什么"><a href="#第三章-目标文件里面有什么" class="headerlink" title="第三章 目标文件里面有什么"></a>第三章 目标文件里面有什么</h1><blockquote><p>PC平台流行的<strong>可执行文件格式（Executable）</strong>主要为Windows下的<strong>PE（Portable</strong><br><strong>Executable）</strong>和Linux下的<strong>ELF（Executable Linkable</strong><br><strong>Format）</strong>，都是<strong>COFF（Common file format）</strong>格式的变种。</p></blockquote><p>编译器编译源代码后生成的目标文件，其结构已经是编译后的可执行文件格式，但还没有经过链接，有些符号或地址还未调整，所以一般跟可执行文件采用相同格式存储。<strong>在Windows下将它们统称为PE-COFF文件格式，在Linux下将它们统称为ELF文件。</strong></p><p> <strong>动态链接库（DLL，Dynamic Linking Library）</strong>（<strong>Windows的.dll和Linux的.so</strong>）、<strong>静态链接库（Static Linking Library）</strong>（<strong>Windows的.lib和Linux的.a</strong>）都按照可执行文件格式存储。<strong>静态链接库是把很多目标文件捆绑在一起形成一个文件再加上索引，简单理解为一个包含很多目标文件的文件包。</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDEyMTcxNTUxOTA0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="图3.1 ELF格式文件（1）"><br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDEyMTcxNjE0NjI0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="图3.2 ELF格式文件（2）"></p><p>1.目标文件文件中至少包含编译后的机器指令代码、数据、链接时所需信息（如符号表、调试信息、 字符串等）。一般目标文件将这些信息按不同属性以“<strong>节</strong>”<strong>（Section）</strong>的形式存储，有时也叫<strong>段（Segment）</strong>（其实这两个是不同的角度的定义，看到后面时才理解），<strong>一般情况下他们都表示一个一定长度的区域。</strong></p><ul><li><p>程序源代码编译后的<strong>机器指令</strong>保存在<strong>代码段（Code Section，常见名字.code或.text）</strong></p></li><li><p><strong>初始化的全局变量</strong>和<strong>局部静态变量</strong>保存在<strong>数据段（Data Section，常见名字.data）</strong></p></li><li><p><strong>未初始化的全局变量</strong>和<strong>局部静态变量</strong>保存在<strong>.bss section</strong></p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDEyMTczMjM4ODE4?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="图3.3 程序与目标文件"></p></li><li><p><strong>ELF文件的文件头描述了整个文件的属性</strong>，包括文件是否可执行、是静态链接还是动态链接及入口地址、目标硬件、目标操作系统等信息。文件头还包含一个<strong>段表（Section Table），段表是一个描述文件各段的数组，具有每个段的信息（各段在文件中的偏移位置和段的属性等）。</strong></p></li><li><p>未初始化的全局变量和局部静态变量<strong>默认值都为0</strong>，本可以存放在.data段，但是在.data存放数据0没有必要。程序运行时他们的确占内存空间，并且可执行文件必须记录它们的大小总和，为其预留位置，记为.bss段。但<strong>.bss段没有内容，在文件中不占空间（better save space）。</strong></p></li></ul><p>2.程序源代码被编译后主要分为两种段：<strong>程序指令</strong>和<strong>程序数据</strong>。区分好处如下：</p><ul><li><p>程序被装载后，数据和指令被分别映射到<strong>两个虚存空间</strong>，将其<strong>权限</strong>分别设置为<strong>可读写</strong>和<strong>只读</strong>。<strong>防止程序的指令被改写。</strong></p></li><li><p><strong>指令和数据分离有利于提高程序的局部性。</strong>现代计算机的CPU缓存一般都被设计成数据缓存和指令缓存分离，所以两者分离存放<strong>对CPU缓存命中率提高有好处。</strong></p></li><li><p>当系统中运行同一个程序的多个副本时，其指令都是一样的，所以内存中只须保存一份该程序的指令部分。<strong>共享指令可以大量节省内存</strong>，对其他的只读数据同理。</p></li></ul><p><strong>* <em>先大概了解目标文件里面有什么，下次再逐个深入。。。</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——编译与链接</title>
    <link href="/2020/06/27/compile-and-link/"/>
    <url>/2020/06/27/compile-and-link/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>从第二章开始不再按照目录的顺序总结，而是将大块知识点总结在一起。。。</em> *</strong></p><h1 id="第二章-编译和链接"><a href="#第二章-编译和链接" class="headerlink" title="第二章 编译和链接"></a><strong>第二章 编译和链接</strong></h1><blockquote><p><strong>集成开发环境（IDE）</strong>一般都将编译和链接的过程一步完成，此过程成为构建（Bulid）。但其掩盖了系统软件运行机制。</p></blockquote><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$gcc</span> hello.c</span><span class="hljs-symbol">$</span>./a.out</code></pre><p>一个<strong>可执行文件的生成</strong>，可以分解成4个步骤：<strong>预处理（Prepressing）</strong>、<strong>编译（Compilation）</strong>、<strong>汇编（Assembly）</strong>和<strong>链接（Linking）</strong>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzIyMjA1MzA4MTUy?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="GCC编译过程分解"></p><p>1.<strong>预编译</strong>：C程序源代码文件和相关头文件被预编译器cpp预编译成 .i 文件。C++程序被预编译后的文件拓展名为 .ii 。</p><pre><code class="hljs stylus"><span class="hljs-comment">/* -E表示只进行预编译 */</span><span class="hljs-variable">$gcc</span> -E hello<span class="hljs-selector-class">.c</span> -o hello<span class="hljs-selector-class">.i</span> 或 <span class="hljs-variable">$cpp</span> hello<span class="hljs-selector-class">.c</span> &gt; hello.i</code></pre><p><strong>预编译过程主要处理源代码文件中以“#”开始的预编译指令。</strong></p><ul><li><p>将所有的“#define”删除，并展开所有宏定义</p></li><li><p>处理所有条件预编译指令，如“#if”、“#ifdef”、“#elif”、“#else”、“#endif”</p></li><li><p>处理“#include”预编译指令，将包含的文件插入到该预编译指令的位置。此过程是递归的。</p></li><li><p>删除所有的注释“//”和“/**/”</p></li><li><p>添加行号和文件标识，以便于编译时器编译器产生调试用的行号信息及编译时产生错误或警告的时显示行号</p></li><li><p>保留所有#pragma编译器指令，因为编译器需要使用它们</p></li></ul><p>2.<strong>编译</strong>：把预处理完的文件进行一系列<strong>词法分析</strong>、<strong>语法分析</strong>、<strong>语义分析</strong>及<strong>优化后生成相应的汇编代码文件</strong>。</p><pre><code class="hljs stylus"><span class="hljs-comment">/* -S表示只进行编译 */</span><span class="hljs-variable">$gcc</span> -S hello<span class="hljs-selector-class">.i</span> -o hello<span class="hljs-selector-class">.s</span> 或 <span class="hljs-variable">$gcc</span> -S hello<span class="hljs-selector-class">.c</span> -o hello.s</code></pre><p>现在版本的GCC将<strong>预编译和编译两个步骤合并在一个步骤中，由编译器完成</strong>。对于C语言代码使用cc1程序、C++语言使用cc1plus、Objective-C语言使用cc1obj、fortran语言使用f771、Java语言使用jc1。</p><blockquote><p><strong>实际上gcc命令只是后台程序的包装，其根据不同的参数调用预编译器cc1、汇编器as、链接器ld。</strong></p></blockquote><p><strong>编译器是将高级语言翻译成机器语言的一个工具</strong>，其编译过程一般分为6步：<strong>扫描</strong>、<strong>语法分析</strong>、<strong>语义分析</strong>、<strong>源代码优化</strong>、<strong>代码生成</strong>和<strong>目标代码优化</strong>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzIyMjEzMjE1MDMw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="编译过程"></p><ul><li><strong>语法分析</strong>：源代码程序被输入到<strong>扫描机（Scanner）</strong>，运用一种类似于<strong>有限状态机（Finite State Machine）</strong>的算法，将源代码的字符序列分割成一系列<strong>记号（Token）</strong>。<br>词法分析产生的记号一般分为：关键字、标识符、字符量（包含数字、字符串等）和特殊符号（如加号、等号）。此过程中，扫描器也将标识符存放到符号表，将数字、字符串常量存放到文字表。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzIyMjE0NTI4Nzcx?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="语法树"></li></ul><p> <strong>符号和数字是最小的表达式，它们不再由表达式来组成，它们通常作为整个语法树的叶节点。</strong>语法分析的同时运算符号的优先级和含义也被确定下来。如果出现了表达式不合法，比如括号不匹配、表达式中缺少操作符等，编译器会报告语法分析阶段的错误。</p><ul><li><p><strong>语义分析</strong>：<strong>语义分析器（Semantic Analyzer）</strong>判断语句是否正真的有意义。编译器能分析的是<strong>静态语义（Static Semantic）</strong>，是在<strong>编译期可以确定的</strong>语义，通常包括声明、类型的匹配、类型的转换。而<strong>动态语义（Dynamic Semantic）</strong>只有在运行期才能确定，比如0作为除数。<br>语义分析后，<strong>语法树的标识符都标识了类型</strong>，若有类型的隐式转换，语义分析器会在语法树中插入相应的转换结点。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzIzMjMyNDI5NzQ0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="这里写图片描述"></p></li><li><p><strong>中间语言生成</strong>：<strong>源代码优化器（Source Code Optimizer）</strong>在源代码级别进行优化。源代码优化器往往将整个语法树转换成<strong>中间代码（Intermediate Code）</strong>，它是<strong>语法树的顺序表示</strong>。<br>它与目标代码非常接近，但<strong>其跟目标机器和运行环境无关</strong>，<strong>不包含数据的大小</strong>、<strong>变量地址</strong>、<strong>寄存器名</strong>等。中间代码常见类型有：<strong>三地址码（Three-address Code）</strong>和<strong>P-代码（P-Code）</strong>。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI2MjAxNTUwMTk5?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="优化后的语法树"><br>上图语法树翻译成三地址码为：</p><pre><code class="hljs mipsasm"><span class="hljs-built_in">t1</span> = <span class="hljs-number">2</span> + <span class="hljs-number">6</span><span class="hljs-built_in">t2</span> = index + <span class="hljs-number">4</span><span class="hljs-built_in">t3</span> = <span class="hljs-built_in">t2</span> * <span class="hljs-built_in">t3</span>array[index] = <span class="hljs-built_in">t3</span><span class="hljs-comment">/*继续优化*/</span><span class="hljs-built_in">t2</span> = index + <span class="hljs-number">4</span><span class="hljs-built_in">t2</span> = <span class="hljs-built_in">t2</span> * <span class="hljs-number">8</span></code></pre><p><strong>中间代码使编译器分成前端和后端。编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。</strong></p></li><li><p><strong>目标代码优化与生成</strong>：编译器后端主要包括<strong>代码生成器（Code Generator）</strong>和<strong>目标代码优化器（Target Code Optimizer）</strong>。<br><strong>代码生成器将中间代码转换成目标机器代码，目标代码优化器对目标代码进行优化</strong>，比如选择合适的寻址方式、使用位移代替乘法运算、删除多余指令等。</p></li></ul><p>3.<strong>汇编</strong>：汇编器将<strong>汇编代码转化成机器可以执行的指令</strong>，每一个汇编语句几乎都对应一条机器指令。根据<strong>汇编指令和机器指令的对照表</strong>一一翻译。</p><pre><code class="hljs stylus"><span class="hljs-variable">$as</span> hello<span class="hljs-selector-class">.s</span> -o hello<span class="hljs-selector-class">.o</span> 或 <span class="hljs-variable">$gcc</span> -c hello<span class="hljs-selector-class">.s</span> -o hello<span class="hljs-selector-class">.o</span> 或 <span class="hljs-variable">$gcc</span> -c hello<span class="hljs-selector-class">.c</span> -o hello.o</code></pre><p>4.<strong>链接</strong>：重新计算各个目标地址的过程叫做<strong>重定位（Relocation）</strong>。<strong>符号（Symbol）</strong>用来表示一个地址，这个地址可能是函数或变量的起始地址。汇编器在每次汇编程序的时候重新计算符号的地址，把所有引用该符号的指令修正到这个正确的地址。</p><p>一个程序被分割成多个模块之后，模块之间的通信方式有<strong>模块间的函数调用</strong>和<strong>模块间的变量访问</strong>两种方式，归结为模块间符号的引用。</p><blockquote><p><strong>定义符号的模块多出一块区域，引用该符号的模块刚好少了那一块区域。两者的拼接过程即链接（Linking）。</strong></p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI2MjEyOTE5MTUw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="模块间拼接"></p><ul><li>模块拼接——<strong>静态链接</strong></li></ul><blockquote><p><strong>将每个源代码模块独立地编译，然后按照需要将它们组装起来，这个组装模块的过程就是链接（Linking）。</strong></p></blockquote><p>链接过程主要包括<strong>地址和空间分配（Address and Storage Allocation）</strong>、<strong>符号决议（Symbol Resolution）</strong>和<strong>重定位（Relocation）</strong>等。每个模块的源代码文件经过编译器编译成<strong>目标文件（Object File，一般拓展名为.o或.obj）</strong>，<strong>目标文件和库（Library）一起链接形成最终可执行文件</strong>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzI2MjEzODMzNzcy?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="连接过程"></p><p>每个模块都是单独编译，编译器编译a.c时并不知道引用的函数的地址，所以暂时把调用该函数的目标地址搁置，等待最后链接时由链接器将这些指令的目标地址修正。<strong>链接器在链接时根据所引用的符号，自动去相应的模块查找该符号的地址，然后将a.c模块中所有引用到该符号的指令重新修正，让其目标地址为真正的符号的地址。</strong><br>地址修正的过程叫做<strong>重定位（Relocation）</strong>，每个要被修正的地方叫一个<strong>重定位入口（Relacation Entry）。</strong></p><p><strong>* <em>下次想总结一下UDP/TCP相关。。。</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——进程与线程</title>
    <link href="/2020/06/27/processes-and-threads/"/>
    <url>/2020/06/27/processes-and-threads/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>第一章最后一部分，part.3。。。</em> *</strong></p><h1 id="第一章-温故而知新"><a href="#第一章-温故而知新" class="headerlink" title="第一章 温故而知新"></a><strong>第一章 温故而知新</strong></h1><h2 id="1-6-众人拾柴火焰高"><a href="#1-6-众人拾柴火焰高" class="headerlink" title="1.6 众人拾柴火焰高"></a><strong>1.6 众人拾柴火焰高</strong></h2><h3 id="1-6-1-线程基础"><a href="#1-6-1-线程基础" class="headerlink" title="1.6.1 线程基础"></a><strong>1.6.1 线程基础</strong></h3><p>1.<strong>线程（Thread）</strong>，也称<strong>轻量级进程（Lightweight Process，LWP）</strong>，是<strong>程序执行流的最小单元</strong>。一个标准线程由线程ID，当前指令指针（PC），寄存器集合和堆栈组成。进程由一个或多个线程组成，各线程之间共享（全局变量）代码段、数据段、堆、打开文件描述符、信号等。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE5MTM0MDM3Mzg5?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="进程内的线程"></p><p>2.线程拥有的私有空间</p><ul><li><p><strong>线程栈</strong></p></li><li><p><strong>线程局部存储（Thread Local Storage，TLS）</strong>，某些操作系统为线程单独提供有限容量的私有空间。</p></li><li><p><strong>寄存器（包括PC寄存器）</strong>，是执行流的的基本数据，为线程私有。</p></li></ul><table><thead><tr><th>线程私有</th><th>线程共享（进程所有）</th></tr></thead><tbody><tr><td>局部变量</td><td>全局变量</td></tr><tr><td>函数的参数</td><td>堆数据</td></tr><tr><td>TLS数据</td><td>函数中的静态变量</td></tr><tr><td></td><td>程序代码</td></tr><tr><td></td><td>打开的文件，A线程打开的文件，B线程可以读写</td></tr></tbody></table><p>3.当线程数量小于等于处理器数量时，才是真正的线程并发，不同线程运行在不同的处理器上。当单处理器对应多线程时，并发是模拟出来的状态，操作系统让多线程程序轮流执行。一个不断在处理器上切换不同状态的线程的行为成为<strong>线程调度（Thread Schedule）</strong>。</p><ul><li><p><strong>运行（Running）</strong>：此时线程正在执行。</p></li><li><p><strong>就绪（Ready）</strong>：此时线程可以立刻运行，但CPU已被占用。</p></li><li><p><strong>等待（Waiting）</strong>：此时线程正在等待某一事件（比如I/O或同步）发生，无法执行。</p></li></ul><p>处于运行中的线程拥有一段可以执行的时间，这段时间被称为<strong>时间片（Time Slice）</strong>。</p><ul><li><p><strong>如果时间片用尽时，该线程进入就绪状态。</strong></p></li><li><p><strong>如果在时间片用尽之前线程就开始等待某事件，该线程进入等待状态。</strong></p></li><li><p><strong>当一个线程离开运行状态时，调度系统选择一个就绪线程继续执行。</strong></p></li><li><p><strong>当处于等待状态的线程所等待的事件发生后，该线程进入就绪状态。</strong></p></li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE5MTQzOTEzODY0?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="线程状态切换"></p><p>4.线程调度的方法中都带有<strong>优先级调度（Priority Schedule）</strong>和<strong>轮转法（Round Robin）</strong>的痕迹。</p><ul><li><p>轮转法：各个线程轮流执行一小段时间。</p></li><li><p>优先级调度：线程拥有各自的<strong>线程优先级（Thread Priority）</strong>线程按照优先级顺序轮流执行。</p></li></ul><blockquote><p> CPU也喜欢先捏软柿子。</p></blockquote><p>系统会根据线程的表现自动调整优先级。频繁地进入等待状态（会放弃之后剩余的可占用时间份额）的线程（例如处理I/O的线程）称为<strong>IO密集型线程（IO Bound Thread）</strong>；频繁地进行大量运算，以至于每次都把时间片全部用尽的线程称为<strong>CPU密集型线程（CPU Bound Thread）</strong>。<strong>IO密集型线程总比CPU密集型线程容易得到优先级提升。</strong></p><p>5.<strong>饿死（Starvation）</strong>现象：一个线程优先级较低，在它执行之前总是有优先级较高的线程要执行，因此这个低优先级线程始终无法执行。为了避免饿死现象，<strong>调度系统常常会逐步提升等待了过长时间得不到执行的线程的优先级</strong>。</p><p>改变线程优先级一般的三种方式：</p><ul><li><p>用户指定优先级</p></li><li><p>根据进入等待状态的频繁程度而提升或降低优先级</p></li><li><p>长时间得不到执行而被提升优先级</p></li></ul><p>6.线程在用尽时间片之后会被强制剥夺继续执行的权利，进入就绪状态，这个过程叫做<strong>抢占（Preemption）</strong>，即之后执行的别的线程抢占了当前线程。早期系统中线程是不可抢占的。线程必须手动发出放弃执行的命令，才能让其他线程得到执行。此时线程是主动进入就绪状态的，而不是靠时间片用尽被强制进入。若线程始终拒绝进入就绪状态也不进行等待，那么其他线程将永远无法执行。但此时线程调度的时机是确定的。</p><p>在不可抢占线程中，线程主动放弃执行的情况：</p><ul><li><p>党线程试图等待某事件时（I/O等）</p></li><li><p>线程主动放弃时间片</p></li></ul><p>7.Linux内核中并不存在正真意义上的线程概念。Linux将所有执行实体都称为<strong>任务（Task）</strong>，每一个任务概念上都类似于一个单线程，具有内存空间、执行实体、文件资源。共享同一个内存空间的多个任务构成了一个进程。</p><table><thead><tr><th>系统调用</th><th>作用</th></tr></thead><tbody><tr><td>fork</td><td>复制当前进程</td></tr><tr><td>exec</td><td>使用新的可执行映像覆盖当前可执行映像</td></tr><tr><td>clone</td><td>创建子进程并从指定位置开始执行</td></tr></tbody></table><p><strong>fork函数产生一个和当前进程完全一样的新进程，并和当前进程一同从fork函数返回。</strong></p><pre><code class="hljs jboss-cli">pid_t pid;<span class="hljs-keyword">if</span><span class="hljs-params">(<span class="hljs-attr">pid</span> == fork()</span>)&#123;<span class="hljs-string">...</span>&#125;</code></pre><ul><li><p>调用fork函数后，新的任务启动并和本任务一起从fork函数返回。<strong>本任务fork返回新任务的pid，新任务fork返回0</strong>。</p></li><li><p>fork不复制原任务的内存空间，而是和原任务一起共享一个<strong>写时复制/写时拷贝（Copy on Write，COW）</strong>的内存空间。写时复制指的是<strong>两个任务可以同时自由读取内存，但任意一个任务试图对内存进行修改时，内存就会复制一份提供给修改方单独使用，避免影响到其他任务使用。</strong></p></li><li><p><strong>exec可以用新的可执行映像替换当前的可执行影响</strong>，所以在fork产生一个新的任务之后，新任务调用exec来执行新的可执行文件。</p></li><li><p><strong>clone可以产生一个新任，从指定位置开始执行，可选共享当前进程的内存空间和文件等</strong>。</p></li></ul><pre><code class="hljs oxygene">int clone(int <span class="hljs-comment">(*fn)(void*)</span>, void* child_stack, int <span class="hljs-keyword">flags</span>, void* arg);</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE5MTk0MDU1NTAx?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="写时复制"></p><h3 id="1-6-2-线程安全"><a href="#1-6-2-线程安全" class="headerlink" title="1.6.2 线程安全"></a><strong>1.6.2 线程安全</strong></h3><p>1.在多线程环境中，可访问的全局变量和堆数据随时都可能被其他的线程改变。多线程程序在<strong>并发时数据的一致性</strong>非常重要。</p><p>2.单指令的操作称为<strong>原子的（Atomic）</strong>，单条指令的执行是不会被打断的。例如自增（++）会被操作系统编译为汇编代码后不止一条指令，所以有可能执行一半就被调度系统打断，去执行别的代码，这不是线程安全的。</p><table><thead><tr><th>Windows API</th><th>作用</th></tr></thead><tbody><tr><td>InterlockedExchange</td><td>原子地交换两个值</td></tr><tr><td>InterlockedDecrement</td><td>原子地减少一个值</td></tr><tr><td>InterlockedIncrement</td><td>原子地增加一个值</td></tr><tr><td>InterlockedXor</td><td>原子地进行异或操作</td></tr></tbody></table><p>3.<strong>同步</strong>是指在一个线程访问数据未结束的时候。其他线程不得对同一个数据进行访问，如此对数据的访问被原子化了。</p><p>4.同步最常用的方法是使用<strong>锁（Lock）</strong>。锁是一种非强制机制，每一个线程在访问数据资源之前需试图<strong>获取（Acquire）</strong>锁，并在访问结束之后<strong>释放（Release）</strong>锁。<strong>在锁已经被占用的时候试图获取锁，线程会等待，直到锁被重新可用。</strong></p><p>5.<strong>二元信号量（Binary Semaphore）</strong>是最简单的锁，有<strong>占用与非占用</strong>两种状态。它适合只能被唯一一个线程独占访问的资源。对于允许多个线程并发访问的资源，多元信号量简称<strong>信号量（Semaphore）</strong>。<strong>一个初始值为N的信号量允许N个线程并发访问。</strong>线程访问资源的时候对信号量的操作步骤如下：</p><ul><li>将信号量的值减1</li><li>如果信号量的值小于0，则进入等待状态，否则继续执行。访问完资源后，线程释放信号量</li><li>将信号量的值加1</li><li>如果信号量的值小于1，唤醒一个等待中的线程</li></ul><p>6.<strong>互斥量（Mutex）</strong>和二元信号量类似，资源同时允许一个线程访问。<strong>信号量在整个系统中可以被任意线程获取或释放</strong>，即同一个信号量可以被系统中的任意一个线程获取之后由另一个线程释放。<strong>互斥量要求哪个线程获取互斥量，哪个线程负责释放互斥量。</strong></p><p>7.<strong>临界区（Critical Section）</strong>是比互斥量更加严格的同步手段。把临界区的锁获取称为进入临界区，锁的释放称为离开临界区。<strong>互斥量和信号量在系统的任何进程里都是可见的，即一个进程创建的互斥量或信号量，另一个进程试图去获取该锁是合法的。临界区作用范围仅限于本进程，其他进程无法获取该锁。</strong></p><p>8.<strong>读写锁（Read-Write Lock）</strong>是一种特定的场合的同步。对于同一个锁，读写锁有<strong>共享的（Shard）</strong>或<strong>独占的（Exclusive）</strong>两种获取方式。</p><ul><li><p>当锁处于自由状态时，试图以任何一种方式获取锁都能成功，并将锁置于对应状态。</p></li><li><p>如果锁处于共享状态，其他线程以共享的方式获取锁仍会成功，此时锁分配给多个线程。</p></li><li><p>如果其他线程试图以独占的方式获取已经处于共享状态的锁，那么它必须等待锁被所有的线程释放。</p></li><li><p>处于独占的锁阻止任何其他线程获取该锁。</p></li></ul><table><thead><tr><th>读写锁状态</th><th>以共享方式获取</th><th>以独占方式获取</th></tr></thead><tbody><tr><td>自由</td><td>成功</td><td>成功</td></tr><tr><td>共享</td><td>成功</td><td>等待</td></tr><tr><td>独占</td><td>等待</td><td>等待</td></tr></tbody></table><p>9.条件变量（Condition Variable）类似于一个栅栏。</p><ul><li><p>线程可以等待条件变量，一个条件变量可以可以被多个线程等待</p></li><li><p>线程可以唤醒条件变量，此时某个或所有等待此条件的变量的线程都会被唤醒并继续支持</p></li></ul><p><strong><strong>未完待续，下次继续补在后面。。。</strong></strong></p><p><strong><em>=================================================</em></strong></p><p><strong><strong>继续。。。</strong></strong></p><p>10.一个函数被重入，表示这个函数没有执行完成，由于外部因素或内部调用，又一次进入该函数执行。只有两种情况：</p><ul><li><strong>多个线程同时执行这个函数</strong></li><li><strong>函数自身调用自身（递归调用）</strong></li></ul><p>一个函数是<strong>可重入的（Reentrant）</strong>，说明该函数被重入之后不会产生任何不良后果，可以在多线程环境中安全使用。如要成为可重入，需有以下特点：</p><ul><li>不使用任何<strong>（局部）静态</strong>或<strong>全局的非const变量</strong></li><li>不返回任何<strong>（局部）静态</strong>或<strong>全局的非const变量的指针</strong></li><li>仅依赖于调用方提供的参数</li><li>不依赖于任何单个资源的锁（mutex等）</li><li>不调用任何不可重入的函数</li></ul><p>11.过度优化：<strong>编译器进行优化时，有可能为了提高变量的访问速度，把变量放到某个寄存器中却不写回；也有可能为了效率而交换毫不相干的两条相邻指令。</strong></p><p>使用<strong>volatile</strong>关键字试图阻止编译器过度优化。</p><ul><li>阻值编译器为了提高速度将一个变量缓存到寄存器内而不写回</li><li>阻值编译器调整操作volatile变量的指令顺序</li></ul><p><strong>CPU进行动态调度时，在执行程序时为了提高效率可能交换指令的顺序。</strong></p><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><span class="hljs-comment">C++中new包含两个步骤：(1)分配内存、(2)调用析构函数</span><span class="hljs-comment">pInst = new T 包含三个步骤：(1)分配内存、(2)在内存的位置上调用构造函数、(3)将内存的地址赋值给pInst，(2)(3)顺序是可以颠倒的。</span><span class="hljs-comment">*/</span><span class="hljs-keyword">volatile</span> T *pInst = <span class="hljs-number">0</span>;<span class="hljs-function">T* <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(pInst == <span class="hljs-literal">NULL</span>)&#123;lock();<span class="hljs-keyword">if</span>(pInst == <span class="hljs-literal">NULL</span>）pInst = <span class="hljs-keyword">new</span> T;unlock();&#125;<span class="hljs-keyword">return</span> pInst;&#125;</code></pre><p>通常情况下调用CPU提供的一条指令，通常被称为<strong>barrier</strong>，一条barrier指令会阻值CPU将该指令之前的指令交换到barrier之后。</p><pre><code class="hljs pgsql"><span class="hljs-keyword">if</span>(!pInst)&#123;T *<span class="hljs-keyword">temp</span> = <span class="hljs-built_in">new</span> T;barrier();pInst = <span class="hljs-keyword">temp</span>;&#125;</code></pre><h3 id="1-6-3-多线程内部情况"><a href="#1-6-3-多线程内部情况" class="headerlink" title="1.6.3 多线程内部情况"></a><strong>1.6.3 多线程内部情况</strong></h3><p>1.<strong>线程的并发执行是由多处理器或操作系统调度来实现的。</strong>用户实际使用的线程并不是内核线程，而是存在于用户态的用户线程。用户态线程并不一定在操作系统内核中对应同等数量的内核线程。</p><ul><li><strong>一对一模型</strong>：一个用户使用的线程唯一对应一个内核线程</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzIxMTcxMjQ3NzEz?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="一对一线程模型"></p><p>优点：线程之间<strong>真正的并发</strong>，一个线程阻塞，其他线程执行不受影响。<br>缺点：<strong>操作系统限制了内核线程的数量</strong>，一对一模型的数量受到限制；<strong>线程调度时上下文切换开销大，导致用户线程执行效率低下。</strong></p><ul><li><strong>多对一模型</strong>：<strong>多个用户线程映射到一个内核线程上</strong>，线程之间的切换由用户态的代码决定。</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzIxMTcxODMyNjky?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="多对一线程模型"></p><p>优点：<strong>高效的上下文切换和几乎无限制的线程数量。</strong><br>缺点：如果一个用户线程阻塞，那么所有线程都无法得到执行，内核线程也随之阻塞。</p><ul><li><strong>多对多模型</strong>：将多个用户线程映射到少数但不止一个内核线程上。</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzIxMTcyMzI2Nzg5?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="多对多线程模型"></p><p>优点：一个用户线程阻塞不会使所有用户线程阻塞，因为此时还会有别的线程可以被调度执行。</p><p><strong>* <em>终于完了。。。后面就不会跟着目录写了。。。</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——虚拟地址空间</title>
    <link href="/2020/06/27/virtual-address-space/"/>
    <url>/2020/06/27/virtual-address-space/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>接着第一章继续，part.2。。。</em> *</strong></p><h1 id="第一章-温故而知新"><a href="#第一章-温故而知新" class="headerlink" title="第一章 温故而知新"></a><strong>第一章 温故而知新</strong></h1><h2 id="1-5-内存不够怎么办"><a href="#1-5-内存不够怎么办" class="headerlink" title="1.5 内存不够怎么办"></a><strong>1.5 内存不够怎么办</strong></h2><p>1.早期的计算机中，程序直接运行在物理内存上，即程序在运行时所访问的地址都是物理地址。计算机将有限的物理内存分配给多个程序使用。这种简单的内存分配策略有很多问题。</p><ul><li><p><strong>地址空间不隔离</strong><br>所有程序直接访问物理地址，程序所使用的内存空间不是相互隔离的。恶意程序可以很容易改写其他程序的内存数据。</p></li><li><p><strong>内存使用效率低</strong><br>一个程序执行时，监控程序直接将整个程序装入内存中然后开始执行。如果要运行一个需要内存非常大的程序，此时剩余可用的内存已经不够了，此时可以将其他程序的数据暂时写入磁盘，等到要用时再读回来。整个过程中有大量的数据在换入换出，导致效率十分低下。</p></li><li><p><strong>程序运行的地址不确定</strong><br>程序每次装入运行时，需要给它从内存中分配一块足够大的空闲区域，此时空闲区域的位置是不确定的。这样影响了之后访问数据和指令跳转时的目标地址，涉及程序的重定位（PS:在后面的链接部分有讲，看了之后真是恍然大悟。。。）。</p></li></ul><p>解决这些问题的法宝：增加中间层，即使用一种间接的地址访问方法。把程序给出的地址看作一种<strong>虚拟地址（Virtual Address）</strong>，通过某些<strong>映射方法</strong>，将<strong>虚拟地址转换成实际的物理地址</strong>。只要能妥善地控制这个虚拟地址到物理地址的映射过程，就可以保证任意一个程序所能访问的物理内存跟另一个程序相互不重叠，达到地址空间隔离的效果。</p><h3 id="1-5-1-关于隔离"><a href="#1-5-1-关于隔离" class="headerlink" title="1.5.1 关于隔离"></a><strong>1.5.1 关于隔离</strong></h3><p>1.所谓地址空间可以想象成一个很大的数组，每个数组的元素都是一个字节，这个数组的大小由地址空间的地址长度决定。地址空间分为两种：<strong>虚拟地址空间（Virtual Address Space）</strong>和<strong>物理地址空间（Physical Address Space）</strong>。物理地址空间是实实在在存在的。虚拟地址空间是指虚拟的、人们想象出来的地址空间，其实它并不存在，<strong>每个进程都有自己独立的虚拟空间，而且每个进程只能访问自己的地址空间</strong>，有效地做到了进程的隔离。</p><h3 id="1-5-2-分段（Segmentation）"><a href="#1-5-2-分段（Segmentation）" class="headerlink" title="1.5.2 分段（Segmentation）"></a><strong>1.5.2 分段（Segmentation）</strong></h3><p>1.最开始使用<strong>分段（Segmentation）</strong>的方法，基本思路是把一段与程序所需要的内存空间大小的虚拟空间映射到某个地址空间。把这两块相同大小的地址空间一一映射。即<strong>虚拟空间中的每个字节相对应于物理空间中的每个字节</strong>。映射过程由软件来设置。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE2MjI1MTMwNTY5?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="段映射机制"></p><p>分段的方法解决了第一个和第三个问题。做到了<strong>地址隔离</strong>、<strong>程序不再需要重定位</strong>。但依旧没有解决内存使用效率的问题。分段对内存区域的映射以程序为单位，还是会将整个程序换入换出到磁盘。</p><h3 id="1-5-3-分页（Paging）"><a href="#1-5-3-分页（Paging）" class="headerlink" title="1.5.3 分页（Paging）"></a><strong>1.5.3 分页（Paging）</strong></h3><p>1.根据程序的<strong>局部性原理</strong>，<strong>当一个程序在运行时，在某个时间段内，它只是频繁地用到了一小部分数据</strong>。使用更小粒度的内存分割和映射的方法，使程序的局部性原理得到充分利用。</p><p>2.<strong>分页是将地址空间人为地等分为固定大小的页</strong>，每一页的大小由硬件决定，或硬件支持多种大小的页，操作系统决定页的大小。但在<strong>同一时刻只能选择一种大小</strong>。目前几乎所有的PC上的操作系统都使用<strong>4KB</strong>大小的页。</p><p>3.<strong>当进程的虚拟地址空间按页分割时，把常用的的数据和代码页装载到内存中，把不常用的代码和数据保存在磁盘里，当需要用的时候从磁盘中读取</strong>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE2MjMxMjQ5NjE1?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="进程虚拟空间、物理空间和磁盘之间的页映射关系"></p><p>虚拟空间的页叫做<strong>虚拟页（VP，Virtual Page）</strong>，物理内存中的页叫做<strong>物理页（PP，Physical Page）</strong>，磁盘中的页叫做<strong>磁盘页（DP，Disk Page）</strong>。有些虚拟空间的页被映射到同一个物理页，实现了<strong>内存共享</strong>。</p><p>4.当进程所需的页不在内存中时，硬件会捕获此消息，即<strong>页错误（Page Fault）</strong>，操作系统接管进程，将需要的页从磁盘中读出并装入内存，之后建立映射关系。</p><p>5.保护也是页映射的目的之一，每个页可以设置权限属性。</p><p>6.虚拟存储的实现需要依靠硬件的支持。几乎所有的硬件都采用<strong>MMU（Memory Management Unit）</strong>部件进行页映射。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE2MjMyNTA5NDc2?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="虚拟地址到物理地址的转换"></p><p>在页映射模式下，CPU发出Virtual Address，即虚拟地址。经过MMU转换变成Physical Address。</p><p><strong>* <em>下次继续线程相关吧。。。</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接、装载与库——计算机组成</title>
    <link href="/2020/06/27/computer-composition/"/>
    <url>/2020/06/27/computer-composition/</url>
    
    <content type="html"><![CDATA[<p><strong>* <em>从这篇开始连续记录我的读书笔记，将书中重要的知识点总结，方便自己以后快速回忆与阅读。那就先从《程序员的自我修养——装载、链接与库》第一章开始喽。</em> *</strong></p><h1 id="第一章-温故而知新"><a href="#第一章-温故而知新" class="headerlink" title="第一章 温故而知新"></a><strong>第一章 温故而知新</strong></h1><h2 id="1-1-从Hello-World-说起"><a href="#1-1-从Hello-World-说起" class="headerlink" title="1.1 从Hello World 说起"></a><strong>1.1 从Hello World 说起</strong></h2><p>无</p><h2 id="1-2-万变不离其宗"><a href="#1-2-万变不离其宗" class="headerlink" title="1.2 万变不离其宗"></a><strong>1.2 万变不离其宗</strong></h2><p>1.计算机中有三个最为关键的部件，分别为<strong>中央处理器CPU</strong>、<strong>内存</strong>和<strong>I/O控制芯片</strong>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE1MTkzMjQ5MjE5?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="早期计算机硬件结构"></p><p>早期的CPU的核心频率与内存一样，所以直接连接在<strong>同一个总线（Bus）上</strong>。但为了协调I/O设备与总线之间的速度，<strong>一般每个设备都会有一个相应的I/O控制器</strong>。</p><p>2.由于CPU核心频率的提升，且远远快于内存的速度，于是产生了与<strong>内存频率相一致的系统总线</strong>，而CPU采用<strong>倍频的方式与系统总线进行通信</strong>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE1MTk0NDE4MDIx?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="硬件结构框架"></p><p>为了协调CPU、内存和高速的图形设备，专门设计了一个<strong>高速的北桥芯片</strong>，以便它们之间能够高速地交换数据。但如果相对低速的设备全部连接在北桥上，北桥同时处理不同速度的设备，设计会十分复杂。于是设计了<strong>专门处理低速设备的南桥（Southbridge）芯片</strong>,将低速设备都连接在南桥上，由南桥汇总后连接到北桥上。90年代时，PC在系统总线上采用PCI结构，在低速设备上采用ISA总线。</p><p>3.<strong>多对称处理器（SMP，Symmetry Multi-Processing）</strong>，每个CPU在系统中所处地位和所发挥的功能一样，是相互对称的。<strong>多核处理器（Multi-core Processor）</strong>实际上就是SMP的简化版，它们之间的区别很小，逻辑上来看它们是完全相同的。区别在于多核和SMP在<strong>缓存共享</strong>等方面有细微的差别，使得程序在优化上可以有针对性地处理。</p><h2 id="1-3-站得高，望得远"><a href="#1-3-站得高，望得远" class="headerlink" title="1.3 站得高，望得远"></a><strong>1.3 站得高，望得远</strong></h2><p>1.计算机系统软件体系结构采用一种层的结构。</p><blockquote><p>“计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。”</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE1MjAxMTI3OTI1?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="计算机软件体系结构"></p><ul><li><p>每个层次之间都需要相互通信，一般将通信的协议成为<strong>接口（Interface）</strong>，接口的下层是接口提供者，由它定义接口；接口的上层是接口的使用者，它使用接口来实现所需功能。</p></li><li><p>从整体层次结构上来看，开发工具与应用程序是是属于同一个层次的，都使用操作系统<strong>应用程序编程接口（Application Programming Interface）</strong>。应用程序接口的提供者运行库，什么样的运行库提供什么样的API。运行库使用操作系统提供的<strong>系统调用接口（System call Interface）</strong>,系统调用接口在实现中往往以<strong>软件中断（Software Interrupt）</strong>的方式提供。</p></li></ul><h2 id="1-4-操作系统做什么"><a href="#1-4-操作系统做什么" class="headerlink" title="1.4 操作系统做什么"></a><strong>1.4 操作系统做什么</strong></h2><blockquote><p><strong>操作系统的一个功能是提供抽象的接口，另外一个主要功能是管理硬件资源。</strong></p></blockquote><h3 id="1-4-1-不要让CPU打盹"><a href="#1-4-1-不要让CPU打盹" class="headerlink" title="1.4.1 不要让CPU打盹"></a><strong>1.4.1 不要让CPU打盹</strong></h3><p>1.如何高效、充分的利用CPU？</p><ul><li><p>计算机发展早期，为了充分利用CPU资源，编写了一个监控程序，当某个程序暂时无需使用CPU时，监控程序就把另外正在等待CPU资源的程序启动，使<strong>CPU充分利用</strong>。这种方法被称为<strong>多道程序（Multiprogramming）</strong>。其最大的问题是程序之间的调度太粗糙，程序之间不分轻重缓急。</p></li><li><p>经过改进，程序运行模式变成一种协作模式，即每个程序运行一段时间后都主动让出CPU给其他程序，使得一段时间内每个程序都有机会运行一小段时间。这种程序协作模式叫做<strong>分时系统（Time-Sharing System）</strong>。但如果一个程序一直霸占CPU，那么其他程序都得等着。</p></li><li><p><strong>多任务（Multi-tasking）系统</strong>，操作系统接管了所有的硬件资源，并且本身运行在一个手硬件保护的级别。所有的应用程序都以<strong>进程（Process）</strong>的方式运行在比操作系统权限更低的级别，<strong>每个进程都有自己独立的地址空间，使得进程之间的地址空间相互隔离。</strong></p></li><li><p>CPU由操作系统统一进行分配，<strong>每个进程根据进程优先级的高低都有机会得到CPU</strong>，如果运行时间超出了一定时间，操作系统会暂停该进程，将CPU资源分配给其他等待运行的进程。这种分配方式即<strong>抢占式（Preemptive）</strong>，<strong>操作系统可以强制剥夺并且分配给它认为目前最需要的进程。</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE1MjEzNzQ3MzQ4?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="进程转换流程"></p></li></ul><h3 id="1-4-2-设备驱动"><a href="#1-4-2-设备驱动" class="headerlink" title="1.4.2 设备驱动"></a><strong>1.4.2 设备驱动</strong></h3><p>1.当成熟的操作系统出现以后，硬件逐渐被抽象成了一系列概念。在UNIX中，硬件设备的访问跟访问普通文件一样。从硬件细节中解放，将繁琐的的硬件细节全交给操作系统中的<strong>硬件驱动（Device Driver）程序</strong>来完成。</p><p>2.文件系统是操作系统中最重要的部分之一，文件系统管理者磁盘中文件的存储方式。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzE1MjE1MzM1NTM1?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="文件在磁盘中的结构"></p><p>硬盘的结构介绍：</p><ul><li><p>硬盘基本存储单位为<strong>扇区（Sector）</strong>，每个扇区一般为512字节。一个磁盘往往有多个盘片，每个盘片分两面，每面按照同心圆划分为若干个磁道，每个磁道划分为若干个扇区。</p></li><li><p>如果按照每个磁道都拥有相同的数量的扇区，那么靠近盘面外围的磁道密度肯定比内圈更加稀疏。但如果不同的磁道扇区数又不同，计算起来就十分麻烦。现代硬盘为了屏蔽这些复杂的硬件细节，普遍使用<strong>LBA（Logical Block Address）</strong>的方式，即整个硬盘中所有的扇区从0开始编号，一直到最后一个扇区，这个扇区编号叫做<strong>逻辑扇区号</strong>。</p></li></ul><p><strong>* <em>下次的读书笔记将总结第一章剩下的内容，主要为内存及其分配机制、线程相关等内容。</em> *</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链接、装载与库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初来乍到，请多多指教</title>
    <link href="/2020/06/26/hello-world/"/>
    <url>/2020/06/26/hello-world/</url>
    
    <content type="html"><![CDATA[<h3 id="学习的日子"><a href="#学习的日子" class="headerlink" title="学习的日子"></a>学习的日子</h3><p>学习，是一个漫长的经历。期间的快乐和苦痛只有自己感受最深。</p><p>学习的路程——道阻且长，但在这路上最大的动力就是内心的信念和兴趣了。</p><p>学习也有一段时间了，其实内心一直反感诸如此类的博客，认为有这时间不如多看看几页书、多想想项目方案。但前天施老师的一句话让我重新思考了这个问题。没错，人也是一种遵循自然法则的生物。到了一定年龄，其实各机能就会到达顶峰，随后而来的就是下滑。这其中最可怕的就是记忆力下滑。换个说法，说哲学点儿，我追不上时间。时光匆匆，白驹过隙，时间的流逝不留下一丝痕迹，表象能确认的可能就是那钟表滴答滴答的声音了吧。但我有时间没有的能力，我可以将一切经历记录下来，让时间留在这些记录中。</p><p>路虽弥,不行不至；事虽小,不做不成。未来的路还很长，做最好的自己，尽最大的能力，不让自己后悔就好。</p><p>第一次写blog，没个主题，也不知道写了些什么，最后还是送给自己一句话吧：桃李不言，下自成蹊。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感想随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
